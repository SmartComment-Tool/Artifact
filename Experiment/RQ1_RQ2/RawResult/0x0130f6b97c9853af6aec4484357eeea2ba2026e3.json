[
  {
    "contract": "MultiSigWallet",
    "function": "getTransactionIds",
    "explanation": "Function returns transaction IDs beyond filtered list length if 'to' exceeds available entries.",
    "contract_code": "\n=== Implementation of Function getTransactionIds(uint256,uint256,bool,bool) ===\nfunction getTransactionIds(uint from, uint to, bool pending, bool executed)\r\n        public\r\n        constant\r\n        returns (uint[] _transactionIds)\r\n    {\r\n        uint[] memory transactionIdsTemp = new uint[](transactionCount);\r\n        uint count = 0;\r\n        uint i;\r\n        for (i=0; i<transactionCount; i++)\r\n            if (   pending && !transactions[i].executed\r\n                || executed && transactions[i].executed)\r\n            {\r\n                transactionIdsTemp[count] = i;\r\n                count += 1;\r\n            }\r\n        _transactionIds = new uint[](to - from);\r\n        for (i=from; i<to; i++)\r\n            _transactionIds[i - from] = transactionIdsTemp[i];\r\n    }\n    ",
    "rewritten_code": {
      "getTransactionIds": "function getTransactionIds(uint from, uint to, bool pending, bool executed) public constant returns (uint[] _transactionIds) {\n        uint[] memory transactionIdsTemp = new uint[](transactionCount);\n        uint count = 0;\n        for (uint i=0; i<transactionCount; i++) {\n            if ((pending && !transactions[i].executed) || (executed && transactions[i].executed)) {\n                transactionIdsTemp[count] = i;\n                count++;\n            }\n        }\n        require(to <= count && from <= to);\n        _transactionIds = new uint[](to - from);\n        for (uint j=from; j<to; j++) {\n            _transactionIds[j - from] = transactionIdsTemp[j];\n        }\n    }"
    }
  },
  {
    "contract": "MultiSigWallet",
    "function": "executeTransaction",
    "explanation": "Function restricts execution to owners but comment permits anyone",
    "contract_code": "\n=== Implementation of Function executeTransaction(uint256) ===\nfunction executeTransaction(uint transactionId)\r\n        public\r\n        ownerExists(msg.sender)\r\n        confirmed(transactionId, msg.sender)\r\n        notExecuted(transactionId)\r\n    {\r\n        if (isConfirmed(transactionId)) {\r\n            Transaction storage txn = transactions[transactionId];\r\n            txn.executed = true;\r\n            if (external_call(txn.destination, txn.value, txn.data.length, txn.data))\r\n                Execution(transactionId);\r\n            else {\r\n                ExecutionFailure(transactionId);\r\n                txn.executed = false;\r\n            }\r\n        }\r\n    }\n    \n=== Functions that function executeTransaction internally calls ===\nfunction external_call(address destination, uint value, uint dataLength, bytes data) private returns (bool) {\r\n        bool result;\r\n        assembly {\r\n            let x := mload(0x40)   // \"Allocate\" memory for output (0x40 is where \"free memory\" pointer is stored by convention)\r\n            let d := add(data, 32) // First 32 bytes are the padded length of data, so exclude that\r\n            result := call(\r\n                sub(gas, 34710),   // 34710 is the value that solidity is currently emitting\r\n                destination,\r\n                value,\r\n                d,\r\n                dataLength,        // Size of the input (in bytes) - this is what fixes the padding problem\r\n                x,\r\n                0                  // Output is ignored, therefore the output size is zero\r\n            )\r\n        }\r\n        return result;\r\n    }\nfunction isConfirmed(uint transactionId)\r\n        public\r\n        constant\r\n        returns (bool)\r\n    {\r\n        uint count = 0;\r\n        for (uint i=0; i<owners.length; i++) {\r\n            if (confirmations[transactionId][owners[i]])\r\n                count += 1;\r\n            if (count == required)\r\n                return true;\r\n        }\r\n    }\nmodifier confirmed(uint transactionId, address owner) {\r\n        require(confirmations[transactionId][owner]);\r\n        _;\r\n    }\nmodifier notExecuted(uint transactionId) {\r\n        require(!transactions[transactionId].executed);\r\n        _;\r\n    }\nmodifier ownerExists(address owner) {\r\n        require(isOwner[owner]);\r\n        _;\r\n    }",
    "rewritten_code": {
      "executeTransaction": "function executeTransaction(uint transactionId)\n    public\n    confirmed(transactionId, msg.sender)\n    notExecuted(transactionId)\n{\n    if (isConfirmed(transactionId)) {\n        Transaction storage txn = transactions[transactionId];\n        txn.executed = true;\n        if (external_call(txn.destination, txn.value, txn.data.length, txn.data))\n            Execution(transactionId);\n        else {\n            ExecutionFailure(transactionId);\n            txn.executed = false;\n        }\n    }\n}"
    }
  }
]