[
  {
    "contract": "MINIWORLDCUPINU",
    "function": "_transfer",
    "explanation": "Comment references cooldown check, but code enforces max transaction amount without cooldown logic.",
    "contract_code": "\n=== Implementation of Function _transfer(address,address,uint256) ===\nfunction _transfer(address from, address to, uint256 amount) private {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n        require(amount > 0, \"Transfer amount must be greater than zero\");\n\n\n        if (from != owner() && to != owner()) {\n            require(!bots[from] && !bots[to]);\n            _feeAddr1 = 0;\n            _feeAddr2 = (_reduceTaxCountdown==0)?_finalTax:_initialTax;\n            if (from == uniswapV2Pair && to != address(uniswapV2Router) && ! _isExcludedFromFee[to] && cooldownEnabled) {\n                require(amount <= _maxTxAmount, \"Exceeds the _maxTxAmount.\");\n                require(balanceOf(to) + amount <= _maxWalletSize, \"Exceeds the maxWalletSize.\");\n                if(_reduceTaxCountdown>0){_reduceTaxCountdown--;}\n            }\n\n\n            uint256 contractTokenBalance = balanceOf(address(this));\n            if (!inSwap && from != uniswapV2Pair && swapEnabled && contractTokenBalance>0 && _reduceTaxCountdown<10) {\n                swapTokensForEth(contractTokenBalance);\n                uint256 contractETHBalance = address(this).balance;\n                if(contractETHBalance > 0) {\n                    sendETHToFee(address(this).balance);\n                }\n            }\n        }else{\n          _feeAddr1 = 0;\n          _feeAddr2 = 0;\n        }\n\n        _tokenTransfer(from,to,amount);\n    }\n    \n=== Functions that function _transfer internally calls ===\nfunction _tokenTransfer(address sender, address recipient, uint256 amount) private {\n        _transferStandard(sender, recipient, amount);\n    }\nfunction balanceOf(address account) public view override returns (uint256) {\n        return tokenFromReflection(_rOwned[account]);\n    }\nfunction owner() public view returns (address) {\n        return _owner;\n    }\nfunction sendETHToFee(uint256 amount) private {\n        _feeAddrWallet.transfer(amount);\n    }\nfunction swapTokensForEth(uint256 tokenAmount) private lockTheSwap {\n        address[] memory path = new address[](2);\n        path[0] = address(this);\n        path[1] = uniswapV2Router.WETH();\n        _approve(address(this), address(uniswapV2Router), tokenAmount);\n        uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\n            tokenAmount,\n            0,\n            path,\n            address(this),\n            block.timestamp\n        );\n    }",
    "rewritten_code": {
      "_transfer": "function _transfer(address from, address to, uint256 amount) private {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n        require(amount > 0, \"Transfer amount must be greater than zero\");\n\n        if (from != owner() && to != owner()) {\n            require(!bots[from] && !bots[to]);\n            _feeAddr1 = 0;\n            _feeAddr2 = (_reduceTaxCountdown==0)?_finalTax:_initialTax;\n            if (from == uniswapV2Pair && to != address(uniswapV2Router) && ! _isExcludedFromFee[to] && cooldownEnabled) {\n                require(cooldown[to] <= block.timestamp, \"Cooldown active\");\n                cooldown[to] = block.timestamp + (60 seconds);\n                require(amount <= _maxTxAmount, \"Exceeds the _maxTxAmount.\");\n                require(balanceOf(to) + amount <= _maxWalletSize, \"Exceeds the maxWalletSize.\");\n                if(_reduceTaxCountdown>0){_reduceTaxCountdown--;}\n            }\n\n            uint256 contractTokenBalance = balanceOf(address(this));\n            if (!inSwap && from != uniswapV2Pair && swapEnabled && contractTokenBalance>0 && _reduceTaxCountdown<10) {\n                swapTokensForEth(contractTokenBalance);\n                uint256 contractETHBalance = address(this).balance;\n                if(contractETHBalance > 0) {\n                    sendETHToFee(address(this).balance);\n                }\n            }\n        }else{\n          _feeAddr1 = 0;\n          _feeAddr2 = 0;\n        }\n\n        _tokenTransfer(from,to,amount);\n    }"
    }
  }
]