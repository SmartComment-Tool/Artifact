[
  {
    "contract": "HALAL",
    "function": "_transfer",
    "explanation": "Incorrect fee divisor for sell burn calculation uses buyTotalFees instead of sellTotalFees.",
    "contract_code": "\n=== Implementation of Function _transfer(address,address,uint256) ===\nfunction _transfer(address from, address to, uint256 amount) internal override {\r\n        require(from != address(0), \"ERC20: transfer from the zero address\");\r\n        require(to != address(0), \"ERC20: transfer to the zero address\");\r\n        require(amount > 0, \"amount must be greater than 0\");\r\n        \r\n        if(!tradingActive){\r\n            require(_isExcludedFromFees[from] || _isExcludedFromFees[to], \"Trading is not active.\");\r\n        }\r\n\r\n        if(!earlyBuyPenaltyInEffect() && tradingActive){\r\n            require((!blacklist[from] && !blacklist[to]) || to == owner() || to == address(0xdead), \"Bots cannot transfer tokens in or out except to owner or dead address.\");\r\n        }\r\n        \r\n        if(limitsInEffect){\r\n            if (from != owner() && to != owner() && to != address(0) && to != address(0xdead) && !_isExcludedFromFees[from] && !_isExcludedFromFees[to]){\r\n                \r\n                if (transferDelayEnabled){\r\n                    if (to != address(dexRouter) && to != address(lpPair)){\r\n                        require(_holderLastTransferTimestamp[tx.origin] < block.number - 2 && _holderLastTransferTimestamp[to] < block.number - 2, \"_transfer:: Transfer Delay enabled.  Try again later.\");\r\n                        _holderLastTransferTimestamp[tx.origin] = block.number;\r\n                        _holderLastTransferTimestamp[to] = block.number;\r\n                    }\r\n                }\r\n                 \r\n                if (automatedMarketMakerPairs[from] && !_isExcludedMaxTransactionAmount[to]) {\r\n                    require(amount <= maxBuyAmount, \"Buy transfer amount exceeds the max buy.\");\r\n                    require(amount + balanceOf(to) <= maxWallet, \"Cannot exceed max wallet\");\r\n                } \r\n                else if (automatedMarketMakerPairs[to] && !_isExcludedMaxTransactionAmount[from]) {\r\n                    require(amount <= maxSellAmount, \"Sell transfer amount exceeds the max sell.\");\r\n                }\r\n                else if (!_isExcludedMaxTransactionAmount[to]) {\r\n                    require(amount + balanceOf(to) <= maxWallet, \"Cannot exceed max wallet\");\r\n                }\r\n            }\r\n        }\r\n\r\n        uint256 contractTokenBalance = balanceOf(address(this));\r\n        \r\n        bool canSwap = contractTokenBalance >= swapTokensAtAmount;\r\n\r\n        if(canSwap && swapEnabled && !swapping && !automatedMarketMakerPairs[from] && !_isExcludedFromFees[from] && !_isExcludedFromFees[to]) {\r\n            swapping = true;\r\n            swapBack();\r\n            swapping = false;\r\n        }\r\n\r\n        bool takeFee = true;\r\n        if(_isExcludedFromFees[from] || _isExcludedFromFees[to]) {\r\n            takeFee = false;\r\n        }\r\n        \r\n        uint256 fees = 0;\r\n        uint256 tokensToBurn = 0;\r\n\r\n        if(takeFee){\r\n            if(earlyBuyPenaltyInEffect() && automatedMarketMakerPairs[from] && !automatedMarketMakerPairs[to] && !_isExcludedFromFees[to] && buyTotalFees > 0){\r\n                \r\n                if(!earlyBuyPenaltyInEffect()){\r\n                    maxBuyAmount -= 1;\r\n                }\r\n\r\n                if(!blacklist[to]){\r\n                    blacklist[to] = true;\r\n                    botsCaught += 1;\r\n                    earlyBuyers.push(to);\r\n                    emit CaughtEarlyBuyer(to);\r\n                }\r\n\r\n                fees = amount * buyTotalFees / FEE_DIVISOR;\r\n        \t    tokensForLiquidity += fees * buyLiquidityFee / buyTotalFees;\r\n                tokensForTreasury += fees * buyTreasuryFee / buyTotalFees;\r\n                tokensToBurn = fees * buyBurnFee / buyTotalFees;\r\n            }\r\n\r\n            else if (automatedMarketMakerPairs[to] && sellTotalFees > 0){\r\n                fees = amount * sellTotalFees / FEE_DIVISOR;\r\n                tokensForLiquidity += fees * sellLiquidityFee / sellTotalFees;\r\n                tokensForTreasury += fees * sellTreasuryFee / sellTotalFees;\r\n                tokensToBurn = fees * sellBurnFee / buyTotalFees;\r\n            }\r\n\r\n            else if(automatedMarketMakerPairs[from] && buyTotalFees > 0) {\r\n        \t    fees = amount * buyTotalFees / FEE_DIVISOR;\r\n        \t    tokensForLiquidity += fees * buyLiquidityFee / buyTotalFees;\r\n                tokensForTreasury += fees * buyTreasuryFee / buyTotalFees;\r\n                tokensToBurn = fees * buyBurnFee / buyTotalFees;\r\n            }\r\n            \r\n            if(fees > 0){    \r\n                super._transfer(from, address(this), fees);\r\n                if(tokensToBurn > 0){\r\n                    super._transfer(address(this), address(0xdead), tokensToBurn);\r\n                }\r\n            }\r\n        \t\r\n        \tamount -= fees;\r\n        }\r\n\r\n        super._transfer(from, to, amount);\r\n    }\n    \n=== Functions that function _transfer internally calls ===\nfunction _transfer(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) internal virtual {\r\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\r\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\r\n\r\n        uint256 senderBalance = _balances[sender];\r\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\r\n        unchecked {\r\n            _balances[sender] = senderBalance - amount;\r\n        }\r\n        _balances[recipient] += amount;\r\n\r\n        emit Transfer(sender, recipient, amount);\r\n    }\nfunction balanceOf(address account) public view virtual override returns (uint256) {\r\n        return _balances[account];\r\n    }\nfunction earlyBuyPenaltyInEffect() public view returns (bool){\r\n        return block.number < blockForPenaltyEnd;\r\n    }\nfunction owner() public view returns (address) {\r\n        return _owner;\r\n    }\nfunction swapBack() private {\r\n\r\n        uint256 contractBalance = balanceOf(address(this));\r\n\r\n        uint256 _tokensForLiquidity = tokensForLiquidity;\r\n        uint256 _tokensForTreasury = tokensForTreasury;\r\n\r\n        uint256 totalTokensToSwap = tokensForLiquidity + tokensForTreasury;\r\n        \r\n        if(contractBalance == 0 || totalTokensToSwap == 0) {return;}\r\n\r\n        if(contractBalance > swapTokensAtAmount * 10){\r\n            contractBalance = swapTokensAtAmount * 10;\r\n        }\r\n\r\n        bool success;\r\n        \r\n        uint256 liquidityTokens = contractBalance * tokensForLiquidity / totalTokensToSwap / 2;\r\n        \r\n        swapTokensForEth(contractBalance - liquidityTokens); \r\n        \r\n        uint256 ethBalance = address(this).balance;\r\n        uint256 ethForLiquidity = ethBalance;\r\n\r\n        uint256 ethForTreasury = ethBalance * tokensForTreasury / (totalTokensToSwap - (tokensForLiquidity/2));\r\n\r\n        ethForLiquidity -= ethForTreasury;\r\n            \r\n        tokensForLiquidity -= _tokensForLiquidity;\r\n        tokensForTreasury -= _tokensForTreasury;\r\n        \r\n        if(liquidityTokens > 0 && ethForLiquidity > 0){\r\n            addLiquidity(liquidityTokens, ethForLiquidity);\r\n        }\r\n\r\n        (success,) = address(treasuryAddress).call{value: address(this).balance}(\"\");\r\n    }",
    "rewritten_code": {
      "function_name": "function _transfer(address from, address to, uint256 amount) internal override {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n        require(amount > 0, \"amount must be greater than 0\");\n        \n        if(!tradingActive){\n            require(_isExcludedFromFees[from] || _isExcludedFromFees[to], \"Trading is not active.\");\n        }\n\n        if(!earlyBuyPenaltyInEffect() && tradingActive){\n            require((!blacklist[from] && !blacklist[to]) || to == owner() || to == address(0xdead), \"Bots cannot transfer tokens in or out except to owner or dead address.\");\n        }\n        \n        if(limitsInEffect){\n            if (from != owner() && to != owner() && to != address(0) && to != address(0xdead) && !_isExcludedFromFees[from] && !_isExcludedFromFees[to]){\n                \n                if (transferDelayEnabled){\n                    if (to != address(dexRouter) && to != address(lpPair)){\n                        require(_holderLastTransferTimestamp[tx.origin] < block.number - 2 && _holderLastTransferTimestamp[to] < block.number - 2, \"_transfer:: Transfer Delay enabled.  Try again later.\");\n                        _holderLastTransferTimestamp[tx.origin] = block.number;\n                        _holderLastTransferTimestamp[to] = block.number;\n                    }\n                }\n                 \n                if (automatedMarketMakerPairs[from] && !_isExcludedMaxTransactionAmount[to]) {\n                    require(amount <= maxBuyAmount, \"Buy transfer amount exceeds the max buy.\");\n                    require(amount + balanceOf(to) <= maxWallet, \"Cannot exceed max wallet\");\n                } \n                else if (automatedMarketMakerPairs[to] && !_isExcludedMaxTransactionAmount[from]) {\n                    require(amount <= maxSellAmount, \"Sell transfer amount exceeds the max sell.\");\n                }\n                else if (!_isExcludedMaxTransactionAmount[to]) {\n                    require(amount + balanceOf(to) <= maxWallet, \"Cannot exceed max wallet\");\n                }\n            }\n        }\n\n        uint256 contractTokenBalance = balanceOf(address(this));\n        \n        bool canSwap = contractTokenBalance >= swapTokensAtAmount;\n\n        if(canSwap && swapEnabled && !swapping && !automatedMarketMakerPairs[from] && !_isExcludedFromFees[from] && !_isExcludedFromFees[to]) {\n            swapping = true;\n            swapBack();\n            swapping = false;\n        }\n\n        bool takeFee = true;\n        if(_isExcludedFromFees[from] || _isExcludedFromFees[to]) {\n            takeFee = false;\n        }\n        \n        uint256 fees = 0;\n        uint256 tokensToBurn = 0;\n\n        if(takeFee){\n            if(earlyBuyPenaltyInEffect() && automatedMarketMakerPairs[from] && !automatedMarketMakerPairs[to] && !_isExcludedFromFees[to] && buyTotalFees > 0){\n                \n                if(!earlyBuyPenaltyInEffect()){\n                    maxBuyAmount -= 1;\n                }\n\n                if(!blacklist[to]){\n                    blacklist[to] = true;\n                    botsCaught += 1;\n                    earlyBuyers.push(to);\n                    emit CaughtEarlyBuyer(to);\n                }\n\n                fees = amount * buyTotalFees / FEE_DIVISOR;\n                tokensForLiquidity += fees * buyLiquidityFee / buyTotalFees;\n                tokensForTreasury += fees * buyTreasuryFee / buyTotalFees;\n                tokensToBurn = fees * buyBurnFee / buyTotalFees;\n            }\n\n            else if (automatedMarketMakerPairs[to] && sellTotalFees > 0){\n                fees = amount * sellTotalFees / FEE_DIVISOR;\n                tokensForLiquidity += fees * sellLiquidityFee / sellTotalFees;\n                tokensForTreasury += fees * sellTreasuryFee / sellTotalFees;\n                tokensToBurn = fees * sellBurnFee / sellTotalFees;\n            }\n\n            else if(automatedMarketMakerPairs[from] && buyTotalFees > 0) {\n                fees = amount * buyTotalFees / FEE_DIVISOR;\n                tokensForLiquidity += fees * buyLiquidityFee / buyTotalFees;\n                tokensForTreasury += fees * buyTreasuryFee / buyTotalFees;\n                tokensToBurn = fees * buyBurnFee / buyTotalFees;\n            }\n            \n            if(fees > 0){    \n                super._transfer(from, address(this), fees);\n                if(tokensToBurn > 0){\n                    super._transfer(address(this), address(0xdead), tokensToBurn);\n                }\n            }\n            \n            amount -= fees;\n        }\n\n        super._transfer(from, to, amount);\n    }"
    }
  }
]