[
  {
    "contract": "RamppERC721A",
    "function": "mintToAdminV2",
    "explanation": "Function uses team/or owner access but comment specifies owner-only",
    "contract_code": "\n=== Implementation of Function mintToAdminV2(address,uint256) ===\nfunction mintToAdminV2(address _to, uint256 _qty) public onlyTeamOrOwner{\n         require(_qty > 0, \"Must mint at least 1 token.\");\n         require(currentTokenId() + _qty <= collectionSize, \"Cannot mint over supply cap of 2222\");\n         _safeMint(_to, _qty, true);\n     }\n    \n=== Functions that function mintToAdminV2 internally calls ===\nfunction _safeMint(address to, uint256 quantity, bool isAdminMint) internal {\n    _safeMint(to, quantity, isAdminMint, \"\");\n  }\nfunction currentTokenId() public view returns (uint256) {\n    return _totalMinted();\n  }\nmodifier onlyTeamOrOwner() {\n    bool _isOwner = owner() == _msgSender();\n    bool _isTeam = inTeam(_msgSender());\n    require(_isOwner || _isTeam, \"Team: caller is not the owner or in Team.\");\n    _;\n  }",
    "rewritten_code": {
      "mintToAdminV2(address,uint256)": "function mintToAdminV2(address _to, uint256 _qty) public onlyOwner {\n    require(_qty > 0, \"Must mint at least 1 token.\");\n    require(currentTokenId() + _qty <= collectionSize, \"Cannot mint over supply cap of 2222\");\n    _safeMint(_to, _qty, true);\n}"
    }
  },
  {
    "contract": "RamppERC721A",
    "function": "mintToMultiple",
    "explanation": "Comment states fee may not be required but code enforces payment check",
    "contract_code": "\n=== Implementation of Function mintToMultiple(address,uint256) ===\nfunction mintToMultiple(address _to, uint256 _amount) public payable {\n        require(onlyERC20MintingMode == false, \"Only minting with ERC-20 tokens is enabled.\");\n        require(_amount >= 1, \"Must mint at least 1 token\");\n        require(_amount <= maxBatchSize, \"Cannot mint more than max mint per transaction\");\n        require(mintingOpen == true, \"Minting is not open right now!\");\n        \n        require(canMintAmount(_to, _amount), \"Wallet address is over the maximum allowed mints\");\n        require(currentTokenId() + _amount <= collectionSize, \"Cannot mint over supply cap of 2222\");\n        require(msg.value == getPrice(_amount), \"Value below required mint fee for amount\");\n\n        _safeMint(_to, _amount, false);\n    }\n    \n=== Functions that function mintToMultiple internally calls ===\nfunction _safeMint(address to, uint256 quantity, bool isAdminMint) internal {\n    _safeMint(to, quantity, isAdminMint, \"\");\n  }\nfunction canMintAmount(address _address, uint256 _amount) public view returns(bool) {\n        require(_amount >= 1, \"Amount must be greater than or equal to 1\");\n        return (_numberMinted(_address) + _amount) <= MAX_WALLET_MINTS;\n    }\nfunction currentTokenId() public view returns (uint256) {\n    return _totalMinted();\n  }\nfunction getPrice(uint256 _count) public view returns (uint256) {\n    require(_count > 0, \"Must be minting at least 1 token.\");\n\n    if(\n      usingEarlyMintIncentive == false ||\n      currentTokenId() > earlyMintTokenIdCap\n    ) {\n      return PRICE * _count;\n    }\n\n    uint256 endingTokenId = currentTokenId() + _count;\n    if(endingTokenId  <= earlyMintTokenIdCap) {\n      return EARLY_MINT_PRICE * _count;\n    }\n\n    uint256 incentiveTokenCount = earlyMintTokenIdCap - currentTokenId();\n    uint256 outsideIncentiveCount = endingTokenId - earlyMintTokenIdCap;\n\n    return (EARLY_MINT_PRICE * incentiveTokenCount) + (PRICE * outsideIncentiveCount);\n  }",
    "rewritten_code": {
      "mintToMultiple(address,uint256)": "function mintToMultiple(address _to, uint256 _amount) public payable {\n        require(onlyERC20MintingMode == false, \"Only minting with ERC-20 tokens is enabled.\");\n        require(_amount >= 1, \"Must mint at least 1 token\");\n        require(_amount <= maxBatchSize, \"Cannot mint more than max mint per transaction\");\n        require(mintingOpen == true, \"Minting is not open right now!\");\n        \n        require(canMintAmount(_to, _amount), \"Wallet address is over the maximum allowed mints\");\n        require(currentTokenId() + _amount <= collectionSize, \"Cannot mint over supply cap of 2222\");\n\n        _safeMint(_to, _amount, false);\n    }"
    }
  },
  {
    "contract": "RamppERC721A",
    "function": "mintTo",
    "explanation": "Comment states fee may not be required, but code enforces payment check.",
    "contract_code": "\n=== Implementation of Function mintTo(address) ===\nfunction mintTo(address _to) public payable {\n        require(onlyERC20MintingMode == false, \"Only minting with ERC-20 tokens is enabled.\");\n        require(getNextTokenId() <= collectionSize, \"Cannot mint over supply cap of 2222\");\n        require(mintingOpen == true, \"Minting is not open right now!\");\n        \n        require(canMintAmount(_to, 1), \"Wallet address is over the maximum allowed mints\");\n        require(msg.value == getPrice(1), \"Value needs to be exactly the mint fee!\");\n        \n        _safeMint(_to, 1, false);\n    }\n    \n=== Functions that function mintTo internally calls ===\nfunction _safeMint(address to, uint256 quantity, bool isAdminMint) internal {\n    _safeMint(to, quantity, isAdminMint, \"\");\n  }\nfunction canMintAmount(address _address, uint256 _amount) public view returns(bool) {\n        require(_amount >= 1, \"Amount must be greater than or equal to 1\");\n        return (_numberMinted(_address) + _amount) <= MAX_WALLET_MINTS;\n    }\nfunction getNextTokenId() public view returns (uint256) {\n      return _totalMinted() + 1;\n  }\nfunction getPrice(uint256 _count) public view returns (uint256) {\n    require(_count > 0, \"Must be minting at least 1 token.\");\n\n    if(\n      usingEarlyMintIncentive == false ||\n      currentTokenId() > earlyMintTokenIdCap\n    ) {\n      return PRICE * _count;\n    }\n\n    uint256 endingTokenId = currentTokenId() + _count;\n    if(endingTokenId  <= earlyMintTokenIdCap) {\n      return EARLY_MINT_PRICE * _count;\n    }\n\n    uint256 incentiveTokenCount = earlyMintTokenIdCap - currentTokenId();\n    uint256 outsideIncentiveCount = endingTokenId - earlyMintTokenIdCap;\n\n    return (EARLY_MINT_PRICE * incentiveTokenCount) + (PRICE * outsideIncentiveCount);\n  }",
    "rewritten_code": {
      "function_name": "function mintTo(address _to) public payable {\n        require(onlyERC20MintingMode == false, \"Only minting with ERC-20 tokens is enabled.\");\n        require(getNextTokenId() <= collectionSize, \"Cannot mint over supply cap of 2222\");\n        require(mintingOpen == true, \"Minting is not open right now!\");\n        require(canMintAmount(_to, 1), \"Wallet address is over the maximum allowed mints\");\n        _safeMint(_to, 1, false);\n    }"
    }
  }
]