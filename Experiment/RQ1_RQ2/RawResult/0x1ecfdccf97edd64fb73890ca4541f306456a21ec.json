[
  {
    "contract": "Metarelics",
    "function": "mint",
    "explanation": "Owner can mint without paused, supply checks via requireChecks(1).",
    "contract_code": "\n=== Implementation of Function mint() ===\nfunction mint() \r\n\t\tpublic\r\n\t\tpayable\r\n        nonReentrant\r\n\t{\r\n\t\tuint256 supply = totalSupply();\r\n\t\tif (msg.sender != owner()) {\r\n\t\t\trequireChecks(1);\r\n            require(msg.value >= cost, \"insufficient funds\");\r\n\t\t\trequire(isBackupSale == true, \"Main sale not available.\");\r\n\t\t\trequire(addressMintedBalance[msg.sender] == 0, \"max NFT per address is 1.\");\r\n\t\t}\r\n\r\n\t\t_safeMint(msg.sender, supply + 1);\r\n\t\taddressMintedBalance[msg.sender]++;\r\n\t}\n    \n=== Functions that function mint internally calls ===\nfunction _safeMint(address to, uint256 tokenId) internal virtual {\r\n        _safeMint(to, tokenId, \"\");\r\n    }\nfunction owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\nfunction requireChecks(uint256 _mintAmount) internal view {\r\n\t\trequire(paused == false, \"the contract is paused\");\r\n\t\trequire(totalSupply() + _mintAmount <= maxSupply, \"max NFT limit exceeded\");\r\n\t}\nfunction totalSupply() public view virtual override returns (uint256) {\r\n        return _allTokens.length;\r\n    }\nmodifier nonReentrant() {\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n\r\n        _status = _ENTERED;\r\n\r\n        _;\r\n\r\n        _status = _NOT_ENTERED;\r\n    }",
    "rewritten_code": {
      "mint()": "function mint() \n\t\tpublic\n\t\tpayable\n        nonReentrant\n\t{\n\t\tuint256 supply = totalSupply();\n\t\trequireChecks(1);\n\t\tif (msg.sender != owner()) {\n\t\t\trequire(msg.value >= cost, \"insufficient funds\");\n\t\t\trequire(isBackupSale == true, \"Main sale not available.\");\n\t\t\trequire(addressMintedBalance[msg.sender] == 0, \"max NFT per address is 1.\");\n\t\t}\n\n\t\t_safeMint(msg.sender, supply + 1);\n\t\taddressMintedBalance[msg.sender]++;\n\t}"
    }
  },
  {
    "contract": "Metarelics",
    "function": "secondaryMint",
    "explanation": "Owner can bypass max per address check, allowing multiple mints.",
    "contract_code": "\n=== Implementation of Function secondaryMint() ===\nfunction secondaryMint()\r\n\t\tpublic\r\n\t\tpayable\r\n        nonReentrant\r\n\t{\r\n\t\tuint256 supply = totalSupply();\r\n        requireChecks(1);\r\n\t\tif (msg.sender != owner()) {\r\n\t\t\trequire(msg.value >= cost, \"insufficient funds\");\r\n\t\t\trequire(secondMintWinners[msg.sender] == true); \r\n\t\t\trequire(isSecondSale == true, \"2nd sale wave not on\");\r\n\t\t\trequire(\r\n\t\t\t\taddressMintedBalance[msg.sender] == 0,\r\n\t\t\t\t\"max NFT per address exceeded\"\r\n\t\t\t);\r\n\t\t}\r\n\r\n\t\t_safeMint(msg.sender, supply + 1);\r\n\t\taddressMintedBalance[msg.sender]++;\r\n\t}\n    \n=== Functions that function secondaryMint internally calls ===\nfunction _safeMint(address to, uint256 tokenId) internal virtual {\r\n        _safeMint(to, tokenId, \"\");\r\n    }\nfunction owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\nfunction requireChecks(uint256 _mintAmount) internal view {\r\n\t\trequire(paused == false, \"the contract is paused\");\r\n\t\trequire(totalSupply() + _mintAmount <= maxSupply, \"max NFT limit exceeded\");\r\n\t}\nfunction totalSupply() public view virtual override returns (uint256) {\r\n        return _allTokens.length;\r\n    }\nmodifier nonReentrant() {\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n\r\n        _status = _ENTERED;\r\n\r\n        _;\r\n\r\n        _status = _NOT_ENTERED;\r\n    }",
    "rewritten_code": {
      "secondaryMint()": "function secondaryMint()\n\t\tpublic\n\t\tpayable\n        nonReentrant\n\t{\n\t\tuint256 supply = totalSupply();\n        requireChecks(1);\n\t\trequire(addressMintedBalance[msg.sender] == 0, \"max NFT per address exceeded\");\n\t\tif (msg.sender != owner()) {\n\t\t\trequire(msg.value >= cost, \"insufficient funds\");\n\t\t\trequire(secondMintWinners[msg.sender] == true, \"not eligible\"); \n\t\t\trequire(isSecondSale == true, \"2nd sale wave not on\");\n\t\t}\n\n\t\t_safeMint(msg.sender, supply + 1);\n\t\taddressMintedBalance[msg.sender]++;\n\t}"
    }
  },
  {
    "contract": "Metarelics",
    "function": "presaleMint",
    "explanation": "Presale limit check missing; allows minting >1 when maxMintable >1.",
    "contract_code": "\n=== Implementation of Function presaleMint(uint256,bytes32[]) ===\nfunction presaleMint(uint256 _mintAmount, bytes32[] calldata proof)\r\n\t\tpublic\r\n\t\tpayable\r\n        nonReentrant\r\n\t{\r\n\t\tuint256 supply = totalSupply();\r\n\t\trequireChecks(_mintAmount);\r\n\t\tif (msg.sender != owner()) {\r\n\t\t\trequire (addressMintedBalance[msg.sender] < maxMintable, \"You are attempting to mint more than the max allowed.\");\r\n\t\t\trequire(msg.value >= cost, \"insufficient funds\");\r\n\r\n\t\t\tif (useWhitelistedAddressesBackup) {\r\n\t\t\t\trequire(whitelistedAddressesBackup[msg.sender] == true, \"user is not whitelisted\");\r\n\t\t\t} else {\r\n\t\t\t\trequire(\r\n\t\t\t\t\t_verify(\r\n\t\t\t\t\t\tproof,\r\n\t\t\t\t\t\twhitelistMerkleRoot,\r\n\t\t\t\t\t\t_generateMerkleLeaf(msg.sender)\r\n\t\t\t\t\t),\r\n\t\t\t\t\t\"user is not whitelisted\"\r\n\t\t\t\t);\r\n\t\t\t}\r\n\r\n\t\t\t_safeMint(msg.sender, supply + 1);\r\n\t\t\taddressMintedBalance[msg.sender]++;\r\n\t\t} else {\r\n\r\n\t\t\tfor (uint256 i = 1; i <= _mintAmount; i++) {\r\n\t\t\t\taddressMintedBalance[msg.sender]++;\r\n\t\t\t\t_safeMint(msg.sender, supply + i);\r\n\t\t\t}\r\n\t\t}\r\n\t}\n    \n=== Functions that function presaleMint internally calls ===\nfunction _generateMerkleLeaf(address account)\r\n\t\tinternal\r\n\t\tpure\r\n\t\treturns (bytes32)\r\n\t{\r\n\t\treturn keccak256(abi.encodePacked(account));\r\n\t}\nfunction _safeMint(address to, uint256 tokenId) internal virtual {\r\n        _safeMint(to, tokenId, \"\");\r\n    }\nfunction _verify(\r\n\t\tbytes32[] memory proof,\r\n\t\tbytes32 merkleRoot,\r\n\t\tbytes32 leafNode\r\n\t) internal pure returns (bool) {\r\n\t\treturn MerkleProof.verify(proof, merkleRoot, leafNode);\r\n\t}\nfunction owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\nfunction requireChecks(uint256 _mintAmount) internal view {\r\n\t\trequire(paused == false, \"the contract is paused\");\r\n\t\trequire(totalSupply() + _mintAmount <= maxSupply, \"max NFT limit exceeded\");\r\n\t}\nfunction totalSupply() public view virtual override returns (uint256) {\r\n        return _allTokens.length;\r\n    }\nmodifier nonReentrant() {\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n\r\n        _status = _ENTERED;\r\n\r\n        _;\r\n\r\n        _status = _NOT_ENTERED;\r\n    }",
    "rewritten_code": {
      "presaleMint(uint256,bytes32[])": "function presaleMint(uint256 _mintAmount, bytes32[] calldata proof)\n\tpublic\n\tpayable\n    nonReentrant\n{\n\tuint256 supply = totalSupply();\n\trequireChecks(_mintAmount);\n\tif (msg.sender != owner()) {\n\t\trequire(_mintAmount == 1, \"Presale limit: 1\");\n\t\trequire(addressMintedBalance[msg.sender] == 0, \"Already minted\");\n\t\trequire(msg.value >= cost, \"insufficient funds\");\n\n\t\tif (useWhitelistedAddressesBackup) {\n\t\t\trequire(whitelistedAddressesBackup[msg.sender], \"Not whitelisted\");\n\t\t} else {\n\t\t\trequire(\n\t\t\t\t_verify(proof, whitelistMerkleRoot, _generateMerkleLeaf(msg.sender)),\n\t\t\t\t\"Not whitelisted\"\n\t\t\t);\n\t\t}\n\n\t\t_safeMint(msg.sender, supply + 1);\n\t\taddressMintedBalance[msg.sender] = 1;\n\t} else {\n\t\tfor (uint256 i = 1; i <= _mintAmount; i++) {\n\t\t\t_safeMint(msg.sender, supply + i);\n\t\t}\n\t\taddressMintedBalance[msg.sender] += _mintAmount;\n\t}\n}"
    }
  },
  {
    "contract": "ERC721",
    "function": "tokenURI",
    "explanation": "Comment specifies URI concatenates baseURI and tokenId, but implementation returns only baseURI.",
    "contract_code": "\n=== Implementation of Function tokenURI(uint256) ===\nfunction tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\r\n        require(_exists(tokenId), \"ERC721Metadata: URI query for nonexistent token\");\r\n\r\n        return _baseURI();\r\n    }\n    \n=== Functions that function tokenURI internally calls ===\nfunction _baseURI() internal view virtual returns (string memory) {\r\n        return \"\";\r\n    }\nfunction _exists(uint256 tokenId) internal view virtual returns (bool) {\r\n        return _owners[tokenId] != address(0);\r\n    }",
    "rewritten_code": {
      "function_name": "function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(_exists(tokenId), \"ERC721Metadata: URI query for nonexistent token\");\n        string memory base = _baseURI();\n        return bytes(base).length > 0 ? string(abi.encodePacked(base, Strings.toString(tokenId))) : \"\";\n    }"
    }
  },
  {
    "contract": "Metarelics",
    "function": "requireChecks",
    "explanation": "Missing check for mint amount â‰¥1 as specified in comment",
    "contract_code": "\n=== Implementation of Function requireChecks(uint256) ===\nfunction requireChecks(uint256 _mintAmount) internal view {\r\n\t\trequire(paused == false, \"the contract is paused\");\r\n\t\trequire(totalSupply() + _mintAmount <= maxSupply, \"max NFT limit exceeded\");\r\n\t}\n    \n=== Functions that function requireChecks internally calls ===\nfunction totalSupply() public view virtual override returns (uint256) {\r\n        return _allTokens.length;\r\n    }",
    "rewritten_code": {
      "requireChecks": "function requireChecks(uint256 _mintAmount) internal view {\n        require(paused == false, \"the contract is paused\");\n        require(_mintAmount > 0, \"mint amount must be >=1\");\n        require(totalSupply() + _mintAmount <= maxSupply, \"max NFT limit exceeded\");\n    }"
    }
  }
]