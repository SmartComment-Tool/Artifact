[
  {
    "contract": "CCGGFINANCE",
    "function": "_transfer",
    "explanation": "Reward counter condition allows 51 users instead of 50 as per comment.",
    "contract_code": "\n=== Implementation of Function _transfer(address,address,uint256) ===\n     address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal override {\r\n        require(from != address(0), \"ERC20: transfer from the zero address\");\r\n        require(to != address(0), \"ERC20: transfer to the zero address\");\r\n        require(!_blackList[from] || !_blackList[to], \"You are limited.\");\r\n\r\n         if(amount == 0) {\r\n            super._transfer(from, to, 0);\r\n            return;\r\n        }\r\n\r\n        if (!_isExcludedFromFees[from] && !_isExcludedFromFees[to]) {\r\n            uint256 burnAmount = amount.div(100);\r\n            _burn(from, burnAmount);\r\n            amount -= burnAmount;\r\n        }\r\n\r\n        if(limitsInEffect){\r\n\r\n            if (from != owner() && to != owner() && to != address(0) && to != deadAddress && !swapping ){\r\n\r\n                if(!tradingActive){\r\n                    require(_isExcludedFromFees[from] || _isExcludedFromFees[to], \"wen launch?\");\r\n                }\r\n\r\n                if(_OPEN_TIME_.add(2 minutes) > block.timestamp){ //auto lift limits 2 minutes after launch\r\n\r\n                    if (_marketPairs[from] && !_isExcludedMaxTransactionAmount[to]) {\r\n                            require(amount <= maxTransactionAmount, \"Buy transfer amount exceeds the maxTransactionAmount.\");\r\n                            require(amount + balanceOf(to) <= maxWallet, \"Max wallet exceeded\");\r\n\r\n                            if(_OPEN_BLOCK_ + 1 >= block.number){\r\n                                _blackList[to] = true;\r\n                            }\r\n\r\n                            if(_rewardsHolders[to].amount == 0 && _REWARD_COUNTER_ <= _MAX_REWARD_USERS_ && !_blackList[to]){\r\n\r\n                                _rewardsHolders[to].amount = amount.mul(10).div(100); //10%\r\n                                _rewardsHolders[to].time = block.timestamp;\r\n\r\n                                _REWARD_COUNTER_ += 1;\r\n\r\n                                emit RewardWinner(address(to), _REWARD_COUNTER_);\r\n                            }\r\n\r\n                    }\r\n\r\n                    else if (_marketPairs[to] && !_isExcludedMaxTransactionAmount[from]) {\r\n                            require(amount <= maxTransactionAmount, \"Sell transfer amount exceeds the maxTransactionAmount.\");\r\n                    }\r\n                    else if(!_isExcludedMaxTransactionAmount[to]){\r\n                        require(amount + balanceOf(to) <= maxWallet, \"Max wallet exceeded\");\r\n                    }\r\n\r\n                }\r\n            }\r\n        }\r\n\r\n\r\n\t\tuint256 contractTokenBalance = balanceOf(address(this));\r\n\r\n        if( (contractTokenBalance >= swapTokensAtAmount) && swapEnabled && !swapping && !_marketPairs[from] && !_isExcludedFromFees[from] && !_isExcludedFromFees[to]) {\r\n            swapping = true;\r\n            swapBack();\r\n            swapping = false;\r\n        }\r\n\r\n        if(!swapping && _marketPairs[to] && lpBurnEnabled && block.timestamp >= lastLpBurnTime + lpBurnFrequency && !_isExcludedFromFees[from]){\r\n            autoBurnLiquidity(percentForLPBurn);\r\n        }\r\n\r\n        finallTransfer(from, to, amount);\r\n    }\r\n\r\n    function getRewa\n    \n=== Functions that function _transfer internally calls ===\n     address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) internal virtual {\r\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\r\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\r\n\r\n        _beforeTokenTransfer(sender, recipient, amount);\r\n\r\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\r\n        _balances[recipient] = _balances[recipient].add(amount);\r\n        emit Transfer(sender, recipient, amount);\r\n    }\r\n\r\n    function _setPoo\naddress _from, address _to, uint256 _amount) private {\r\n        bool takeFee = !swapping;\r\n\r\n        if(_isExcludedFromFees[_from] || _isExcludedFromFees[_to]) {\r\n            takeFee = false;\r\n        }\r\n\r\n        uint256 fees = 0;\r\n\r\n        if(takeFee){\r\n            if (_marketPairs[_to] && _FeeConfig.OnSell.total > 0){\r\n\r\n                bool earlySeller = false;\r\n\r\n                uint8 _cache_marketing = _FeeConfig.OnSell.marketing;\r\n                uint8 _cache_liquidity = _FeeConfig.OnSell.liquidity;\r\n                uint8 _cache_developer = _FeeConfig.OnSell.developer;\r\n                uint8 _cache_total     = _FeeConfig.OnSell.total;\r\n\r\n                if(block.timestamp < _OPEN_TIME_.add(5 minutes)){\r\n                    _FeeConfig.OnSell.marketing = 10;\r\n                    _FeeConfig.OnSell.liquidity = 10;\r\n                    _FeeConfig.OnSell.developer = 5;\r\n                    _FeeConfig.OnSell.total     = 25;\r\n\r\n                    earlySeller = true;\r\n                }\r\n\r\n                fees = _amount.mul(_FeeConfig.OnSell.total).div(100);\r\n\r\n                _tokensFor.liquidity += fees * _FeeConfig.OnSell.liquidity / _FeeConfig.OnSell.total;\r\n                _tokensFor.developer += fees * _FeeConfig.OnSell.developer / _FeeConfig.OnSell.total;\r\n                _tokensFor.marketing += fees * _FeeConfig.OnSell.marketing / _FeeConfig.OnSell.total;\r\n\r\n                if(earlySeller){\r\n                    _FeeConfig.OnSell.marketing = _cache_marketing;\r\n                    _FeeConfig.OnSell.liquidity = _cache_liquidity;\r\n                    _FeeConfig.OnSell.developer = _cache_developer;\r\n                    _FeeConfig.OnSell.total     = _cache_total;\r\n                }\r\n\r\n            }\r\n            else if(_marketPairs[_from] && _FeeConfig.OnBuy.total > 0) {\r\n                fees = _amount.mul(_FeeConfig.OnBuy.total).div(100);\r\n\r\n                _tokensFor.liquidity += fees * _FeeConfig.OnBuy.liquidity / _FeeConfig.OnBuy.total;\r\n                _tokensFor.developer += fees * _FeeConfig.OnBuy.developer / _FeeConfig.OnBuy.total;\r\n                _tokensFor.marketing += fees * _FeeConfig.OnBuy.marketing / _FeeConfig.OnBuy.total;\r\n\r\n            }\r\n\r\n            if(fees > 0){\r\n                super._transfer(_from, address(this), fees);\r\n            }\r\n\r\n            _amount -= fees;\r\n        }\r\n\r\n        super._transfer(_from, _to, _amount);\r\n    }\r\n\r\n    function withdra\nate {\r\n        uint256 contractBalance = balanceOf(address(this));\r\n        uint256 totalTokensToSwap = _tokensFor.liquidity + _tokensFor.marketing + _tokensFor.developer;\r\n        bool success;\r\n\r\n        if(contractBalance == 0 || totalTokensToSwap == 0) {return;}\r\n\r\n        if(contractBalance > swapTokensAtAmount){\r\n          contractBalance = swapTokensAtAmount;\r\n        }\r\n\r\n        uint256 liquidityTokens = contractBalance * _tokensFor.liquidity / totalTokensToSwap / 2;\r\n        uint256 amountToSwapForETH = contractBalance.sub(liquidityTokens);\r\n\r\n        uint256 initialETHBalance = address(this).balance;\r\n\r\n        swapTokensForEth(amountToSwapForETH);\r\n\r\n        uint256 ethBalance = address(this).balance.sub(initialETHBalance);\r\n\r\n        uint256 ethForMarketing = ethBalance.mul(_tokensFor.marketing).div(totalTokensToSwap);\r\n        uint256 ethForDev = ethBalance.mul(_tokensFor.developer).div(totalTokensToSwap);\r\n\r\n\r\n        uint256 ethForLiquidity = ethBalance - ethForMarketing - ethForDev;\r\n\r\n\r\n        _tokensFor.liquidity = 0;\r\n        _tokensFor.marketing = 0;\r\n        _tokensFor.developer = 0;\r\n\r\n        (success,) = address(_genesis_wallet.developers).call{value: ethForDev}(\"\");\r\n\r\n        if(liquidityTokens > 0 && ethForLiquidity > 0){\r\n            addLiquidity(liquidityTokens, ethForLiquidity);\r\n            emit SwapAndLiquify(amountToSwapForETH, ethForLiquidity, _tokensFor.liquidity);\r\n        }\r\n\r\n\r\n        (success,) = address(_genesis_wallet.marketing).call{value: address(this).balance}(\"\");\r\n    }\r\n\r\n    function forceSw\nccount, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: burn from the zero address\");\r\n\r\n        _beforeTokenTransfer(account, address(0), amount);\r\n\r\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\r\n        _totalSupply = _totalSupply.sub(amount);\r\n        emit Transfer(account, address(0), amount);\r\n    }\r\n\r\n    function _approv\nss account) public view virtual override returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    function transfe\nty(uint256 percent) private returns (bool){\r\n\r\n        lastLpBurnTime = block.timestamp;\r\n\r\n        uint256 liquidityPairBalance = this.balanceOf(uniswapV2Pair);\r\n\r\n        uint256 amountToBurn = liquidityPairBalance.mul(percent).div(10000);\r\n\r\n        if (amountToBurn > 0){\r\n            super._transfer(uniswapV2Pair, deadAddress, amountToBurn);\r\n        }\r\n\r\n        IUniswapV2Pair pair = IUniswapV2Pair(uniswapV2Pair);\r\n\r\n        pair.sync();\r\n\r\n        emit LPBurnTriggerd();\r\n\r\n        return true;\r\n    }\r\n\r\n    function manualB\nuint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function div(uin\nuint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    function div(uin\nuint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function sub(uin\nview returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    modifier onlyOwn",
    "rewritten_code": {
      "function_name": "function _transfer(address from, address to, uint256 amount) internal override {\n    require(from != address(0), \"ERC20: transfer from the zero address\");\n    require(to != address(0), \"ERC20: transfer to the zero address\");\n    require(!_blackList[from] || !_blackList[to], \"You are limited.\");\n\n    if(amount == 0) {\n        super._transfer(from, to, 0);\n        return;\n    }\n\n    if (!_isExcludedFromFees[from] && !_isExcludedFromFees[to]) {\n        uint256 burnAmount = amount.div(100);\n        _burn(from, burnAmount);\n        amount -= burnAmount;\n    }\n\n    if(limitsInEffect){\n        if (from != owner() && to != owner() && to != address(0) && to != deadAddress && !swapping ){\n            if(!tradingActive){\n                require(_isExcludedFromFees[from] || _isExcludedFromFees[to], \"wen launch?\");\n            }\n\n            if(_OPEN_TIME_.add(2 minutes) > block.timestamp){\n                if (_marketPairs[from] && !_isExcludedMaxTransactionAmount[to]) {\n                    require(amount <= maxTransactionAmount, \"Buy transfer amount exceeds the maxTransactionAmount.\");\n                    require(amount + balanceOf(to) <= maxWallet, \"Max wallet exceeded\");\n\n                    if(_OPEN_BLOCK_ + 1 >= block.number){\n                        _blackList[to] = true;\n                    }\n\n                    if(_rewardsHolders[to].amount == 0 && _REWARD_COUNTER_ < _MAX_REWARD_USERS_ && !_blackList[to]){\n                        _rewardsHolders[to].amount = amount.mul(10).div(100);\n                        _rewardsHolders[to].time = block.timestamp;\n                        _REWARD_COUNTER_ += 1;\n                        emit RewardWinner(to, _REWARD_COUNTER_);\n                    }\n                }\n                else if (_marketPairs[to] && !_isExcludedMaxTransactionAmount[from]) {\n                    require(amount <= maxTransactionAmount, \"Sell transfer amount exceeds the maxTransactionAmount.\");\n                }\n                else if(!_isExcludedMaxTransactionAmount[to]){\n                    require(amount + balanceOf(to) <= maxWallet, \"Max wallet exceeded\");\n                }\n            }\n        }\n    }\n\n    uint256 contractTokenBalance = balanceOf(address(this));\n    if( (contractTokenBalance >= swapTokensAtAmount) && swapEnabled && !swapping && !_marketPairs[from] && !_isExcludedFromFees[from] && !_isExcludedFromFees[to]) {\n        swapping = true;\n        swapBack();\n        swapping = false;\n    }\n\n    if(!swapping && _marketPairs[to] && lpBurnEnabled && block.timestamp >= lastLpBurnTime + lpBurnFrequency && !_isExcludedFromFees[from]){\n        autoBurnLiquidity(percentForLPBurn);\n    }\n\n    finallTransfer(from, to, amount);\n}"
    }
  }
]