[
  {
    "contract": "DivsNetwork",
    "function": "purchaseTokens",
    "explanation": "Require statement redundantly checks overflow already handled by SafeMath.add",
    "contract_code": "\n=== Implementation of Function purchaseTokens(uint256,address) ===\nfunction purchaseTokens(uint256 _incomingEthereum, address _referredBy)\r\n        antiEarlyWhale(_incomingEthereum)\r\n        internal\r\n        returns(uint256)\r\n    {\r\n        uint256 _undividedDividends = SafeMath.div(SafeMath.mul(_incomingEthereum, dividendFee_), 100);\r\n        uint256 _referralBonus = SafeMath.div(_undividedDividends, 3);\r\n        uint256 _fundPayout = SafeMath.div(SafeMath.mul(_incomingEthereum, fundFee_), 100);\r\n        uint256 _dividends = SafeMath.sub(_undividedDividends, _referralBonus);\r\n        uint256 _taxedEthereum = SafeMath.sub(SafeMath.sub(_incomingEthereum, _undividedDividends), _fundPayout);\r\n\r\n        totalEthFundCollected = SafeMath.add(totalEthFundCollected, _fundPayout);\r\n\r\n        uint256 _amountOfTokens = ethereumToTokens_(_taxedEthereum);\r\n        uint256 _fee = _dividends * magnitude;\r\n\r\n        require(_amountOfTokens > 0 && (SafeMath.add(_amountOfTokens,tokenSupply_) > tokenSupply_));\r\n\r\n        if(\r\n            _referredBy != 0x0000000000000000000000000000000000000000 &&\r\n\r\n            _referredBy != msg.sender &&\r\n\r\n            tokenBalanceLedger_[_referredBy] >= stakingRequirement\r\n        ){\r\n            referralBalance_[_referredBy] = SafeMath.add(referralBalance_[_referredBy], _referralBonus);\r\n        } else {\r\n            _dividends = SafeMath.add(_dividends, _referralBonus);\r\n            _fee = _dividends * magnitude;\r\n        }\r\n\r\n        if(tokenSupply_ > 0){\r\n\r\n            tokenSupply_ = SafeMath.add(tokenSupply_, _amountOfTokens);\r\n\r\n            profitPerShare_ += (_dividends * magnitude / (tokenSupply_));\r\n\r\n            _fee = _fee - (_fee-(_amountOfTokens * (_dividends * magnitude / (tokenSupply_))));\r\n\r\n        } else {\r\n            tokenSupply_ = _amountOfTokens;\r\n        }\r\n\r\n        tokenBalanceLedger_[msg.sender] = SafeMath.add(tokenBalanceLedger_[msg.sender], _amountOfTokens);\r\n\r\n        int256 _updatedPayouts = (int256) ((profitPerShare_ * _amountOfTokens) - _fee);\r\n        payoutsTo_[msg.sender] += _updatedPayouts;\r\n\r\n        onTokenPurchase(msg.sender, _incomingEthereum, _amountOfTokens, _referredBy);\r\n\r\n        return _amountOfTokens;\r\n    }\n    \n=== Functions that function purchaseTokens internally calls ===\nfunction add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\nfunction div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\nfunction ethereumToTokens_(uint256 _ethereum)\r\n        internal\r\n        view\r\n        returns(uint256)\r\n    {\r\n        uint256 _tokenPriceInitial = tokenPriceInitial_ * 1e18;\r\n        uint256 _tokensReceived =\r\n         (\r\n            (\r\n                SafeMath.sub(\r\n                    (sqrt\r\n                        (\r\n                            (_tokenPriceInitial**2)\r\n                            +\r\n                            (2*(tokenPriceIncremental_ * 1e18)*(_ethereum * 1e18))\r\n                            +\r\n                            (((tokenPriceIncremental_)**2)*(tokenSupply_**2))\r\n                            +\r\n                            (2*(tokenPriceIncremental_)*_tokenPriceInitial*tokenSupply_)\r\n                        )\r\n                    ), _tokenPriceInitial\r\n                )\r\n            )/(tokenPriceIncremental_)\r\n        )-(tokenSupply_)\r\n        ;\r\n\r\n        return _tokensReceived;\r\n    }\nfunction mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\nfunction sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\nmodifier antiEarlyWhale(uint256 _amountOfEthereum){\r\n        address _customerAddress = msg.sender;\r\n        \r\n        if (now >= ACTIVATION_TIME) {\r\n            onlyAmbassadors = false;\r\n        }\r\n\r\n        if( onlyAmbassadors && ((totalEthereumBalance() - _amountOfEthereum) <= ambassadorQuota_ )){\r\n            require(\r\n                ambassadors_[_customerAddress] == true &&\r\n\r\n                (ambassadorAccumulatedQuota_[_customerAddress] + _amountOfEthereum) <= ambassadorMaxPurchase_\r\n\r\n            );\r\n\r\n            ambassadorAccumulatedQuota_[_customerAddress] = SafeMath.add(ambassadorAccumulatedQuota_[_customerAddress], _amountOfEthereum);\r\n\r\n            _;\r\n        } else {\r\n            onlyAmbassadors = false;\r\n            _;\r\n        }\r\n\r\n    }",
    "rewritten_code": {
      "purchaseTokens": "function purchaseTokens(uint256 _incomingEthereum, address _referredBy)\n        antiEarlyWhale(_incomingEthereum)\n        internal\n        returns(uint256)\n    {\n        uint256 _undividedDividends = SafeMath.div(SafeMath.mul(_incomingEthereum, dividendFee_), 100);\n        uint256 _referralBonus = SafeMath.div(_undividedDividends, 3);\n        uint256 _fundPayout = SafeMath.div(SafeMath.mul(_incomingEthereum, fundFee_), 100);\n        uint256 _dividends = SafeMath.sub(_undividedDividends, _referralBonus);\n        uint256 _taxedEthereum = SafeMath.sub(SafeMath.sub(_incomingEthereum, _undividedDividends), _fundPayout);\n\n        totalEthFundCollected = SafeMath.add(totalEthFundCollected, _fundPayout);\n\n        uint256 _amountOfTokens = ethereumToTokens_(_taxedEthereum);\n        uint256 _fee = _dividends * magnitude;\n\n        require(_amountOfTokens > 0);\n\n        if(\n            _referredBy != 0x0000000000000000000000000000000000000000 &&\n            _referredBy != msg.sender &&\n            tokenBalanceLedger_[_referredBy] >= stakingRequirement\n        ){\n            referralBalance_[_referredBy] = SafeMath.add(referralBalance_[_referredBy], _referralBonus);\n        } else {\n            _dividends = SafeMath.add(_dividends, _referralBonus);\n            _fee = _dividends * magnitude;\n        }\n\n        if(tokenSupply_ > 0){\n            tokenSupply_ = SafeMath.add(tokenSupply_, _amountOfTokens);\n            profitPerShare_ += (_dividends * magnitude / (tokenSupply_));\n            _fee = _fee - (_fee-(_amountOfTokens * (_dividends * magnitude / (tokenSupply_))));\n        } else {\n            tokenSupply_ = _amountOfTokens;\n        }\n\n        tokenBalanceLedger_[msg.sender] = SafeMath.add(tokenBalanceLedger_[msg.sender], _amountOfTokens);\n\n        int256 _updatedPayouts = (int256) ((profitPerShare_ * _amountOfTokens) - _fee);\n        payoutsTo_[msg.sender] += _updatedPayouts;\n\n        onTokenPurchase(msg.sender, _incomingEthereum, _amountOfTokens, _referredBy);\n\n        return _amountOfTokens;\n    }"
    }
  }
]