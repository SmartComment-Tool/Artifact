[
  {
    "contract": "NFTContract1155",
    "function": "setApprovalForAll",
    "explanation": "Missing check preventing operator from being caller",
    "contract_code": "\n=== Implementation of Function setApprovalForAll(address,bool) ===\nfunction setApprovalForAll(address operator, bool approved) public virtual override onlyAllowedOperatorApproval(operator) {\n        require( isSBT == false || approved == false , \"setApprovalForAll is prohibited\");\n        require(\n            _isAllowed(operator) || approved == false,\n            \"RestrictApprove: Can not approve locked token\"\n        );\n        super.setApprovalForAll(operator, approved);\n    }\n    \n=== Functions that function setApprovalForAll internally calls ===\nfunction _isAllowed(address transferer)\n        internal\n        view\n        virtual\n        returns (bool)\n    {\n        if(enableRestrict == false) {\n            return true;\n        }\n\n        return\n            _isLocalAllowed(transferer) || cal.isAllowed(transferer, calLevel);\n    }\nfunction setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\nmodifier onlyAllowedOperatorApproval(address operator) virtual {\n        _checkFilterOperator(operator);\n        _;\n    }",
    "rewritten_code": {
      "setApprovalForAll": "function setApprovalForAll(address operator, bool approved) public virtual override onlyAllowedOperatorApproval(operator) {\n        require(operator != _msgSender(), \"ERC1155: setting approval status for self\");\n        require( isSBT == false || approved == false , \"setApprovalForAll is prohibited\");\n        require(_isAllowed(operator) || approved == false, \"RestrictApprove: Can not approve locked token\");\n        super.setApprovalForAll(operator, approved);\n    }"
    }
  },
  {
    "contract": "Base64",
    "function": "encode",
    "explanation": "Loop increments dataPtr before reading input, skipping first 3 bytes.",
    "contract_code": "\n=== Implementation of Function encode(bytes) ===\nfunction encode(bytes memory data) internal pure returns (string memory) {\n        if (data.length == 0) return '';\n\n        string memory table = TABLE_ENCODE;\n\n        uint256 encodedLen = 4 * ((data.length + 2) / 3);\n\n        string memory result = new string(encodedLen + 32);\n\n        assembly {\n            mstore(result, encodedLen)\n\n            let tablePtr := add(table, 1)\n\n            let dataPtr := data\n            let endPtr := add(dataPtr, mload(data))\n\n            let resultPtr := add(result, 32)\n\n            for {} lt(dataPtr, endPtr) {}\n            {\n                dataPtr := add(dataPtr, 3)\n                let input := mload(dataPtr)\n\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(18, input), 0x3F))))\n                resultPtr := add(resultPtr, 1)\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(12, input), 0x3F))))\n                resultPtr := add(resultPtr, 1)\n                mstore8(resultPtr, mload(add(tablePtr, and(shr( 6, input), 0x3F))))\n                resultPtr := add(resultPtr, 1)\n                mstore8(resultPtr, mload(add(tablePtr, and(        input,  0x3F))))\n                resultPtr := add(resultPtr, 1)\n            }\n\n            switch mod(mload(data), 3)\n            case 1 { mstore(sub(resultPtr, 2), shl(240, 0x3d3d)) }\n            case 2 { mstore(sub(resultPtr, 1), shl(248, 0x3d)) }\n        }\n\n        return result;\n    }\n    ",
    "rewritten_code": {
      "encode": "function encode(bytes memory data) internal pure returns (string memory) {\n        if (data.length == 0) return '';\n\n        string memory table = TABLE_ENCODE;\n\n        uint256 encodedLen = 4 * ((data.length + 2) / 3);\n\n        string memory result = new string(encodedLen + 32);\n\n        assembly {\n            mstore(result, encodedLen)\n\n            let tablePtr := add(table, 1)\n\n            let dataPtr := data\n            let endPtr := add(dataPtr, mload(data))\n\n            let resultPtr := add(result, 32)\n\n            for {} lt(dataPtr, endPtr) {}\n            {\n                let input := mload(dataPtr)\n                dataPtr := add(dataPtr, 3)\n\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(18, input), 0x3F))))\n                resultPtr := add(resultPtr, 1)\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(12, input), 0x3F))))\n                resultPtr := add(resultPtr, 1)\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(6, input), 0x3F))))\n                resultPtr := add(resultPtr, 1)\n                mstore8(resultPtr, mload(add(tablePtr, and(input, 0x3F))))\n                resultPtr := add(resultPtr, 1)\n            }\n\n            switch mod(mload(data), 3)\n            case 1 { mstore(sub(resultPtr, 2), shl(240, 0x3d3d)) }\n            case 2 { mstore(sub(resultPtr, 1), shl(248, 0x3d)) }\n        }\n\n        return result;\n    }"
    }
  }
]