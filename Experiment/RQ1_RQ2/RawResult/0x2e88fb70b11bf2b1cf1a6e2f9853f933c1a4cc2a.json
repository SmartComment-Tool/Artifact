[
  {
    "contract": "JiggleosOnChain",
    "function": "drawFreeSVG",
    "explanation": "Missing seed range validation (1-4294967295)",
    "contract_code": "\n=== Implementation of Function drawFreeSVG(uint32) ===\nfunction drawFreeSVG(uint32 _seed) public view returns(string memory) {\n        require(seedToId[_seed] == 0, \"Seed already minted\");\n        uint256 currentSeed = _seed;\n        return string(abi.encodePacked(\n                'data:image/svg+xml;base64,', Base64.encode(bytes(abi.encodePacked(\n                    head,\n                    currentSeed.toString(),\n                    tail\n                )))));\n    }\n    \n=== Functions that function drawFreeSVG internally calls ===\nfunction encode(bytes memory data) internal pure returns (string memory) {\n        if (data.length == 0) return '';\n        string memory table = TABLE;\n        uint256 encodedLen = 4 * ((data.length + 2) / 3);\n        string memory result = new string(encodedLen + 32);\n\n        assembly {\n            mstore(result, encodedLen)\n            let tablePtr := add(table, 1)\n            let dataPtr := data\n            let endPtr := add(dataPtr, mload(data))\n            let resultPtr := add(result, 32)\n            for {} lt(dataPtr, endPtr) {}{\n                dataPtr := add(dataPtr, 3)\n                let input := mload(dataPtr)\n                mstore(resultPtr, shl(248, mload(add(tablePtr, and(shr(18, input), 0x3F)))))\n                resultPtr := add(resultPtr, 1)\n                mstore(resultPtr, shl(248, mload(add(tablePtr, and(shr(12, input), 0x3F)))))\n                resultPtr := add(resultPtr, 1)\n                mstore(resultPtr, shl(248, mload(add(tablePtr, and(shr( 6, input), 0x3F)))))\n                resultPtr := add(resultPtr, 1)\n                mstore(resultPtr, shl(248, mload(add(tablePtr, and(        input,  0x3F)))))\n                resultPtr := add(resultPtr, 1)\n            }\n            switch mod(mload(data), 3)\n            case 1 { mstore(sub(resultPtr, 2), shl(240, 0x3d3d)) }\n            case 2 { mstore(sub(resultPtr, 1), shl(248, 0x3d)) }\n        }\n        return result;\n    }\nfunction toString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }",
    "rewritten_code": {
      "function_name": "function drawFreeSVG(uint32 _seed) public view returns(string memory) {\n        require(_seed >= 1 && _seed <= 4294967295, \"Invalid seed range\");\n        require(seedToId[_seed] == 0, \"Seed already minted\");\n        uint256 currentSeed = _seed;\n        return string(abi.encodePacked(\n                'data:image/svg+xml;base64,', Base64.encode(bytes(abi.encodePacked(\n                    head,\n                    currentSeed.toString(),\n                    tail\n                )))));\n    }"
    }
  },
  {
    "contract": "JiggleosOnChain",
    "function": "mint",
    "explanation": "Owner can mint without 0.1 ETH payment and seed validation allows 0. Comments require 0.1 ETH per mint and seed â‰¥1.",
    "contract_code": "\n=== Implementation of Function mint(uint32,string) ===\nfunction mint(uint32 seed, string memory name) external payable nonReentrant {\n        uint id = _nextTokenId.current();\n\n        require(nameLength(name) == true, \"Name must be between 1-32 characters\");\n        require(id < 10001, \"Sold out\");\n        require(seedToId[seed] == 0, \"Seed already minted\");\n\n        if (msg.sender != owner()) {\n            require(saleON, \"Sale OFF\");\n            require(msg.value == 0.1 ether);\n        }\n\n        idToName[id] = name;\n        idToSeeder[id] = msg.sender;\n        idToSeed[id] = seed;\n        seedToId[seed] = id;\n\n        _nextTokenId.increment();\n        _mint(msg.sender, id);\n    }\n    \n=== Functions that function mint internally calls ===\nfunction _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _beforeTokenTransfer(address(0), to, tokenId);\n\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n\n        _afterTokenTransfer(address(0), to, tokenId);\n    }\nfunction current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\nfunction increment(Counter storage counter) internal {\n    unchecked {\n        counter._value += 1;\n    }\n    }\nfunction nameLength(string memory str) internal pure returns (bool){\n        bytes memory b = bytes(str);\n        if(b.length < 1) return false;\n        if(b.length > 32) return false;\n        return true;\n    }\nfunction owner() public view virtual returns (address) {\n        return _owner;\n    }\nmodifier nonReentrant() {\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n        _status = _ENTERED;\n        _;\n        _status = _NOT_ENTERED;\n    }",
    "rewritten_code": {
      "mint(uint32,string)": "function mint(uint32 seed, string memory name) external payable nonReentrant {\n        uint id = _nextTokenId.current();\n\n        require(nameLength(name), \"Name must be between 1-32 characters\");\n        require(id < 10001, \"Sold out\");\n        require(seed >= 1 && seed <= 4294967295, \"Invalid seed\");\n        require(seedToId[seed] == 0, \"Seed already minted\");\n        require(saleON, \"Sale OFF\");\n        require(msg.value == 0.1 ether, \"Incorrect payment\");\n\n        idToName[id] = name;\n        idToSeeder[id] = msg.sender;\n        idToSeed[id] = seed;\n        seedToId[seed] = id;\n\n        _nextTokenId.increment();\n        _mint(msg.sender, id);\n    }"
    }
  }
]