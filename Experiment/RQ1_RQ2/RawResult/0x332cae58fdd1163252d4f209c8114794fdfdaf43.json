[
  {
    "contract": "ERC721ARedemption",
    "function": "setRedemptionAddress",
    "explanation": "Missing check for IERC721Receiver implementation in redemption address",
    "contract_code": "\n=== Implementation of Function setRedemptionAddress(address) ===\nfunction setRedemptionAddress(address _newRedemptionAddress) public onlyTeamOrOwner {\n    require(_newRedemptionAddress != address(0), \"New redemption address cannot be null address.\");\n    redemptionAddress = _newRedemptionAddress;\n  }\n    \n=== Functions that function setRedemptionAddress internally calls ===\nmodifier onlyTeamOrOwner() {\n    bool _isOwner = owner() == _msgSender();\n    bool _isTeam = inTeam(_msgSender());\n    require(_isOwner || _isTeam, \"Team: caller is not the owner or in Team.\");\n    _;\n  }",
    "rewritten_code": {
      "function_name": "function setRedemptionAddress(address _newRedemptionAddress) public onlyTeamOrOwner {\n    require(_newRedemptionAddress != address(0), \"New redemption address cannot be null address.\");\n    if (_newRedemptionAddress.code.length > 0) {\n      try IERC721Receiver(_newRedemptionAddress).onERC721Received(address(this), address(0), 0, \"\") returns (bytes4 retval) {\n        require(retval == IERC721Receiver.onERC721Received.selector, \"Invalid receiver\");\n      } catch {\n        revert(\"Contract does not implement IERC721Receiver\");\n      }\n    }\n    redemptionAddress = _newRedemptionAddress;\n  }"
    }
  },
  {
    "contract": "RamppERC721A",
    "function": "mintToAdminV2",
    "explanation": "Comment specifies owner-only access but implementation allows team members",
    "contract_code": "\n=== Implementation of Function mintToAdminV2(address,uint256) ===\nfunction mintToAdminV2(address _to, uint256 _qty) public onlyTeamOrOwner{\n         require(_qty > 0, \"Must mint at least 1 token.\");\n         require(currentTokenId() + _qty <= collectionSize, \"Cannot mint over supply cap of 1000\");\n         _safeMint(_to, _qty, true);\n     }\n    \n=== Functions that function mintToAdminV2 internally calls ===\nfunction _safeMint(address to, uint256 quantity, bool isAdminMint) internal {\n    _safeMint(to, quantity, isAdminMint, \"\");\n  }\nfunction currentTokenId() public view returns (uint256) {\n    return _totalMinted();\n  }\nmodifier onlyTeamOrOwner() {\n    bool _isOwner = owner() == _msgSender();\n    bool _isTeam = inTeam(_msgSender());\n    require(_isOwner || _isTeam, \"Team: caller is not the owner or in Team.\");\n    _;\n  }",
    "rewritten_code": {
      "mintToAdminV2(address,uint256)": "function mintToAdminV2(address _to, uint256 _qty) public onlyOwner {\n    require(_qty > 0, \"Must mint at least 1 token.\");\n    require(currentTokenId() + _qty <= collectionSize, \"Cannot mint over supply cap of 1000\");\n    _safeMint(_to, _qty, true);\n}"
    }
  },
  {
    "contract": "ERC721ARedemption",
    "function": "verifedClaim",
    "explanation": "Missing ownership check of redemption token by caller",
    "contract_code": "\n=== Implementation of Function verifedClaim(address,uint256) ===\nfunction verifedClaim(address redemptionContract, uint256 tokenId) public payable {\n    require(getNextTokenId() <= collectionSize, \"Cannot mint over supply cap of 5000\");\n    require(verifiedClaimModeEnabled, \"ERC721 Redeemable: Verified claim mode is not enabled currently\");\n    require(redemptionContract != address(0), \"ERC721 Redeemable: Redemption contract cannot be null.\");\n    require(redemptionContracts[redemptionContract], \"ERC721 Redeemable: Redemption contract is not eligable for redeeming.\");\n    require(msg.value == redemptionSurcharge, \"ERC721 Redeemable: Redemption fee not sent by redeemer.\");\n    require(tokenRedemptions[redemptionContract][tokenId] == false, \"ERC721 Redeemable: Token has already been redeemed.\");\n    \n    tokenRedemptions[redemptionContract][tokenId] = true;\n    emit VerifiedClaim(_msgSender(), tokenId, redemptionContract);\n    _safeMint(_msgSender(), 1, false);\n  }\n    \n=== Functions that function verifedClaim internally calls ===\nfunction _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\nfunction _safeMint(address to, uint256 quantity, bool isAdminMint) internal {\n    _safeMint(to, quantity, isAdminMint, \"\");\n  }\nfunction getNextTokenId() public view returns (uint256) {\n      return _totalMinted() + 1;\n  }",
    "rewritten_code": {
      "function_name": "function verifedClaim(address redemptionContract, uint256 tokenId) public payable {\n    require(getNextTokenId() <= collectionSize, \"Cannot mint over supply cap of 5000\");\n    require(verifiedClaimModeEnabled, \"ERC721 Redeemable: Verified claim mode is not enabled currently\");\n    require(redemptionContract != address(0), \"ERC721 Redeemable: Redemption contract cannot be null.\");\n    require(redemptionContracts[redemptionContract], \"ERC721 Redeemable: Redemption contract is not eligable for redeeming.\");\n    require(msg.value == redemptionSurcharge, \"ERC721 Redeemable: Redemption fee not sent by redeemer.\");\n    require(tokenRedemptions[redemptionContract][tokenId] == false, \"ERC721 Redeemable: Token has already been redeemed.\");\n    require(IERC721(redemptionContract).ownerOf(tokenId) == _msgSender(), \"ERC721 Redeemable: Caller does not own redemption token\");\n\n    tokenRedemptions[redemptionContract][tokenId] = true;\n    emit VerifiedClaim(_msgSender(), tokenId, redemptionContract);\n    _safeMint(_msgSender(), 1, false);\n  }"
    }
  },
  {
    "contract": "RamppERC721A",
    "function": "mintToMultiple",
    "explanation": "Comment states fee may not be required but code always enforces payment.",
    "contract_code": "\n=== Implementation of Function mintToMultiple(address,uint256) ===\nfunction mintToMultiple(address _to, uint256 _amount) public payable {\n        require(onlyERC20MintingMode == false, \"Only minting with ERC-20 tokens is enabled.\");\n        require(_amount >= 1, \"Must mint at least 1 token\");\n        require(_amount <= maxBatchSize, \"Cannot mint more than max mint per transaction\");\n        require(mintingOpen == true, \"Minting is not open right now!\");\n        \n        \n        require(currentTokenId() + _amount <= collectionSize, \"Cannot mint over supply cap of 1000\");\n        require(msg.value == getPrice(_amount), \"Value below required mint fee for amount\");\n\n        _safeMint(_to, _amount, false);\n    }\n    \n=== Functions that function mintToMultiple internally calls ===\nfunction _safeMint(address to, uint256 quantity, bool isAdminMint) internal {\n    _safeMint(to, quantity, isAdminMint, \"\");\n  }\nfunction currentTokenId() public view returns (uint256) {\n    return _totalMinted();\n  }\nfunction getPrice(uint256 _count) public view returns (uint256) {\n    require(_count > 0, \"Must be minting at least 1 token.\");\n\n    if(\n      usingEarlyMintIncentive == false ||\n      currentTokenId() > earlyMintTokenIdCap\n    ) {\n      return PRICE * _count;\n    }\n\n    uint256 endingTokenId = currentTokenId() + _count;\n    if(endingTokenId  <= earlyMintTokenIdCap) {\n      return EARLY_MINT_PRICE * _count;\n    }\n\n    uint256 incentiveTokenCount = earlyMintTokenIdCap - currentTokenId();\n    uint256 outsideIncentiveCount = endingTokenId - earlyMintTokenIdCap;\n\n    return (EARLY_MINT_PRICE * incentiveTokenCount) + (PRICE * outsideIncentiveCount);\n  }",
    "rewritten_code": {
      "mintToMultiple": "function mintToMultiple(address _to, uint256 _amount) public payable {\n        require(onlyERC20MintingMode == false, \"Only minting with ERC-20 tokens is enabled.\");\n        require(_amount >= 1, \"Must mint at least 1 token\");\n        require(_amount <= maxBatchSize, \"Cannot mint more than max mint per transaction\");\n        require(mintingOpen == true, \"Minting is not open right now!\");\n        \n        require(currentTokenId() + _amount <= collectionSize, \"Cannot mint over supply cap of 1000\");\n        \n        _safeMint(_to, _amount, false);\n    }"
    }
  }
]