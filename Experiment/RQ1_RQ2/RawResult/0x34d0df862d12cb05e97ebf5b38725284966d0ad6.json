[
  {
    "contract": "GovernanceToken",
    "function": "getPriorVotes",
    "explanation": "Missing check for finalized block in prior votes lookup",
    "contract_code": "\n=== Implementation of Function getPriorVotes(address,uint256) ===\nfunction getPriorVotes(address account, uint blockNumber)\n        external\n        view\n        returns (uint256)\n    {\n        require(blockNumber < block.number, \"CARVE::getPriorVotes: not yet determined\");\n\n        uint32 nCheckpoints = numCheckpoints[account];\n        if (nCheckpoints == 0) {\n            return 0;\n        }\n\n        if (checkpoints[account][nCheckpoints - 1].fromBlock <= blockNumber) {\n            return checkpoints[account][nCheckpoints - 1].votes;\n        }\n\n        if (checkpoints[account][0].fromBlock > blockNumber) {\n            return 0;\n        }\n\n        uint32 lower = 0;\n        uint32 upper = nCheckpoints - 1;\n        while (upper > lower) {\n            uint32 center = upper - (upper - lower) / 2; // ceil, avoiding overflow\n            Checkpoint memory cp = checkpoints[account][center];\n            if (cp.fromBlock == blockNumber) {\n                return cp.votes;\n            } else if (cp.fromBlock < blockNumber) {\n                lower = center;\n            } else {\n                upper = center - 1;\n            }\n        }\n        return checkpoints[account][lower].votes;\n    }\n    ",
    "rewritten_code": {
      "getPriorVotes(address,uint256)": "function getPriorVotes(address account, uint blockNumber) external view returns (uint256) {\n        require(blockNumber < block.number, \"CARVE::getPriorVotes: not yet determined\");\n        require(block.number - blockNumber > 256, \"CARVE::getPriorVotes: block not finalized\");\n\n        uint32 nCheckpoints = numCheckpoints[account];\n        if (nCheckpoints == 0) return 0;\n\n        if (checkpoints[account][nCheckpoints - 1].fromBlock <= blockNumber) {\n            return checkpoints[account][nCheckpoints - 1].votes;\n        }\n\n        if (checkpoints[account][0].fromBlock > blockNumber) return 0;\n\n        uint32 lower = 0;\n        uint32 upper = nCheckpoints - 1;\n        while (upper > lower) {\n            uint32 center = upper - (upper - lower) / 2;\n            Checkpoint memory cp = checkpoints[account][center];\n            if (cp.fromBlock == blockNumber) return cp.votes;\n            else if (cp.fromBlock < blockNumber) lower = center;\n            else upper = center - 1;\n        }\n        return checkpoints[account][lower].votes;\n    }"
    }
  }
]