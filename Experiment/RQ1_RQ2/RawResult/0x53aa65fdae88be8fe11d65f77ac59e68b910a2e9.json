[
  {
    "contract": "ShibaVerseExchange",
    "function": "_transfer",
    "explanation": "Comment specifies cooldown check but code checks transaction amount instead",
    "contract_code": "\n=== Implementation of Function _transfer(address,address,uint256) ===\nfunction _transfer(address from, address to, uint256 amount) private {\r\n        require(amount > 0, \"Transfer amount must be greater than zero\");\r\n        require(!bots[from]);\r\n        if (from != address(this)) {\r\n            _feeAddr1 = 1;\r\n            _feeAddr2 = 9;\r\n            if (from == uniswapV2Pair && to != address(uniswapV2Router) && ! _isExcludedFromFee[to] && cooldownEnabled) {\r\n                require(amount <= _maxTxAmount);\r\n            }\r\n\r\n            uint256 contractTokenBalance = balanceOf(address(this));\r\n            if (!inSwap && from != uniswapV2Pair && swapEnabled) {\r\n                swapTokensForEth(contractTokenBalance);\r\n                uint256 contractETHBalance = address(this).balance;\r\n                if(contractETHBalance > 300000000000000000) {\r\n                    sendETHToFee(address(this).balance);\r\n                }\r\n            }\r\n        }\r\n\t\t\r\n        _tokenTransfer(from,to,amount);\r\n    }\n    \n=== Functions that function _transfer internally calls ===\nfunction _tokenTransfer(address sender, address recipient, uint256 amount) private {\r\n        _transferStandard(sender, recipient, amount);\r\n    }\nfunction balanceOf(address account) public view override returns (uint256) {\r\n        return tokenFromReflection(_rOwned[account]);\r\n    }\nfunction sendETHToFee(uint256 amount) private {\r\n        _feeAddrWallet1.transfer(amount/3);\r\n        _feeAddrWallet2.transfer(amount/3);\r\n        _feeAddrWallet3.transfer(amount/3);\r\n    }\nfunction swapTokensForEth(uint256 tokenAmount) private lockTheSwap {\r\n        address[] memory path = new address[](2);\r\n        path[0] = address(this);\r\n        path[1] = uniswapV2Router.WETH();\r\n        _approve(address(this), address(uniswapV2Router), tokenAmount);\r\n        uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n            tokenAmount,\r\n            0,\r\n            path,\r\n            address(this),\r\n            block.timestamp\r\n        );\r\n    }",
    "rewritten_code": {
      "_transfer": "function _transfer(address from, address to, uint256 amount) private {\n        require(amount > 0, \"Transfer amount must be greater than zero\");\n        require(!bots[from]);\n        if (from != address(this)) {\n            _feeAddr1 = 1;\n            _feeAddr2 = 9;\n            if (from == uniswapV2Pair && to != address(uniswapV2Router) && ! _isExcludedFromFee[to] && cooldownEnabled) {\n                require(block.timestamp >= cooldown[from], \"Cooldown active\");\n                cooldown[from] = block.timestamp + 30 minutes;\n            }\n\n            uint256 contractTokenBalance = balanceOf(address(this));\n            if (!inSwap && from != uniswapV2Pair && swapEnabled) {\n                swapTokensForEth(contractTokenBalance);\n                uint256 contractETHBalance = address(this).balance;\n                if(contractETHBalance > 300000000000000000) {\n                    sendETHToFee(address(this).balance);\n                }\n            }\n        }\n        \n        _tokenTransfer(from,to,amount);\n    }",
      "_transferStandard": "function _transferStandard(address sender, address recipient, uint256 tAmount) private {\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee, uint256 tTeam) = _getValues(tAmount);\n        _rOwned[sender] = _rOwned[sender].sub(rAmount);\n        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);\n        _takeTeam(tTeam);\n        _reflectFee(rFee, tFee);\n        emit Transfer(sender, recipient, tTransferAmount);\n    }"
    }
  }
]