[
  {
    "contract": "XMAS",
    "function": "_transfer",
    "explanation": "Comment specifies disabling tax but implementation sets tax to tier1 instead of zero.",
    "contract_code": "\n=== Implementation of Function _transfer(address,address,uint256) ===\nfunction _transfer(address from, address to, uint256 amount) private {\r\n        require(from != address(0), \"ERC20: transfer from the zero address\");\r\n        require(to != address(0), \"ERC20: transfer to the zero address\");\r\n        require(amount > 0, \"Transfer amount must be greater than zero\");\r\n        uint256 taxAmount=0;\r\n        if (from != owner() && to != owner()) {\r\n\r\n            taxAmount = amount.mul(_tax).div(1000);\r\n\r\n            if (antiSniperEnabled && from!= address(this)) {\r\n                require(antisniper[to], \"Failed to snipe\");\r\n            }\r\n            \r\n            if (from == uniswapV2Pair && to != address(uniswapV2Router)) {\r\n                _buyCount++;\r\n                \r\n                if (_buyCount >= _antiSniperCount && antiSniperEnabled) {\r\n                    antiSniperEnabled = false;\r\n                    _tax = _tier1;\r\n                }\r\n            }\r\n            if(to == uniswapV2Pair && from!= address(this) ){\r\n                taxAmount = amount.mul(_tax).div(1000);\r\n\r\n                if (_buyCount >= _reductingPeriod1 && _tax == _tier1) {\r\n                    _tax = _tier2;\r\n                }\r\n                if (_buyCount >= _reductingPeriod2 && _tax == _tier2) {\r\n                    _tax = _tier3;\r\n                }\r\n                if (block.timestamp >= _tradingOpened.add(_reductingPeriod3) && _tax == _tier3) {\r\n                    _tax = _tier4;\r\n                }\r\n            }\r\n\r\n            uint256 contractTokenBalance = balanceOf(address(this));\r\n            if (!inSwap && to == uniswapV2Pair && swapEnabled && contractTokenBalance>_taxSwapThreshold && _buyCount>_preventSwapBefore) {\r\n                swapTokensForEth(min(amount,min(contractTokenBalance,_maxTaxSwap)));\r\n                \r\n                uint256 contractETHBalance = address(this).balance;\r\n                if(contractETHBalance > 0) {\r\n                    sendETHToFee(address(this).balance);\r\n                }\r\n            }\r\n        }\r\n\r\n        if(taxAmount>0){\r\n          _balances[address(this)]=_balances[address(this)].add(taxAmount);\r\n          emit Transfer(from, address(this),taxAmount);\r\n        }\r\n        _balances[from]=_balances[from].sub(amount);\r\n        _balances[to]=_balances[to].add(amount.sub(taxAmount));\r\n        emit Transfer(from, to, amount.sub(taxAmount));\r\n    }\n    \n=== Functions that function _transfer internally calls ===\nfunction add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n        return c;\r\n    }\nfunction balanceOf(address account) public view override returns (uint256) {\r\n        return _balances[account];\r\n    }\nfunction div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\nfunction min(uint256 a, uint256 b) private pure returns (uint256){\r\n      return (a>b)?b:a;\r\n    }\nfunction mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n        return c;\r\n    }\nfunction owner() public view returns (address) {\r\n        return _owner;\r\n    }\nfunction sendETHToFee(uint256 amount) private {\r\n        _taxWallet.transfer(amount);\r\n    }\nfunction sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\nfunction swapTokensForEth(uint256 tokenAmount) private lockTheSwap {\r\n        address[] memory path = new address[](2);\r\n        path[0] = address(this);\r\n        path[1] = uniswapV2Router.WETH();\r\n        _approve(address(this), address(uniswapV2Router), tokenAmount);\r\n        uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n            tokenAmount,\r\n            0,\r\n            path,\r\n            address(this),\r\n            block.timestamp\r\n        );\r\n    }",
    "rewritten_code": {
      "_transfer(address,address,uint256)": "function _transfer(address from, address to, uint256 amount) private {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n        require(amount > 0, \"Transfer amount must be greater than zero\");\n        uint256 taxAmount=0;\n        if (from != owner() && to != owner()) {\n\n            taxAmount = amount.mul(_tax).div(1000);\n\n            if (antiSniperEnabled && from!= address(this)) {\n                require(antisniper[to], \"Failed to snipe\");\n            }\n            \n            if (from == uniswapV2Pair && to != address(uniswapV2Router)) {\n                _buyCount++;\n                \n                if (_buyCount >= _antiSniperCount && antiSniperEnabled) {\n                    antiSniperEnabled = false;\n                    _tax = 0;\n                }\n            }\n            if(to == uniswapV2Pair && from!= address(this) ){\n                taxAmount = amount.mul(_tax).div(1000);\n\n                if (_buyCount >= _reductingPeriod1 && _tax == _tier1) {\n                    _tax = _tier2;\n                }\n                if (_buyCount >= _reductingPeriod2 && _tax == _tier2) {\n                    _tax = _tier3;\n                }\n                if (block.timestamp >= _tradingOpened.add(_reductingPeriod3) && _tax == _tier3) {\n                    _tax = _tier4;\n                }\n            }\n\n            uint256 contractTokenBalance = balanceOf(address(this));\n            if (!inSwap && to == uniswapV2Pair && swapEnabled && contractTokenBalance>_taxSwapThreshold && _buyCount>_preventSwapBefore) {\n                swapTokensForEth(min(amount,min(contractTokenBalance,_maxTaxSwap)));\n                \n                uint256 contractETHBalance = address(this).balance;\n                if(contractETHBalance > 0) {\n                    sendETHToFee(address(this).balance);\n                }\n            }\n        }\n\n        if(taxAmount>0){\n          _balances[address(this)]=_balances[address(this)].add(taxAmount);\n          emit Transfer(from, address(this),taxAmount);\n        }\n        _balances[from]=_balances[from].sub(amount);\n        _balances[to]=_balances[to].add(amount.sub(taxAmount));\n        emit Transfer(from, to, amount.sub(taxAmount));\n    }"
    }
  }
]