[
  {
    "contract": "KOPOKOMafia",
    "function": "presaleMint",
    "explanation": "Comment specifies minting one NFT, but implementation allows multiple tokens",
    "contract_code": "\n=== Implementation of Function presaleMint(bytes32[],uint256) ===\nfunction presaleMint(bytes32[] calldata _proof,uint256 _ammount) external payable nonReentrant {\r\n        \r\n        require(sellingStep == Steps.Presale, \"Presale has not started yet.\");\r\n        \r\n        require(nftsPerWallet[msg.sender] < max_mint_allowed_presale, string(abi.encodePacked(\"You can only get \",\r\n        Strings.toString(max_mint_allowed_presale),\" NFT on the Presale\")));\r\n\r\n        require(_ammount <= max_mint_allowed_presale, string(abi.encodePacked(\"You can't mint more than \",\r\n        Strings.toString(max_mint_allowed_presale),\" tokens\")));\r\n\r\n        require(isWhiteListed(msg.sender, _proof), \"You are not on the whitelist\");\r\n        uint price = pricePresale;\r\n        require(msg.value >= price * _ammount, \"Not enought funds.\");\r\n        nftsPerWallet[msg.sender] += _ammount;\r\n        _safeMint(msg.sender, _ammount);\r\n    }\n    \n=== Functions that function presaleMint internally calls ===\nfunction _safeMint(address to, uint256 quantity) internal {\r\n        _safeMint(to, quantity, '');\r\n    }\nfunction isWhiteListed(address account, bytes32[] calldata proof) internal view returns(bool) {\r\n           \r\n        return _verify(_leaf(account),proof);\r\n    }\nfunction toString(uint256 value) internal pure returns (string memory) {\r\n\r\n        if (value == 0) {\r\n            return \"0\";\r\n        }\r\n        uint256 temp = value;\r\n        uint256 digits;\r\n        while (temp != 0) {\r\n            digits++;\r\n            temp /= 10;\r\n        }\r\n        bytes memory buffer = new bytes(digits);\r\n        while (value != 0) {\r\n            digits -= 1;\r\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\r\n            value /= 10;\r\n        }\r\n        return string(buffer);\r\n    }\nmodifier nonReentrant() {\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n\r\n        _status = _ENTERED;\r\n\r\n        _;\r\n\r\n        _status = _NOT_ENTERED;\r\n    }",
    "rewritten_code": {
      "presaleMint": "function presaleMint(bytes32[] calldata _proof,uint256 _ammount) external payable nonReentrant {\n        require(_ammount == 1, \"Can only mint 1 NFT\");\n        require(sellingStep == Steps.Presale, \"Presale has not started yet.\");\n        require(nftsPerWallet[msg.sender] < max_mint_allowed_presale, string(abi.encodePacked(\"You can only get \",\n        Strings.toString(max_mint_allowed_presale),\" NFT on the Presale\")));\n        require(isWhiteListed(msg.sender, _proof), \"You are not on the whitelist\");\n        uint price = pricePresale;\n        require(msg.value >= price * _ammount, \"Not enought funds.\");\n        nftsPerWallet[msg.sender] += _ammount;\n        _safeMint(msg.sender, _ammount);\n    }"
    }
  },
  {
    "contract": "KOPOKOMafia",
    "function": "gift",
    "explanation": "MAX_SUPPLY refers to total minted tokens, but totalSupply() counts burned tokens. Should use _totalMinted() for supply check.",
    "contract_code": "\n=== Implementation of Function gift(address) ===\nfunction gift(address _account) external onlyOwner {\r\n        uint supply = totalSupply();\r\n        require(supply + 1 <= MAX_SUPPLY, \"Sold out\");\r\n        _safeMint(_account, 1);\r\n    }\n    \n=== Functions that function gift internally calls ===\nfunction _safeMint(address to, uint256 quantity) internal {\r\n        _safeMint(to, quantity, '');\r\n    }\nfunction totalSupply() public view returns (uint256) {\r\n        unchecked {\r\n            return _currentIndex - _burnCounter - _startTokenId();\r\n        }\r\n    }\nmodifier onlyOwner() {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }",
    "rewritten_code": {
      "gift": "function gift(address _account) external onlyOwner {\n    uint256 minted = _totalMinted();\n    require(minted + 1 <= MAX_SUPPLY, \"Sold out\");\n    _safeMint(_account, 1);\n}"
    }
  },
  {
    "contract": "KOPOKOMafia",
    "function": "saleMint",
    "explanation": "Used totalSupply() which counts burned tokens instead of _totalMinted() for mint limit check",
    "contract_code": "\n=== Implementation of Function saleMint(uint256) ===\nfunction saleMint(uint256 _ammount) external payable nonReentrant {\r\n        uint numberNftSold = totalSupply();\r\n        uint price = priceSale;\r\n        require(sellingStep != Steps.SoldOut, \"Sorry, no NFTs left.\");\r\n        require(sellingStep == Steps.Sale, \"Sorry, sale has not started yet.\");\r\n        require(msg.value >= price * _ammount, \"Not enought funds.\");\r\n       \r\n        require(nftsPerWalletSale[msg.sender] < max_mint_allowed, string(abi.encodePacked(\"You can only get \",\r\n        Strings.toString(max_mint_allowed),\" NFT on the Sale\")));\r\n\r\n         require(_ammount <= max_mint_allowed, string(abi.encodePacked(\"You can't mint more than \",\r\n        Strings.toString(max_mint_allowed),\" tokens\")));\r\n\r\n        require(numberNftSold + _ammount <= MAX_SUPPLY, \"Sale is almost done and we don't have enought NFTs left.\");\r\n        nftsPerWalletSale[msg.sender] += _ammount;\r\n        \r\n        _safeMint(msg.sender, _ammount);\r\n        \r\n        if(numberNftSold + _ammount == MAX_SUPPLY) {\r\n            sellingStep = Steps.SoldOut;   \r\n        }\r\n    }\n    \n=== Functions that function saleMint internally calls ===\nfunction _safeMint(address to, uint256 quantity) internal {\r\n        _safeMint(to, quantity, '');\r\n    }\nfunction toString(uint256 value) internal pure returns (string memory) {\r\n\r\n        if (value == 0) {\r\n            return \"0\";\r\n        }\r\n        uint256 temp = value;\r\n        uint256 digits;\r\n        while (temp != 0) {\r\n            digits++;\r\n            temp /= 10;\r\n        }\r\n        bytes memory buffer = new bytes(digits);\r\n        while (value != 0) {\r\n            digits -= 1;\r\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\r\n            value /= 10;\r\n        }\r\n        return string(buffer);\r\n    }\nfunction totalSupply() public view returns (uint256) {\r\n        unchecked {\r\n            return _currentIndex - _burnCounter - _startTokenId();\r\n        }\r\n    }\nmodifier nonReentrant() {\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n\r\n        _status = _ENTERED;\r\n\r\n        _;\r\n\r\n        _status = _NOT_ENTERED;\r\n    }",
    "rewritten_code": {
      "saleMint": "function saleMint(uint256 _ammount) external payable nonReentrant {\n        uint numberNftSold = _totalMinted();\n        uint price = priceSale;\n        require(sellingStep != Steps.SoldOut, \"Sorry, no NFTs left.\");\n        require(sellingStep == Steps.Sale, \"Sorry, sale has not started yet.\");\n        require(msg.value >= price * _ammount, \"Not enought funds.\");\n       \n        require(nftsPerWalletSale[msg.sender] < max_mint_allowed, string(abi.encodePacked(\"You can only get \",\n        Strings.toString(max_mint_allowed),\" NFT on the Sale\")));\n\n         require(_ammount <= max_mint_allowed, string(abi.encodePacked(\"You can't mint more than \",\n        Strings.toString(max_mint_allowed),\" tokens\")));\n\n        require(numberNftSold + _ammount <= MAX_SUPPLY, \"Sale is almost done and we don't have enought NFTs left.\");\n        nftsPerWalletSale[msg.sender] += _ammount;\n        \n        _safeMint(msg.sender, _ammount);\n        \n        if(numberNftSold + _ammount == MAX_SUPPLY) {\n            sellingStep = Steps.SoldOut;   \n        }\n    }"
    }
  }
]