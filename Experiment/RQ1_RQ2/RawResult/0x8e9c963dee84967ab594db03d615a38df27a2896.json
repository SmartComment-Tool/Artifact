[
  {
    "contract": "BoredApePixelClubOrdinals",
    "function": "mint",
    "explanation": "Used totalSupply() (existing tokens) instead of _totalMinted() for minted count calculation",
    "contract_code": "\n=== Implementation of Function mint(address,uint256) ===\nfunction mint(address to, uint256 quantity) external payable nonReentrant callerIsUser {\n        require(!mintPaused, \"Mint is paused\");\n\n        uint256 totalCost = mintPrice * quantity;\n        uint256 totalMinted = totalSupply() + quantity;\n        require(msg.value >= totalCost, \"Not enough balance for mint the quantity supplied\");\n        require(totalMinted  <= maxSupply, \"Not enough supply left for this mint quantity\");\n\n        require( numberMinted(to) + quantity <= maxMintPerWallet, \"Can not mint this many\");\n\n        require(totalMinted  <= nextPause, \"Pause Breakpoint: Not enough supply left for this mint quantity\");\n\n        _safeMint(to, quantity);\n\n        refundIfOver(totalCost);\n\n        emit Minted(to, quantity, totalMinted);\n\n        uint256 next = (totalSupply() / nextPause) * nextPause;\n        if(next == totalMinted) {\n            mintPaused = true;\n            emit MintPaused(mintPaused);\n            emit PauseBreakpoint(next);\n        }\n    }\n    \n=== Functions that function mint internally calls ===\nfunction _safeMint(address to, uint256 quantity) internal virtual {\r\n        _safeMint(to, quantity, '');\r\n    }\nfunction numberMinted(address owner) public view returns (uint256) {\n        return _numberMinted(owner);\n    }\nfunction refundIfOver(uint256 price) private {\n        require(msg.value >= price, \"Need to send more ETH.\");\n        if (msg.value > price) {\n            payable(msg.sender).transfer(msg.value - price);\n        }\n    }\nfunction totalSupply() public view virtual override returns (uint256) {\r\n        unchecked {\r\n            return _currentIndex - _burnCounter - _startTokenId();\r\n        }\r\n    }\nmodifier callerIsUser() {\n        require(tx.origin == msg.sender, \"The caller is another contract\");\n        _;\n    }\nmodifier nonReentrant() {\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        _status = _ENTERED;\n\n        _;\n\n        _status = _NOT_ENTERED;\n    }",
    "rewritten_code": {
      "mint": "function mint(address to, uint256 quantity) external payable nonReentrant callerIsUser {\n        require(!mintPaused, \"Mint is paused\");\n\n        uint256 totalCost = mintPrice * quantity;\n        uint256 totalMinted = _totalMinted() + quantity;\n        require(msg.value >= totalCost, \"Not enough balance for mint the quantity supplied\");\n        require(totalMinted  <= maxSupply, \"Not enough supply left for this mint quantity\");\n\n        require( numberMinted(to) + quantity <= maxMintPerWallet, \"Can not mint this many\");\n\n        require(totalMinted  <= nextPause, \"Pause Breakpoint: Not enough supply left for this mint quantity\");\n\n        _safeMint(to, quantity);\n\n        refundIfOver(totalCost);\n\n        emit Minted(to, quantity, totalMinted);\n\n        uint256 next = (totalMinted / nextPause) * nextPause;\n        if(next == totalMinted) {\n            mintPaused = true;\n            emit MintPaused(mintPaused);\n            emit PauseBreakpoint(next);\n        }\n    }"
    }
  },
  {
    "contract": "ERC721A",
    "function": "setApprovalForAll",
    "explanation": "Missing check to prevent operator from being the caller.",
    "contract_code": "\n=== Implementation of Function setApprovalForAll(address,bool) ===\nfunction setApprovalForAll(address operator, bool approved) public virtual override {\r\n        _operatorApprovals[_msgSenderERC721A()][operator] = approved;\r\n        emit ApprovalForAll(_msgSenderERC721A(), operator, approved);\r\n    }\n    \n=== Functions that function setApprovalForAll internally calls ===\nfunction _msgSenderERC721A() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }",
    "rewritten_code": {
      "setApprovalForAll": "function setApprovalForAll(address operator, bool approved) public virtual override {\n        require(operator != _msgSenderERC721A(), \"ERC721: approve to caller\");\n        _operatorApprovals[_msgSenderERC721A()][operator] = approved;\n        emit ApprovalForAll(_msgSenderERC721A(), operator, approved);\n    }"
    }
  }
]