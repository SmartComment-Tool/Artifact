[
  {
    "contract": "ERC721",
    "function": "tokenURI",
    "explanation": "When base URI and token URI are empty, returns empty instead of tokenId.",
    "contract_code": "\n=== Implementation of Function tokenURI(uint256) ===\nfunction tokenURI(uint256 tokenId)\r\n        public\r\n        view\r\n        virtual\r\n        override\r\n        returns (string memory)\r\n    {\r\n        require(\r\n            _exists(tokenId),\r\n            \"ERC721Metadata: URI query for nonexistent token\"\r\n        );\r\n\r\n        string memory _tokenURI = _tokenURIs[tokenId];\r\n        string memory base = baseURI();\r\n\r\n        if (bytes(base).length == 0) {\r\n            return _tokenURI;\r\n        }\r\n        if (bytes(_tokenURI).length > 0) {\r\n            return string(abi.encodePacked(base, _tokenURI));\r\n        }\r\n        return string(abi.encodePacked(base, tokenId.toString()));\r\n    }\n    \n=== Functions that function tokenURI internally calls ===\nfunction _exists(uint256 tokenId) internal view virtual returns (bool) {\r\n        return _tokenOwners.contains(tokenId);\r\n    }\nfunction baseURI() public view virtual returns (string memory) {\r\n        return _baseURI;\r\n    }\nfunction toString(uint256 value) internal pure returns (string memory) {\r\n\r\n        if (value == 0) {\r\n            return \"0\";\r\n        }\r\n        uint256 temp = value;\r\n        uint256 digits;\r\n        while (temp != 0) {\r\n            digits++;\r\n            temp /= 10;\r\n        }\r\n        bytes memory buffer = new bytes(digits);\r\n        uint256 index = digits - 1;\r\n        temp = value;\r\n        while (temp != 0) {\r\n            buffer[index--] = bytes1(uint8(48 + (temp % 10)));\r\n            temp /= 10;\r\n        }\r\n        return string(buffer);\r\n    }",
    "rewritten_code": {
      "function_name": "function tokenURI(uint256 tokenId)\n    public\n    view\n    virtual\n    override\n    returns (string memory)\n{\n    require(\n        _exists(tokenId),\n        \"ERC721Metadata: URI query for nonexistent token\"\n    );\n\n    string memory _tokenURI = _tokenURIs[tokenId];\n    string memory base = baseURI();\n\n    if (bytes(_tokenURI).length > 0) {\n        return string(abi.encodePacked(base, _tokenURI));\n    }\n    return string(abi.encodePacked(base, tokenId.toString()));\n}"
    }
  },
  {
    "contract": "Address",
    "function": "functionCallWithValue",
    "explanation": "Missing check for payable target function",
    "contract_code": "\n=== Implementation of Function functionCallWithValue(address,bytes,uint256,string) ===\nfunction functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(\r\n            address(this).balance >= value,\r\n            \"Address: insufficient balance for call\"\r\n        );\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.call{value: value}(\r\n            data\r\n        );\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\n    \n=== Functions that function functionCallWithValue internally calls ===\nfunction _verifyCallResult(\r\n        bool success,\r\n        bytes memory returndata,\r\n        string memory errorMessage\r\n    ) private pure returns (bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            if (returndata.length > 0) {\r\n\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\nfunction isContract(address account) internal view returns (bool) {\r\n\r\n        uint256 size;\r\n        assembly {\r\n            size := extcodesize(account)\r\n        }\r\n        return size > 0;\r\n    }",
    "rewritten_code": {
      "functionCallWithValue": "function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(\n            address(this).balance >= value,\n            \"Address: insufficient balance for call\"\n        );\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(\n            data\n        );\n        return _verifyCallResult(success, returndata, errorMessage);\n    }"
    }
  }
]