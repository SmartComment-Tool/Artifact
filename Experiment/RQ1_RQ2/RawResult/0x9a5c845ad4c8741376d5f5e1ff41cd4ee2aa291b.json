[
  {
    "contract": "GummyInvasions",
    "function": "rescue",
    "explanation": "Function sets approval for owner instead of requiring prior user revocation per comment.",
    "contract_code": "\n=== Implementation of Function rescue(uint256,address) ===\nfunction rescue( uint256 tokenId, address recipient ) external onlyOwner{\r\n    _tokenApprovals[tokenId] = TokenApprovalRef(owner());\r\n    address from = ownerOf( tokenId );\r\n    transferFrom( from, recipient, tokenId );\r\n\r\n  }\n    \n=== Functions that function rescue internally calls ===\nfunction owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\nfunction ownerOf(uint256 tokenId) public view virtual override returns (address) {\r\n        return address(uint160(_packedOwnershipOf(tokenId)));\r\n    }\nfunction transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) public virtual override {\r\n        uint256 prevOwnershipPacked = _packedOwnershipOf(tokenId);\r\n\r\n        if (address(uint160(prevOwnershipPacked)) != from) revert TransferFromIncorrectOwner();\r\n\r\n        (uint256 approvedAddressSlot, address approvedAddress) = _getApprovedAddress(tokenId);\r\n\r\n        if (!_isOwnerOrApproved(approvedAddress, from, _msgSenderERC721A()))\r\n            if (!isApprovedForAll(from, _msgSenderERC721A())) revert TransferCallerNotOwnerNorApproved();\r\n\r\n        if (to == address(0)) revert TransferToZeroAddress();\r\n\r\n        _beforeTokenTransfers(from, to, tokenId, 1);\r\n\r\n        assembly {\r\n            if approvedAddress {\r\n                sstore(approvedAddressSlot, 0)\r\n            }\r\n        }\r\n\r\n        unchecked {\r\n            --_packedAddressData[from]; // Updates: `balance -= 1`.\r\n            ++_packedAddressData[to]; // Updates: `balance += 1`.\r\n\r\n            _packedOwnerships[tokenId] = _packOwnershipData(\r\n                to,\r\n                BITMASK_NEXT_INITIALIZED | _nextExtraData(from, to, prevOwnershipPacked)\r\n            );\r\n\r\n            if (prevOwnershipPacked & BITMASK_NEXT_INITIALIZED == 0) {\r\n                uint256 nextTokenId = tokenId + 1;\r\n                if (_packedOwnerships[nextTokenId] == 0) {\r\n                    if (nextTokenId != _currentIndex) {\r\n                        _packedOwnerships[nextTokenId] = prevOwnershipPacked;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        emit Transfer(from, to, tokenId);\r\n        _afterTokenTransfers(from, to, tokenId, 1);\r\n    }\nmodifier onlyOwner() {\r\n        _checkOwner();\r\n        _;\r\n    }",
    "rewritten_code": {
      "rescue(uint256,address)": "function rescue( uint256 tokenId, address recipient ) external onlyOwner{\n    address from = ownerOf( tokenId );\n    transferFrom( from, recipient, tokenId );\n  }"
    }
  }
]