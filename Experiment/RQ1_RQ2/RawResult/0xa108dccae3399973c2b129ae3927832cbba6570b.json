[
  {
    "contract": "STYK_I",
    "function": "checkInflation",
    "explanation": "Comment states conversion from 10^8 to 10^18 decimals, but implementation divides by 1e12 instead of multiplying by 1e10",
    "contract_code": "\n=== Implementation of Function checkInflation() ===\nfunction checkInflation() external view returns (uint256) {\r\n        return _inflation();\r\n    }\n    \n=== Functions that function checkInflation internally calls ===\nfunction _inflation() internal view returns (uint256) {\r\n        uint256 buyPrice_ = buyPrice();\r\n        uint256 inflation_factor = safeDiv(buyPrice_, 1e12);\r\n        return inflation_factor;\r\n    }",
    "rewritten_code": {
      "function_name": "function checkInflation() external view returns (uint256) {\n    return safeMul(_inflation(), 1e10);\n}"
    }
  },
  {
    "contract": "STYK_I",
    "function": "buyPrice",
    "explanation": "Function named buyPrice() calculates buy price but comment describes sell price logic",
    "contract_code": "\n=== Implementation of Function buyPrice() ===\nfunction buyPrice() public view returns (uint256) {\r\n        if (tokenSupply_ == 0) {\r\n            return tokenPriceInitial_ + tokenPriceIncremental_;\r\n        } else {\r\n            uint256 _ethereum = tokensToEthereum_(1e18);\r\n            uint256 _dividends = safeDiv(_ethereum, dividendFee_);\r\n            uint256 _taxedEthereum = safeAdd(_ethereum, _dividends);\r\n            return _taxedEthereum;\r\n        }\r\n    }\n    \n=== Functions that function buyPrice internally calls ===\nfunction safeAdd(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n        return c;\r\n    }\nfunction safeDiv(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return safeDiv(a, b, \"SafeMath: division by zero\");\r\n    }\nfunction tokensToEthereum_(uint256 _tokens)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        uint256 tokens_ = (_tokens + 1e18);\r\n        uint256 _tokenSupply = (tokenSupply_ + 1e18);\r\n        uint256 _etherReceived =\r\n            (// underflow attempts BTFO\r\n            safeSub(\r\n                (((tokenPriceInitial_ +\r\n                    (tokenPriceIncremental_ * (_tokenSupply / 1e18))) -\r\n                    tokenPriceIncremental_) * (tokens_ - 1e18)),\r\n                (tokenPriceIncremental_ * ((tokens_**2 - tokens_) / 1e18)) / 2\r\n            ) / 1e18);\r\n        return _etherReceived;\r\n    }",
    "rewritten_code": {
      "function_name": "function buyPrice() public view returns (uint256) {\n    if (tokenSupply_ == 0) {\n        return tokenPriceInitial_ - tokenPriceIncremental_;\n    } else {\n        uint256 _ethereum = tokensToEthereum_(1e18);\n        uint256 _dividends = safeDiv(_ethereum, dividendFee_);\n        uint256 _taxedEthereum = safeSub(_ethereum, _dividends);\n        return _taxedEthereum;\n    }\n}"
    }
  },
  {
    "contract": "STYK_I",
    "function": "claimMonthlyRewards",
    "explanation": "Function tracks rewards but doesn't transfer them to user",
    "contract_code": "\n=== Implementation of Function claimMonthlyRewards() ===\nfunction claimMonthlyRewards() external {\r\n        address _customerAddress = msg.sender;\r\n        \r\n        require(_calculateMonthlyRewards(_customerAddress) > 0 ,\"ERR_YOU_DONT_QUALIFY\");\r\n        \r\n        uint256 daysPayout = safeSub(getDaysInMonth(getMonth(now), getYear(now)),1);\r\n\r\n        require(\r\n            (getDay(now) == daysPayout || getDay(now) == getDaysInMonth(getMonth(now), getYear(now))),\r\n            \"ERR_CANNOT_CLAIM_BEFORE_PAYOUT\"\r\n        );\r\n        \r\n        require(!monthlyRewardsClaimed[_customerAddress][getYear(now)][getMonth(now)],\"ERR_REWARD_ALREADY_CLAIMED\");\r\n        \r\n        if (_calculateTokenPercentage(_customerAddress) != 0) {\r\n            totalMonthRewards[_customerAddress] = safeAdd(\r\n                totalMonthRewards[_customerAddress],\r\n                _calculateMonthlyRewards(_customerAddress)\r\n            );\r\n            monthlyRewardsClaimed[_customerAddress][getYear(now)][getMonth(now)] = true;\r\n        \r\n        }\r\n    }\n    \n=== Functions that function claimMonthlyRewards internally calls ===\nfunction _calculateMonthlyRewards(address _to)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        uint256 token_percent = _teamTokenHolder(_to);\r\n        if (token_percent != 0) {\r\n            uint256 rewards =\r\n                safeDiv(\r\n                    safeMul(\r\n                        _dividendsOfPremintedTokens(MONTHLY_REWARD_TOKENS),\r\n                        token_percent\r\n                    ),\r\n                    1000000\r\n                );\r\n\r\n            return rewards;\r\n        }\r\n        return 0;\r\n    }\nfunction _calculateTokenPercentage(address _customerAddress)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        if (tokenBalanceLedger_[_customerAddress] > 0) {\r\n            uint256 token_percent =\r\n                safeDiv(\r\n                    safeMul(tokenBalanceLedger_[_customerAddress], 1000000),\r\n                    totalSupply()\r\n                );\r\n            return token_percent;\r\n        }\r\n        return 0;\r\n    }\nfunction getDay(uint timestamp) public pure returns (uint8) {\r\n                return parseTimestamp(timestamp).day;\r\n        }\nfunction getDaysInMonth(uint8 month, uint16 year) public pure returns (uint8) {\r\n                if (month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) {\r\n                        return 31;\r\n                }\r\n                else if (month == 4 || month == 6 || month == 9 || month == 11) {\r\n                        return 30;\r\n                }\r\n                else if (isLeapYear(year)) {\r\n                        return 29;\r\n                }\r\n                else {\r\n                        return 28;\r\n                }\r\n        }\nfunction getMonth(uint timestamp) public pure returns (uint8) {\r\n                return parseTimestamp(timestamp).month;\r\n        }\nfunction getYear(uint timestamp) public pure returns (uint16) {\r\n                uint secondsAccountedFor = 0;\r\n                uint16 year;\r\n                uint numLeapYears;\r\n\r\n                year = uint16(ORIGIN_YEAR + timestamp / YEAR_IN_SECONDS);\r\n                numLeapYears = leapYearsBefore(year) - leapYearsBefore(ORIGIN_YEAR);\r\n\r\n                secondsAccountedFor += LEAP_YEAR_IN_SECONDS * numLeapYears;\r\n                secondsAccountedFor += YEAR_IN_SECONDS * (year - ORIGIN_YEAR - numLeapYears);\r\n\r\n                while (secondsAccountedFor > timestamp) {\r\n                        if (isLeapYear(uint16(year - 1))) {\r\n                                secondsAccountedFor -= LEAP_YEAR_IN_SECONDS;\r\n                        }\r\n                        else {\r\n                                secondsAccountedFor -= YEAR_IN_SECONDS;\r\n                        }\r\n                        year -= 1;\r\n                }\r\n                return year;\r\n        }\nfunction safeAdd(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n        return c;\r\n    }\nfunction safeSub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return safeSub(a, b, \"SafeMath: subtraction overflow\");\r\n    }",
    "rewritten_code": {
      "function_name": "function claimMonthlyRewards() external {\n    address _customerAddress = msg.sender;\n    require(_calculateMonthlyRewards(_customerAddress) > 0, \"ERR_YOU_DONT_QUALIFY\");\n    uint256 daysPayout = safeSub(getDaysInMonth(getMonth(now), getYear(now)),1);\n    require((getDay(now) == daysPayout || getDay(now) == getDaysInMonth(getMonth(now), getYear(now))), \"ERR_CANNOT_CLAIM_BEFORE_PAYOUT\");\n    require(!monthlyRewardsClaimed[_customerAddress][getYear(now)][getMonth(now)], \"ERR_REWARD_ALREADY_CLAIMED\");\n    uint256 rewards = _calculateMonthlyRewards(_customerAddress);\n    totalMonthRewards[_customerAddress] = safeAdd(totalMonthRewards[_customerAddress], rewards);\n    tokenBalanceLedger_[_customerAddress] = safeAdd(tokenBalanceLedger_[_customerAddress], rewards);\n    monthlyRewardsClaimed[_customerAddress][getYear(now)][getMonth(now)] = true;\n}"
    }
  },
  {
    "contract": "STYK_I",
    "function": "sellPrice",
    "explanation": "Function calculates sell price but comment specifies buy price.",
    "contract_code": "\n=== Implementation of Function sellPrice() ===\nfunction sellPrice() external view returns (uint256) {\r\n        if (tokenSupply_ == 0) {\r\n            return tokenPriceInitial_ - tokenPriceIncremental_;\r\n        } else {\r\n            uint256 _ethereum = tokensToEthereum_(1e18);\r\n            uint256 _dividends = safeDiv(_ethereum, dividendFee_);\r\n            uint256 _taxedEthereum = safeSub(_ethereum, _dividends);\r\n            return _taxedEthereum;\r\n        }\r\n    }\n    \n=== Functions that function sellPrice internally calls ===\nfunction safeDiv(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return safeDiv(a, b, \"SafeMath: division by zero\");\r\n    }\nfunction safeSub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return safeSub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\nfunction tokensToEthereum_(uint256 _tokens)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        uint256 tokens_ = (_tokens + 1e18);\r\n        uint256 _tokenSupply = (tokenSupply_ + 1e18);\r\n        uint256 _etherReceived =\r\n            (// underflow attempts BTFO\r\n            safeSub(\r\n                (((tokenPriceInitial_ +\r\n                    (tokenPriceIncremental_ * (_tokenSupply / 1e18))) -\r\n                    tokenPriceIncremental_) * (tokens_ - 1e18)),\r\n                (tokenPriceIncremental_ * ((tokens_**2 - tokens_) / 1e18)) / 2\r\n            ) / 1e18);\r\n        return _etherReceived;\r\n    }",
    "rewritten_code": {
      "sellPrice()": "function sellPrice() external view returns (uint256) {\n        if (tokenSupply_ == 0) {\n            return tokenPriceInitial_ + tokenPriceIncremental_;\n        } else {\n            uint256 _ethereum = tokensToEthereum_(1e18);\n            uint256 _dividends = safeDiv(_ethereum, dividendFee_);\n            uint256 _taxedEthereum = safeAdd(_ethereum, _dividends);\n            return _taxedEthereum;\n        }\n    }"
    }
  },
  {
    "contract": "STYK_I",
    "function": "release",
    "explanation": "Release function adds tokens to supply but doesn't transfer from contract's balance",
    "contract_code": "\n=== Implementation of Function release() ===\nfunction release() external {\r\n        require(now > lockTime, \"ERR_CANNOT_RELEASE_TOKENS_BEFORE_LOCK_TIME\");\r\n\r\n        uint256 amount = tokenBalanceLedger_[address(this)];\r\n        tokenSupply_ = safeAdd(tokenSupply_, amount);\r\n    }\n    \n=== Functions that function release internally calls ===\nfunction safeAdd(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n        return c;\r\n    }",
    "rewritten_code": {
      "release": "function release() external {\n        require(now > lockTime, \"ERR_CANNOT_RELEASE_TOKENS_BEFORE_LOCK_TIME\");\n        uint256 amount = tokenBalanceLedger_[address(this)];\n        tokenBalanceLedger_[address(this)] = safeSub(tokenBalanceLedger_[address(this)], amount);\n        tokenSupply_ = safeAdd(tokenSupply_, amount);\n    }"
    }
  }
]