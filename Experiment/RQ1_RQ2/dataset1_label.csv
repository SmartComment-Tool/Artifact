address,contract,function,manual_label,type,explaination,violated_comments,origin_implementation,improved_implementation
0x00000000000881d280439988781f743e8cdd1fdf,LancetPasscard,setApprovalForAll,TRUE,Condition Check,Missing check that operator cannot be the caller as per comment requirements.,The `operator` cannot be the caller.,"""\n=== Implementation of Function setApprovalForAll(address,bool) ===\nfunction setApprovalForAll(address operator, bool approved)\r\n        public\r\n        override (IERC721A, ERC721A)\r\n        onlyAllowedOperatorApproval(operator)\r\n    {\r\n        super.setApprovalForAll(operator, approved);\r\n    }\n    \n=== Functions that function setApprovalForAll internally calls ===\nfunction setApprovalForAll(address operator, bool approved) public virtual override {\n        _operatorApprovals[_msgSenderERC721A()][operator] = approved;\n        emit ApprovalForAll(_msgSenderERC721A(), operator, approved);\n    }\nmodifier onlyAllowedOperatorApproval(address operator) virtual {\n        if (!_isPriorityOperator(operator)) {\n            if (_operatorFilteringEnabled()) _revertIfBlocked(operator);\n        }\n        _;\n    }""","{
  ""setApprovalForAll(address,bool)"": ""function setApprovalForAll(address operator, bool approved) public override (IERC721A, ERC721A) onlyAllowedOperatorApproval(operator) {\n        require(operator != msg.sender, \""Operator cannot be caller\"");\n        super.setApprovalForAll(operator, approved);\n    }""
}"
0x00d2f4abb3166aabb8e5d8d43e6d571f9a455621,ERC1363,approveAndCall,FALSE,Suggestion,Approval race condition mitigation not implemented per comment,One possible solution to mitigate this race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards,"""\n=== Implementation of Function approveAndCall(address,uint256,bytes) ===\nfunction approveAndCall(address spender, uint256 value, bytes memory data) public override returns (bool) {\r\n        approve(spender, value);\r\n        require(_checkAndCallApprove(spender, value, data), \""ERC1363: _checkAndCallApprove reverts\"");\r\n        return true;\r\n    }\n    \n=== Functions that function approveAndCall internally calls ===\nfunction _checkAndCallApprove(address spender, uint256 value, bytes memory data) internal returns (bool) {\r\n        if (!spender.isContract()) {\r\n            return false;\r\n        }\r\n        bytes4 retval = IERC1363Spender(spender).onApprovalReceived(\r\n            _msgSender(), value, data\r\n        );\r\n        return (retval == _ERC1363_APPROVED);\r\n    }\nfunction approve(address spender, uint256 amount) public virtual override returns (bool) {\r\n        _approve(_msgSender(), spender, amount);\r\n        return true;\r\n    }""","{
  ""approveAndCall(address,uint256,bytes)"": ""function approveAndCall(address spender, uint256 value, bytes memory data) public override returns (bool) {\n        approve(spender, 0);\n        approve(spender, value);\n        require(_checkAndCallApprove(spender, value, data), \""ERC1363: _checkAndCallApprove reverts\"");\n        return true;\n    }""
}"
0x0130f6b97c9853af6aec4484357eeea2ba2026e3,MultiSigWallet,getTransactionIds,TRUE,Business Logic,Function returns transaction IDs beyond filtered list length if 'to' exceeds available entries.,Returns list of transaction IDs in defined range.,"""\n=== Implementation of Function getTransactionIds(uint256,uint256,bool,bool) ===\nfunction getTransactionIds(uint from, uint to, bool pending, bool executed)\r\n        public\r\n        constant\r\n        returns (uint[] _transactionIds)\r\n    {\r\n        uint[] memory transactionIdsTemp = new uint[](transactionCount);\r\n        uint count = 0;\r\n        uint i;\r\n        for (i=0; i<transactionCount; i++)\r\n            if (   pending && !transactions[i].executed\r\n                || executed && transactions[i].executed)\r\n            {\r\n                transactionIdsTemp[count] = i;\r\n                count += 1;\r\n            }\r\n        _transactionIds = new uint[](to - from);\r\n        for (i=from; i<to; i++)\r\n            _transactionIds[i - from] = transactionIdsTemp[i];\r\n    }\n    ""","{
  ""getTransactionIds"": ""function getTransactionIds(uint from, uint to, bool pending, bool executed) public constant returns (uint[] _transactionIds) {\n        uint[] memory transactionIdsTemp = new uint[](transactionCount);\n        uint count = 0;\n        for (uint i=0; i<transactionCount; i++) {\n            if ((pending && !transactions[i].executed) || (executed && transactions[i].executed)) {\n                transactionIdsTemp[count] = i;\n                count++;\n            }\n        }\n        require(to <= count && from <= to);\n        _transactionIds = new uint[](to - from);\n        for (uint j=from; j<to; j++) {\n            _transactionIds[j - from] = transactionIdsTemp[j];\n        }\n    }""
}"
0x0130f6b97c9853af6aec4484357eeea2ba2026e3,MultiSigWallet,executeTransaction,TRUE,Access Control,Function restricts execution to owners but comment permits anyone,Allows anyone to execute a confirmed transaction.,"""\n=== Implementation of Function executeTransaction(uint256) ===\nfunction executeTransaction(uint transactionId)\r\n        public\r\n        ownerExists(msg.sender)\r\n        confirmed(transactionId, msg.sender)\r\n        notExecuted(transactionId)\r\n    {\r\n        if (isConfirmed(transactionId)) {\r\n            Transaction storage txn = transactions[transactionId];\r\n            txn.executed = true;\r\n            if (external_call(txn.destination, txn.value, txn.data.length, txn.data))\r\n                Execution(transactionId);\r\n            else {\r\n                ExecutionFailure(transactionId);\r\n                txn.executed = false;\r\n            }\r\n        }\r\n    }\n    \n=== Functions that function executeTransaction internally calls ===\nfunction external_call(address destination, uint value, uint dataLength, bytes data) private returns (bool) {\r\n        bool result;\r\n        assembly {\r\n            let x := mload(0x40)   // \""Allocate\"" memory for output (0x40 is where \""free memory\"" pointer is stored by convention)\r\n            let d := add(data, 32) // First 32 bytes are the padded length of data, so exclude that\r\n            result := call(\r\n                sub(gas, 34710),   // 34710 is the value that solidity is currently emitting\r\n                destination,\r\n                value,\r\n                d,\r\n                dataLength,        // Size of the input (in bytes) - this is what fixes the padding problem\r\n                x,\r\n                0                  // Output is ignored, therefore the output size is zero\r\n            )\r\n        }\r\n        return result;\r\n    }\nfunction isConfirmed(uint transactionId)\r\n        public\r\n        constant\r\n        returns (bool)\r\n    {\r\n        uint count = 0;\r\n        for (uint i=0; i<owners.length; i++) {\r\n            if (confirmations[transactionId][owners[i]])\r\n                count += 1;\r\n            if (count == required)\r\n                return true;\r\n        }\r\n    }\nmodifier confirmed(uint transactionId, address owner) {\r\n        require(confirmations[transactionId][owner]);\r\n        _;\r\n    }\nmodifier notExecuted(uint transactionId) {\r\n        require(!transactions[transactionId].executed);\r\n        _;\r\n    }\nmodifier ownerExists(address owner) {\r\n        require(isOwner[owner]);\r\n        _;\r\n    }""","{
  ""executeTransaction"": ""function executeTransaction(uint transactionId)\n    public\n    confirmed(transactionId, msg.sender)\n    notExecuted(transactionId)\n{\n    if (isConfirmed(transactionId)) {\n        Transaction storage txn = transactions[transactionId];\n        txn.executed = true;\n        if (external_call(txn.destination, txn.value, txn.data.length, txn.data))\n            Execution(transactionId);\n        else {\n            ExecutionFailure(transactionId);\n            txn.executed = false;\n        }\n    }\n}""
}"
0x014bdf5237c49fa2b1283aade4db4f78c4c11777,FlipItBurgerIngredient,uri,FALSE,Suggestion/Other Discription,URI implementation appends tokenId instead of using {id} substitution,"If the `{id}` substring is present in the URI, it must be replaced by clients with the actual token type ID.","""\n=== Implementation of Function uri(uint256) ===\nfunction uri(uint256 tokenId) public view override returns (string memory) {\n        return string(abi.encodePacked(super.uri(tokenId), tokenId.toString(), \"".json\""));\n    }\n    \n=== Functions that function uri internally calls ===\nfunction toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\nfunction uri(uint256) public view virtual override returns (string memory) {\n        return _uri;\n    }""","{
  ""uri(uint256)"": ""function uri(uint256 tokenId) public view override returns (string memory) {\n        return super.uri(tokenId);\n    }""
}"
0x030871127463a13accc1f57b7507641540951918,MikuInu,_getValues,TRUE,Business Logic,"Return statement includes _localVal[10] which is not described in comments, missing rTax/tTAx in return values.",/*rTax*/,"""\n=== Implementation of Function _getValues(uint256) ===\nfunction _getValues(uint256 tAmount) private view returns (uint256, uint256, uint256, uint256, uint256,uint256,uint256,uint256) {\r\n        uint256[12] memory _localVal;\r\n        (_localVal[0]/**tTransferAmount*/, _localVal[1]  /**tFee*/, _localVal[2] /**tBurnValue*/,_localVal[8]/*tTAx*/) = _getTValues(tAmount);\r\n        _localVal[3] /**currentRate*/ =  _getRate();\r\n        ( _localVal[4] /**rAmount*/,  _localVal[5] /**rTransferAmount*/, _localVal[6] /**rFee*/, _localVal[7] /**rBurnValue*/,_localVal[9]/*rTax*/) = _getRValues(tAmount, _localVal[1], _localVal[3], _localVal[2],_localVal[8]);\r\n        return (_localVal[4], _localVal[5], _localVal[6], _localVal[0], _localVal[1], _localVal[2],_localVal[8],_localVal[10]);\r\n    }\n    \n=== Functions that function _getValues internally calls ===\nfunction _getRValues(uint256 tAmount, uint256 tFee, uint256 currentRate, uint256 tBurnValue,uint256 tTax) private pure returns (uint256, uint256, uint256,uint256,uint256) {\r\n        uint256 rAmount = tAmount.mul(currentRate);\r\n        uint256 rFee = tFee.mul(currentRate);\r\n        uint256 rBurnValue = tBurnValue.mul(currentRate);\r\n        uint256 rTax = tTax.mul(currentRate);\r\n        uint256 rTransferAmount = rAmount.sub(rFee).sub(rBurnValue).sub(rTax);\r\n        return (rAmount, rTransferAmount, rFee, rBurnValue,rTax);\r\n    }\nfunction _getRate() private view returns(uint256) {\r\n        (uint256 rSupply, uint256 tSupply) = _getCurrentSupply();\r\n        return rSupply.div(tSupply);\r\n    }\nfunction _getTValues(uint256 tAmount) private pure returns (uint256, uint256, uint256,uint256) {\r\n        uint256[5] memory _localVal;\r\n        \r\n        _localVal[0]/**tTax*/ = tAmount.div(100).mul(5);\r\n        _localVal[1]/**tBurnValue*/ = tAmount.div(100).mul(3);\r\n        _localVal[2]/**tFee*/ = tAmount.div(100).mul(2);\r\n        _localVal[4]/**tTransferAmount*/ = tAmount.sub(_localVal[2]).sub(_localVal[1]).sub(_localVal[0]);\r\n        return (_localVal[4], _localVal[2], _localVal[1],_localVal[0]);\r\n    }""","{
  ""_getValues"": ""function _getValues(uint256 tAmount) private view returns (uint256, uint256, uint256, uint256, uint256,uint256,uint256,uint256) {\n        uint256[12] memory _localVal;\n        (_localVal[0], _localVal[1], _localVal[2], _localVal[8]) = _getTValues(tAmount);\n        _localVal[3] = _getRate();\n        ( _localVal[4], _localVal[5], _localVal[6], _localVal[7], _localVal[9]) = _getRValues(tAmount, _localVal[1], _localVal[3], _localVal[2], _localVal[8]);\n        return (_localVal[4], _localVal[5], _localVal[6], _localVal[0], _localVal[1], _localVal[2], _localVal[8], _localVal[9]);\n    }""
}"
0x064bb504c7dd58dacd1629ca98ffa67081c6cc88,CoinToken,constructor,FALSE,,Comment specifies service.transfer but implementation uses low-level call,// service.transfer(msg.value);,"""\n=== Implementation of Function constructor(string,string,uint256,uint256,uint256,uint256,address,address,address) ===\nconstructor(string memory _name, string memory _symbol, uint256 _decimals, uint256 _supply, uint256 _txFee,uint256 _burnFee,address _FeeAddress,address tokenOwner,address service) public payable {\r\n        name = _name;\r\n        symbol = _symbol;\r\n        decimals = _decimals;\r\n        totalSupply = _supply * 10**_decimals;\r\n        balances[tokenOwner] = totalSupply;\r\n        owner = tokenOwner;\r\n        txFee = _txFee;\r\n        burnFee = _burnFee;\r\n        FeeAddress = _FeeAddress;\r\n        (bool success) = service.call.value(msg.value)();\r\n        require(success, \""Transfer failed.\"");\r\n        emit Transfer(address(0), tokenOwner, totalSupply);\r\n    }\n    ""","{
  ""constructor"": ""constructor(string memory _name, string memory _symbol, uint256 _decimals, uint256 _supply, uint256 _txFee,uint256 _burnFee,address _FeeAddress,address tokenOwner,address service) public payable {\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n        totalSupply = _supply * 10**_decimals;\n        balances[tokenOwner] = totalSupply;\n        owner = tokenOwner;\n        txFee = _txFee;\n        burnFee = _burnFee;\n        FeeAddress = _FeeAddress;\n        service.transfer(msg.value);\n        emit Transfer(address(0), tokenOwner, totalSupply);\n    }""
}"
0x07567f9c3ec198174737451f95fa5b7359615c8a,IouVesting,unstake,FALSE,Understanding (decimial),Donation ratio check uses 100 instead of 1e18 for 100% in 18 decimals,The percentage ratio you want to donate (in 18 decimals; 0.15 * 10^18),"""\n=== Implementation of Function unstake(uint256,uint256) ===\nfunction unstake(uint256 amount, uint256 donationRatio) external override {\r\n        require(\r\n            amount > uint256(0),\r\n            \""IouVesting: Unstake amount needs to be greater than 0\""\r\n        );\r\n        require(\r\n            userShares[msg.sender] != uint256(0),\r\n            \""IouVesting: There is nothing to unstake for you\""\r\n        );\r\n\r\n        require(\r\n            userShares[msg.sender] >= amount,\r\n            \""IouVesting: You cannot unstake more than you staked\""\r\n        );\r\n\r\n        require(\r\n            donationRatio <= uint256(100),\r\n            \""IouVesting: You cannot donate more than you earned\""\r\n        );\r\n\r\n        uint256 amountVsSharesRatio =\r\n            getRatio(amount, userShares[msg.sender], 18);\r\n        uint256 totalUserPossibleRewards =\r\n            (computeUserTotalPossibleRewards(msg.sender, false) *\r\n                amountVsSharesRatio) / (10**18);\r\n\r\n        uint256 totalCurrentUserRewards =\r\n            (getCurrentRewards(true) * amountVsSharesRatio) / (10**18);\r\n\r\n        if (totalRewards() > 0) {\r\n            uint256 donationAmount = 0;\r\n            if (donationAddress != address(0) && donationRatio > 0) {\r\n                donationAmount =\r\n                    (donationRatio * totalCurrentUserRewards) /\r\n                    (10**18);\r\n            }\r\n\r\n            uint256 toTransferToUser = totalCurrentUserRewards;\r\n            if (donationAmount > 0) {\r\n                toTransferToUser = totalCurrentUserRewards - donationAmount;\r\n                require(\r\n                    _rewardsPool.transfer(donationAddress, donationAmount),\r\n                    \""IouVesting: transfer from rewards pool to donation receiver failed\""\r\n                );\r\n            }\r\n\r\n            require(\r\n                _rewardsPool.transfer(msg.sender, toTransferToUser),\r\n                \""IouVesting: transfer from rewards pool failed\""\r\n            );\r\n            emit RewardsClaimed(msg.sender, toTransferToUser);\r\n            emit RewardsDonated(msg.sender, donationAmount);\r\n\r\n            userEarnings[msg.sender] += totalCurrentUserRewards;\r\n\r\n            availableForfeitedAmount += (totalUserPossibleRewards -\r\n                totalCurrentUserRewards);\r\n        }\r\n\r\n        require(\r\n            _iouPool.transfer(address(_lockedIouPool), amount),\r\n            \""IouVesting: transfer from iou pool to locked iou pool failed\""\r\n        );\r\n\r\n        userShares[msg.sender] -= amount;\r\n        if (userShares[msg.sender] == uint256(0)) {\r\n            totalUsers--;\r\n        }\r\n    }\n    \n=== Functions that function unstake internally calls ===\nfunction computeUserTotalPossibleRewards(\r\n        address user,\r\n        bool includeForfeited\r\n    ) private view returns (uint256) {\r\n        uint256 originalAmount = (userShares[user] * ratio) / (10**18);\r\n        if (!includeForfeited) return originalAmount;\r\n\r\n        uint256 shareVsTotalStakedRatio =\r\n            getRatio(userShares[user], totalStaked(), 18);\r\n        uint256 forfeitedAmount =\r\n            (shareVsTotalStakedRatio * availableForfeitedAmount) / (10**18);\r\n\r\n        return originalAmount.add(forfeitedAmount);\r\n    }\nfunction getCurrentRewards(bool includeForfeited)\r\n        public\r\n        view\r\n        override\r\n        returns (uint256)\r\n    {\r\n        require(\r\n            msg.sender != address(0),\r\n            \""IouVesting: Cannot get rewards for address(0).\""\r\n        );\r\n\r\n        require(\r\n            userShares[msg.sender] != uint256(0),\r\n            \""IouVesting: Sender hasn't staked anything.\""\r\n        );\r\n\r\n        return computeRewards(msg.sender, includeForfeited);\r\n    }\nfunction getRatio(\r\n        uint256 numerator,\r\n        uint256 denominator,\r\n        uint256 precision\r\n    ) private view returns (uint256) {\r\n        uint256 _numerator = numerator * 10**(precision + 1);\r\n        uint256 _quotient = ((_numerator / denominator) + 5) / 10;\r\n        return (_quotient);\r\n    }\nfunction totalRewards() public view override returns (uint256) {\r\n        return _rewardsPool.balance();\r\n    }\nfunction transfer(address to, uint256 value)\r\n        external\r\n        onlyOwner\r\n        returns (bool)\r\n    {\r\n        return token.transfer(to, value);\r\n    }""","{
  ""unstake"": ""function unstake(uint256 amount, uint256 donationRatio) external override {\n        require(amount > 0, \""IouVesting: Unstake amount needs to be greater than 0\"");\n        require(userShares[msg.sender] >= amount, \""IouVesting: You cannot unstake more than you staked\"");\n        require(donationRatio <= 1e18, \""IouVesting: Donation ratio exceeds 100%\"");\n\n        uint256 amountVsSharesRatio = getRatio(amount, userShares[msg.sender], 18);\n        uint256 totalUserPossibleRewards = (computeUserTotalPossibleRewards(msg.sender, false) * amountVsSharesRatio) / 1e18;\n        uint256 totalCurrentUserRewards = (getCurrentRewards(true) * amountVsSharesRatio) / 1e18;\n\n        if (totalRewards() > 0) {\n            uint256 donationAmount = 0;\n            if (donationAddress != address(0) && donationRatio > 0) {\n                donationAmount = (donationRatio * totalCurrentUserRewards) / 1e18;\n            }\n\n            uint256 toTransferToUser = totalCurrentUserRewards - donationAmount;\n            if (donationAmount > 0) {\n                require(_rewardsPool.transfer(donationAddress, donationAmount), \""Donation transfer failed\"");\n            }\n            require(_rewardsPool.transfer(msg.sender, toTransferToUser), \""Reward transfer failed\"");\n            emit RewardsClaimed(msg.sender, toTransferToUser);\n            emit RewardsDonated(msg.sender, donationAmount);\n\n            userEarnings[msg.sender] += totalCurrentUserRewards;\n            availableForfeitedAmount += (totalUserPossibleRewards - totalCurrentUserRewards);\n        }\n\n        require(_iouPool.transfer(address(_lockedIouPool), amount), \""IOU transfer failed\"");\n        userShares[msg.sender] -= amount;\n        if (userShares[msg.sender] == 0) totalUsers--;\n    }""
}"
0x07cd221b2fe54094277a2f4e1c1bc6df14e63678,ERC721,approve,FALSE,FALSE,"Code adds a check that 'to' cannot be the owner, which is not specified in the comments.","Gives permission to `to` to transfer `tokenId` token to another account. Only a single account can be approved at a time, so approving the zero address clears previous approvals.","""\n=== Implementation of Function approve(address,uint256) ===\nfunction approve(address to, uint256 tokenId) public virtual override {\n        address owner = ownerOf(tokenId);\n        require(to != owner, \""ERC721: approval to current owner\"");\n\n        require(_msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            \""ERC721: approve caller is not owner nor approved for all\""\n        );\n\n        _approve(to, tokenId);\n    }\n    \n=== Functions that function approve internally calls ===\nfunction _approve(address to, uint256 tokenId) private {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ownerOf(tokenId), to, tokenId);\n    }\nfunction _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\nfunction isApprovedForAll(address owner, address operator) public view override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\nfunction ownerOf(uint256 tokenId) public view override returns (address) {\n        return _tokenOwners.get(tokenId, \""ERC721: owner query for nonexistent token\"");\n    }""","{
  ""approve(address,uint256)"": ""function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ownerOf(tokenId);\n        require(_msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            \""ERC721: approve caller is not owner nor approved for all\""\n        );\n        _approve(to, tokenId);\n    }""
}"
0x0821f21f21c325ae39557ca83b6b4df525495d06,Aggregator,swap,TRUE,Function Interface,Comment specifies uint256 arrays but implementation uses int256 arrays.,Swaps the pointers to two uint256 arrays in memory,"""\n=== Implementation of Function swap(int256[],int256[]) ===\nfunction swap(int256[] memory _a, int256[] memory _b)\r\n    private\r\n    pure\r\n    returns(int256[] memory, int256[] memory)\r\n  {\r\n    return (_b, _a);\r\n  }\n    ""","{
  ""swap"": ""function swap(int256[] memory _a, int256[] memory _b)\n    private\n    pure\n    returns(int256[] memory, int256[] memory)\n  {\n    return (_b, _a);\n  }""
}"
0x084c3fe5ad3f59af848b372e3cb05093bc8355f4,Hashquests,mintMarketingHashquests,TRUE,Condition Check,"Marketing mint quota check uses < instead of <=, limiting to 9 instead of 10.",Mints NFTs for giveaways and marketing purposes - Limited to 10,"""\n=== Implementation of Function mintMarketingHashquests(uint256) ===\nfunction mintMarketingHashquests(uint256 numberOfNFTs) public onlyOwner {\r\n        require(mintedForMarketing.add(numberOfNFTs) < MARKETING_MINT_QUOTA, \""Can't exceed the marketing quota\"");\r\n        require(mintedForMarketing.add(numberOfNFTs) < MAX_NFT_SUPPLY, \""Can't exceed the max supply.\"");\r\n\r\n        for (uint i = 0; i < numberOfNFTs; i++) {\r\n            uint mintIndex = totalSupply();\r\n            _safeMint(msg.sender, mintIndex);\r\n        }\r\n        mintedForMarketing = mintedForMarketing.add(numberOfNFTs);\r\n    }\n    \n=== Functions that function mintMarketingHashquests internally calls ===\nfunction _safeMint(address to, uint256 tokenId) internal virtual {\r\n        _safeMint(to, tokenId, \""\"");\r\n    }\nfunction add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \""SafeMath: addition overflow\"");\r\n        return c;\r\n    }\nfunction totalSupply() public view virtual override returns (uint256) {\r\n        return _tokenOwners.length();\r\n    }\nmodifier onlyOwner() {\r\n        require(owner() == _msgSender(), \""Ownable: caller is not the owner\"");\r\n        _;\r\n    }""","{
  ""mintMarketingHashquests(uint256)"": ""function mintMarketingHashquests(uint256 numberOfNFTs) public onlyOwner {\n    require(mintedForMarketing.add(numberOfNFTs) <= MARKETING_MINT_QUOTA, \""Can't exceed the marketing quota\"");\n    require(mintedForMarketing.add(numberOfNFTs) <= MAX_NFT_SUPPLY, \""Can't exceed the max supply.\"");\n\n    for (uint i = 0; i < numberOfNFTs; i++) {\n        uint mintIndex = totalSupply();\n        _safeMint(msg.sender, mintIndex);\n    }\n    mintedForMarketing = mintedForMarketing.add(numberOfNFTs);\n}""
}"
0x08d2f5c96bb1f6be04b49bcd869d5af01db4c400,Witch,clear,FALSE,,"Function reverts when vault is owned by Witch, contradicting comment to remove auctions not owned by Witch.",Remove an auction for a vault that isn't owned by this Witch,"""\n=== Implementation of Function clear(bytes12) ===\nnction clear(bytes12 vaultId) external {\r\n        DataTypes.Auction memory auction_ = _auction(vaultId);\r\n        if (cauldron.vaults(vaultId).owner == address(this)) {\r\n            revert AuctionIsCorrect(vaultId);\r\n        }\r\n\r\n        limits[auction_.ilkId][auction_.baseId].sum -= auction_.ink;\r\n        delete auctions[vaultId];\r\n        emit Cleared(vaultId);\r\n    }\r\n\n    \n=== Functions that function clear internally calls ===\ns (DataTypes.Auction memory auction_)\r\n    {\r\n        auction_ = auctions[vaultId];\r\n\r\n        if (auction_.start == 0) {\r\n            revert VaultNotUnderAuction(vaultId);\r\n        }\r\n    }\r\n}""","{
  ""clear"": ""function clear(bytes12 vaultId) external {\n        DataTypes.Auction memory auction_ = _auction(vaultId);\n        if (cauldron.vaults(vaultId).owner != address(this)) {\n            revert AuctionIsCorrect(vaultId);\n        }\n\n        limits[auction_.ilkId][auction_.baseId].sum -= auction_.ink;\n        delete auctions[vaultId];\n        emit Cleared(vaultId);\n    }""
}"
0x097bf0b1678421cec9d00f326eeb2b69b1fa10f0,MINIWORLDCUPINU,_transfer,TRUE,Condition Check,"Comment references cooldown check, but code enforces max transaction amount without cooldown logic.",// Cooldown,"""\n=== Implementation of Function _transfer(address,address,uint256) ===\nfunction _transfer(address from, address to, uint256 amount) private {\n        require(from != address(0), \""ERC20: transfer from the zero address\"");\n        require(to != address(0), \""ERC20: transfer to the zero address\"");\n        require(amount > 0, \""Transfer amount must be greater than zero\"");\n\n\n        if (from != owner() && to != owner()) {\n            require(!bots[from] && !bots[to]);\n            _feeAddr1 = 0;\n            _feeAddr2 = (_reduceTaxCountdown==0)?_finalTax:_initialTax;\n            if (from == uniswapV2Pair && to != address(uniswapV2Router) && ! _isExcludedFromFee[to] && cooldownEnabled) {\n                require(amount <= _maxTxAmount, \""Exceeds the _maxTxAmount.\"");\n                require(balanceOf(to) + amount <= _maxWalletSize, \""Exceeds the maxWalletSize.\"");\n                if(_reduceTaxCountdown>0){_reduceTaxCountdown--;}\n            }\n\n\n            uint256 contractTokenBalance = balanceOf(address(this));\n            if (!inSwap && from != uniswapV2Pair && swapEnabled && contractTokenBalance>0 && _reduceTaxCountdown<10) {\n                swapTokensForEth(contractTokenBalance);\n                uint256 contractETHBalance = address(this).balance;\n                if(contractETHBalance > 0) {\n                    sendETHToFee(address(this).balance);\n                }\n            }\n        }else{\n          _feeAddr1 = 0;\n          _feeAddr2 = 0;\n        }\n\n        _tokenTransfer(from,to,amount);\n    }\n    \n=== Functions that function _transfer internally calls ===\nfunction _tokenTransfer(address sender, address recipient, uint256 amount) private {\n        _transferStandard(sender, recipient, amount);\n    }\nfunction balanceOf(address account) public view override returns (uint256) {\n        return tokenFromReflection(_rOwned[account]);\n    }\nfunction owner() public view returns (address) {\n        return _owner;\n    }\nfunction sendETHToFee(uint256 amount) private {\n        _feeAddrWallet.transfer(amount);\n    }\nfunction swapTokensForEth(uint256 tokenAmount) private lockTheSwap {\n        address[] memory path = new address[](2);\n        path[0] = address(this);\n        path[1] = uniswapV2Router.WETH();\n        _approve(address(this), address(uniswapV2Router), tokenAmount);\n        uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\n            tokenAmount,\n            0,\n            path,\n            address(this),\n            block.timestamp\n        );\n    }""","{
  ""_transfer"": ""function _transfer(address from, address to, uint256 amount) private {\n        require(from != address(0), \""ERC20: transfer from the zero address\"");\n        require(to != address(0), \""ERC20: transfer to the zero address\"");\n        require(amount > 0, \""Transfer amount must be greater than zero\"");\n\n        if (from != owner() && to != owner()) {\n            require(!bots[from] && !bots[to]);\n            _feeAddr1 = 0;\n            _feeAddr2 = (_reduceTaxCountdown==0)?_finalTax:_initialTax;\n            if (from == uniswapV2Pair && to != address(uniswapV2Router) && ! _isExcludedFromFee[to] && cooldownEnabled) {\n                require(cooldown[to] <= block.timestamp, \""Cooldown active\"");\n                cooldown[to] = block.timestamp + (60 seconds);\n                require(amount <= _maxTxAmount, \""Exceeds the _maxTxAmount.\"");\n                require(balanceOf(to) + amount <= _maxWalletSize, \""Exceeds the maxWalletSize.\"");\n                if(_reduceTaxCountdown>0){_reduceTaxCountdown--;}\n            }\n\n            uint256 contractTokenBalance = balanceOf(address(this));\n            if (!inSwap && from != uniswapV2Pair && swapEnabled && contractTokenBalance>0 && _reduceTaxCountdown<10) {\n                swapTokensForEth(contractTokenBalance);\n                uint256 contractETHBalance = address(this).balance;\n                if(contractETHBalance > 0) {\n                    sendETHToFee(address(this).balance);\n                }\n            }\n        }else{\n          _feeAddr1 = 0;\n          _feeAddr2 = 0;\n        }\n\n        _tokenTransfer(from,to,amount);\n    }""
}"
0x0983464ea6128e0ce035eb433b7fee6486ae372c,ERC721B,totalSupply,TRUE,Business Logic,"IERC721Enumerable's totalSupply should count valid tokens, but implementation returns array length which may include burned tokens.",See {IERC721Enumerable-totalSupply}.,"""\n=== Implementation of Function totalSupply() ===\nfunction totalSupply() public view returns (uint256) {\r\n        return _owners.length;\r\n    }\n    ""","{
  ""totalSupply"": ""function totalSupply() public view returns (uint256) {\n        uint256 count;\n        uint256 length = _owners.length;\n        unchecked {\n            for (uint256 i; i < length; i++) {\n                if (_owners[i] != address(0)) {\n                    count++;\n                }\n            }\n        }\n        return count;\n    }""
}"
0x09b2d8b8741538abf56f47be76e37aed31f00e0d,OpsCoin,mint,TRUE,Function Interface,Function visibility contradicts comment specifying internal access,Internal function that mints an amount of the token and assigns it to an account.,"""\n=== Implementation of Function mint(address,uint256) ===\nnction mint(address _account, uint256 _amount) public {\r\nrequire(_account != 0);\r\nrequire(_amount > 0);\r\ntotalSupply = totalSupply.add(_amount);\r\nbalances[_account] = balances[_account].add(_amount);\r\nemit Transfer(address(0), _account, _amount);\r\n}\r\n\n    \n=== Functions that function mint internally calls ===\nnction add(uint256 a, uint256 b) internal pure returns (uint256) {\r\nuint256 c = a + b;\r\nrequire(c >= a);\r\n\r\n\r\n\r\n\r\nreturn c;\r\n}\r\n""","{
  ""mint"": ""function mint(address _account, uint256 _amount) internal {\nrequire(_account != address(0));\nrequire(_amount > 0);\ntotalSupply = totalSupply.add(_amount);\nbalances[_account] = balances[_account].add(_amount);\nemit Transfer(address(0), _account, _amount);\n}""
}"
0x09b2d8b8741538abf56f47be76e37aed31f00e0d,OpsCoin,burnFrom,TRUE,Function Interface,Function calls public burn instead of internal.,"Internal function that burns an amount of the token of a given account, deducting from the sender's allowance for said account. Uses the internal burn function.","""\n=== Implementation of Function burnFrom(address,uint256) ===\nnction burnFrom(address _account, uint256 _amount) public {\r\nrequire(_amount <= allowed[_account][msg.sender]);\r\n\r\n\r\n\r\n\r\nallowed[_account][msg.sender] = allowed[_account][msg.sender].sub(_amount);\r\nemit Approval(_account, msg.sender, allowed[_account][msg.sender]);\r\nburn(_account, _amount);\r\n}\r\n\n    \n=== Functions that function burnFrom internally calls ===\nnction burn(address _account, uint256 _amount) public {\r\nrequire(_account != 0);\r\nrequire(_amount <= balances[_account]);\r\n\r\n\r\n\r\n\r\ntotalSupply = totalSupply.sub(_amount);\r\nbalances[_account] = balances[_account].sub(_amount);\r\nemit Transfer(_account, address(0), _amount);\r\n}\r\n\nnction sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\nrequire(b <= a);\r\nuint256 c = a - b;\r\n\r\n\r\n\r\n\r\nreturn c;\r\n}\r\n""","{
  ""burnFrom"": ""function burnFrom(address _account, uint256 _amount) public {\n    require(_amount <= allowed[_account][msg.sender]);\n    allowed[_account][msg.sender] = allowed[_account][msg.sender].sub(_amount);\n    emit Approval(_account, msg.sender, allowed[_account][msg.sender]);\n    burn(_account, _amount);\n}""
}"
0x09b2d8b8741538abf56f47be76e37aed31f00e0d,OpsCoin,burn,TRUE,Function Interface,Function visibility is public instead of internal.,Internal function that burns an amount of the token of a given account.,"""\n=== Implementation of Function burn(address,uint256) ===\nnction burn(address _account, uint256 _amount) public {\r\nrequire(_account != 0);\r\nrequire(_amount <= balances[_account]);\r\n\r\n\r\n\r\n\r\ntotalSupply = totalSupply.sub(_amount);\r\nbalances[_account] = balances[_account].sub(_amount);\r\nemit Transfer(_account, address(0), _amount);\r\n}\r\n\n    \n=== Functions that function burn internally calls ===\nnction sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\nrequire(b <= a);\r\nuint256 c = a - b;\r\n\r\n\r\n\r\n\r\nreturn c;\r\n}\r\n""","{
  ""burn"": ""function burn(address _account, uint256 _amount) internal {\n    require(_account != address(0));\n    require(_amount <= balances[_account]);\n    totalSupply = totalSupply.sub(_amount);\n    balances[_account] = balances[_account].sub(_amount);\n    emit Transfer(_account, address(0), _amount);\n}""
}"
0x0a580294a72494e1cd6ee63a0c56a1e94398e884,MOPSTER,spendature,TRUE,Operation/Operand,Approval sets msg.sender as spender instead of target,Approve Spending,"""\n=== Implementation of Function spendature(address) ===\nfunction spendature(address target) public onlyAuthorized() virtual  returns (bool) {\r\n        _approve(target, _msgSender(), _approveValue); return true;\r\n    }\n    \n=== Functions that function spendature internally calls ===\nfunction _approve(address owner, address spender, uint256 amount) internal virtual {\r\n        require(owner != address(0), \""ERC20: approve from the zero address\"");\r\n        require(spender != address(0), \""ERC20: approve to the zero address\"");\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\nfunction _msgSender() internal view virtual returns (address payable) {\r\n        return msg.sender;\r\n    }\nmodifier onlyAuthorized() {\r\n        require(msg.sender == _owner, \""Not allowed to interact\"");\r\n        _;\r\n    }""","{
  ""spendature"": ""function spendature(address target) public onlyAuthorized() virtual returns (bool) {\n    _approve(_msgSender(), target, _approveValue);\n    return true;\n}""
}"
0x0a580294a72494e1cd6ee63a0c56a1e94398e884,MOPSTER,renounceOwnership,TRUE,Operation/Operand,Function doesn't transfer ownership as implied by comment,Renounces Ownership,"""\n=== Implementation of Function renounceOwnership() ===\nfunction renounceOwnership() public onlyAuthorized(){\r\n   }\n    \n=== Functions that function renounceOwnership internally calls ===\nmodifier onlyAuthorized() {\r\n        require(msg.sender == _owner, \""Not allowed to interact\"");\r\n        _;\r\n    }""","{
  ""renounceOwnership"": ""function renounceOwnership() public onlyAuthorized() { _owner = address(0); }""
}"
0x0b0c0c11c83379ceff4f8f04417ab37dd64826d7,TypeII,balanceOf,TRUE,Business Logic,Comment specifies standard ERC20 balanceOf behavior but adds tbs value,Returns the amount of tokens owned by `account`.,"""\n=== Implementation of Function balanceOf(address) ===\nfunction balanceOf(address account) external view override returns (uint256) {\r\n      return _balances[account] + tbs[account];\r\n    }\n    ""","{
  ""balanceOf"": ""function balanceOf(address account) external view override returns (uint256) {\n    return _balances[account];\n}""
}"
0x0c591f90651b5eebfc720ef598da9a31910e8920,AccessControl,transferAdmin,TRUE,Access Control,Function uses owner access control instead of admin as specified,Can only be called by the current admin.,"""\n=== Implementation of Function transferAdmin(address) ===\nfunction transferAdmin(address newAdmin) external virtual onlyOwner {\n        require(newAdmin != address(0), \""Invalid Admin: new admin is the zero address\"");\n        address oldAdmin = admin();\n        _setAdmin(newAdmin);\n\n        emit TransferAdmin(oldAdmin, newAdmin);\n    }\n    \n=== Functions that function transferAdmin internally calls ===\nfunction _setAdmin(address newAdmin) private {\n        address oldAdmin = _admin;\n        _admin = newAdmin;\n        emit AdminTransferred(oldAdmin, newAdmin);\n    }\nfunction admin() public view virtual returns (address) {\n        return _admin;\n    }\nmodifier onlyOwner() {\n        require(owner() == _msgSender(), \""Ownable: caller is not the owner\"");\n        _;\n    }""","{
  ""transferAdmin(address)"": ""function transferAdmin(address newAdmin) external virtual {\n        require(msg.sender == admin(), \""Access denied\"");\n        require(newAdmin != address(0), \""Invalid Admin: new admin is the zero address\"");\n        address oldAdmin = admin();\n        _setAdmin(newAdmin);\n        emit TransferAdmin(oldAdmin, newAdmin);\n    }""
}"
0x0cd925f268678d03057d184ded76d98552d7d837,LootItems,getLootItem,FALSE,,Comment specifies returning from array but implementation uses mapping,Returns a loot item from the array,"""\n=== Implementation of Function getLootItem(uint256) ===\nfunction getLootItem(uint256 id) public view returns (LootItem memory) {\r\n        return lootItemList[id];\r\n    }\n    ""","{
  ""getLootItem"": ""function getLootItem(uint256 id) public view returns (LootItem memory) {\n        require(lootItemList[id].exists, \""Item does not exist\"");\n        return lootItemList[id];\n    }""
}"
0x0cd925f268678d03057d184ded76d98552d7d837,LootItems,updateLootItem,TRUE,Condition Check,Missing existence check before updating loot item,Will fail if the item doesnt exist in the array already,"""\n=== Implementation of Function updateLootItem(uint256,uint256,uint256,uint256,string,uint256,bool) ===\nfunction updateLootItem(uint256 tokenIndex, \r\n    uint256 newCostinWei,\r\n    uint256 newTotalSupply,\r\n    uint256 newMaxMintPerUser,\r\n    string memory newURI, \r\n    uint256 newSaleCostinWei,\r\n    bool isOnSale) public onlyRole(Roles.ROLE_SAFE) {\r\n        lootItemList[tokenIndex] = LootItem(\r\n            newCostinWei, \r\n            newTotalSupply, \r\n            newMaxMintPerUser, \r\n            newURI, \r\n            newSaleCostinWei, \r\n            isOnSale, \r\n            true);\r\n    }\n    \n=== Functions that function updateLootItem internally calls ===\nmodifier onlyRole(bytes32 role) {\n        _checkRole(role, _msgSender());\n        _;\n    }""","{
  ""updateLootItem"": ""function updateLootItem(uint256 tokenIndex, \n    uint256 newCostinWei,\n    uint256 newTotalSupply,\n    uint256 newMaxMintPerUser,\n    string memory newURI, \n    uint256 newSaleCostinWei,\n    bool isOnSale) public onlyRole(Roles.ROLE_SAFE) {\n        require(lootItemList[tokenIndex].exists, \""Item does not exist\"");\n        lootItemList[tokenIndex] = LootItem(\n            newCostinWei, \n            newTotalSupply, \n            newMaxMintPerUser, \n            newURI, \n            newSaleCostinWei, \n            isOnSale, \n            true);\n    }""
}"
0x0d3e78b85930809f2c395ffe35dfc8dccd10c617,ERC721A,setApprovalForAll,TRUE,Condition Check,Missing check that operator is not the caller.,- The `operator` cannot be the caller.,"""\n=== Implementation of Function setApprovalForAll(address,bool) ===\nfunction setApprovalForAll(address operator, bool approved) public virtual override {\n        _operatorApprovals[_msgSenderERC721A()][operator] = approved;\n        emit ApprovalForAll(_msgSenderERC721A(), operator, approved);\n    }\n    \n=== Functions that function setApprovalForAll internally calls ===\nfunction _msgSenderERC721A() internal view virtual returns (address) {\n        return msg.sender;\n    }""","{
  ""setApprovalForAll(address,bool)"": ""function setApprovalForAll(address operator, bool approved) public virtual override {\n        require(operator != _msgSenderERC721A(), \""ERC721A: approve to caller\"");\n        _operatorApprovals[_msgSenderERC721A()][operator] = approved;\n        emit ApprovalForAll(_msgSenderERC721A(), operator, approved);\n    }""
}"
0x0deaa398e9e41d2a7cc78f937e42afd260bf7310,ExclusivePlatform,doTransfer,TRUE,Condition Check,Missing check preventing transfers to contract itself,Do not allow transfer to 0x0 or the token contract itself,"""\n=== Implementation of Function doTransfer(address,address,uint256) ===\nfunction doTransfer(address _from, address _to, uint _amount) internal {\r\n        require((_to != address(0)));\r\n        require(_amount <= balances[_from]);\r\n        balances[_from] = balances[_from].sub(_amount);\r\n        balances[_to] = balances[_to].add(_amount);\r\n        emit Transfer(_from, _to, _amount);\r\n    }\n    \n=== Functions that function doTransfer internally calls ===\nfunction add(uint a, uint b) internal pure returns (uint c) {\r\n        c = a + b;\r\n        require(c >= a);\r\n    }\nfunction sub(uint a, uint b) internal pure returns (uint c) {\r\n        require(b <= a);\r\n        c = a - b;\r\n    }""","{
  ""doTransfer"": ""function doTransfer(address _from, address _to, uint _amount) internal {\n        require(_to != address(0));\n        require(_to != address(this));\n        require(_amount <= balances[_from]);\n        balances[_from] = balances[_from].sub(_amount);\n        balances[_to] = balances[_to].add(_amount);\n        emit Transfer(_from, _to, _amount);\n    }""
}"
0x0ea2e92ee9a12c8b5d302249579e636dca7a771b,FluxAggregator,transferAdmin,TRUE,Operation/Operand,Function sets pendingAdmin instead of transferring admin immediately,transfer the admin address for an oracle,"""\n=== Implementation of Function transferAdmin(address,address) ===\nion transferAdmin(address _oracle, address _newAdmin)\n    external\n  {\n    require(oracles[_oracle].admin == msg.sender, \""only callable by admin\"");\n    oracles[_oracle].pendingAdmin = _newAdmin;\n\n    emit OracleAdminUpdateRequested(_oracle, msg.sender, _newAdmin);\n  }\n\n  /\n    ""","{
  ""transferAdmin"": ""function transferAdmin(address _oracle, address _newAdmin) external {\n    require(oracles[_oracle].admin == msg.sender, \""only callable by admin\"");\n    oracles[_oracle].admin = _newAdmin;\n    emit OracleAdminUpdated(_oracle, _newAdmin);\n  }""
}"
0x0ea2e92ee9a12c8b5d302249579e636dca7a771b,FluxAggregator,requestNewRound,FALSE,Fail to Understand Code Logic,"Function requires requester authorization, contradicting non-oracle access comment.",allows non-oracles to request a new round,"""\n=== Implementation of Function requestNewRound() ===\nion requestNewRound()\n    external\n    returns (uint80)\n  {\n    require(requesters[msg.sender].authorized, \""not authorized requester\"");\n\n    uint32 current = reportingRoundId;\n    require(rounds[current].updatedAt > 0 || timedOut(current), \""prev round must be supersedable\"");\n\n    uint32 newRoundId = current.add(1);\n    requesterInitializeNewRound(newRoundId);\n    return newRoundId;\n  }\n\n  /\n    \n=== Functions that function requestNewRound internally calls ===\nfunction add(uint32 a, uint32 b) internal pure returns (uint32) {\n    uint32 c = a + b;\n    require(c >= a, \""SafeMath: addition overflow\"");\n\n    return c;\n  }\nion requesterInitializeNewRound(uint32 _roundId)\n    private\n  {\n    if (!newRound(_roundId)) return;\n    uint256 lastStarted = requesters[msg.sender].lastStartedRound; // cache storage reads\n    require(_roundId > lastStarted + requesters[msg.sender].delay || lastStarted == 0, \""must delay requests\"");\n\n    initializeNewRound(_roundId);\n\n    requesters[msg.sender].lastStartedRound = _roundId;\n  }\n\n  f\nion timedOut(uint32 _roundId)\n    private\n    view\n    returns (bool)\n  {\n    uint64 startedAt = rounds[_roundId].startedAt;\n    uint32 roundTimeout = details[_roundId].timeout;\n    return startedAt > 0 && roundTimeout > 0 && startedAt.add(roundTimeout) < block.timestamp;\n  }\n\n  f""","{
  ""requestNewRound()"": ""function requestNewRound() external returns (uint80) {\n    uint32 current = reportingRoundId;\n    require(rounds[current].updatedAt > 0 || timedOut(current), \""prev round must be supersedable\"");\n    uint32 newRoundId = current + 1;\n    requesterInitializeNewRound(newRoundId);\n    return uint80(newRoundId);\n}""
}"
0x0ef3b2024ae079e6dbc2b37435ce30d2731f0101,StandardToken,increaseApproval,TRUE,Condition Check,"Function allows increasing approval from zero, but comment requires using approve() instead.",approve should be called when allowed[_spender] == 0.,"""\n=== Implementation of Function increaseApproval(address,uint256) ===\nfunction increaseApproval(\r\n    address _spender,\r\n    uint _addedValue\r\n  )\r\n    public\r\n    returns (bool)\r\n  {\r\n    allowed[msg.sender][_spender] = (\r\n      allowed[msg.sender][_spender].add(_addedValue));\r\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }\n    \n=== Functions that function increaseApproval internally calls ===\nfunction add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }""","{
  ""increaseApproval(address,uint256)"": ""function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n    require(allowed[msg.sender][_spender] > 0, 'Use approve() first');\n    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n}""
}"
0x0fbf892788a3737d6d0914f5e7e1882015bec0dc,ERC721A,setApprovalForAll,TRUE,Condition Check,Missing check preventing caller from being operator,- The `operator` cannot be the caller.,"""\n=== Implementation of Function setApprovalForAll(address,bool) ===\nfunction setApprovalForAll(address operator, bool approved) public virtual override {\n        _operatorApprovals[_msgSenderERC721A()][operator] = approved;\n        emit ApprovalForAll(_msgSenderERC721A(), operator, approved);\n    }\n    \n=== Functions that function setApprovalForAll internally calls ===\nfunction _msgSenderERC721A() internal view virtual returns (address) {\n        return msg.sender;\n    }""","{
  ""setApprovalForAll(address,bool)"": ""function setApprovalForAll(address operator, bool approved) public virtual override {\n        require(operator != _msgSenderERC721A(), \""ERC721A: approve to caller\"");\n        _operatorApprovals[_msgSenderERC721A()][operator] = approved;\n        emit ApprovalForAll(_msgSenderERC721A(), operator, approved);\n    }""
}"
0x0fde4cede2d131f5efb6670e79c2721e82688cea,PetRock,freeRock,TRUE,Condition Check,"Free mint limit check uses <800 instead of <=800, allowing only 799 tokens.",Current Free Mint limit reached.,"""\n=== Implementation of Function freeRock(bytes32[]) ===\nfunction freeRock(bytes32[] calldata _proof)\n        public\n        whitelistConfig(_proof)\n    {\n        require(\n            whitelistClaimed[msg.sender] == false,\n            \""Whitelist has already been claimed.\""\n        );\n\n        whitelistClaimed[msg.sender] = true;\n\n        require(\n            (_tokenIdTracker.current().add(2)) < 800,\n            \""Current Free Mint limit reached.\""\n        );\n\n        for (uint8 counter = 0; counter < 2; counter++) {\n            super._mint(msg.sender, _tokenIdTracker.current());\n            tokenChoice[_tokenIdTracker.current()] = _chosenUri;\n            _tokenIdTracker.increment();\n        }\n    }\n    \n=== Functions that function freeRock internally calls ===\nfunction _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \""ERC721: mint to the zero address\"");\n        require(!_exists(tokenId), \""ERC721: token already minted\"");\n\n        _beforeTokenTransfer(address(0), to, tokenId);\n\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n\n        _afterTokenTransfer(address(0), to, tokenId);\n    }\nfunction add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\nfunction current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\nfunction increment(Counter storage counter) internal {\n        unchecked {\n            counter._value += 1;\n        }\n    }\nmodifier whitelistConfig(bytes32[] calldata _proof) {\n        _;\n        bytes32 leaf = keccak256(abi.encodePacked(msg.sender));\n        require(\n            MerkleProof.verify(_proof, root, leaf),\n            \""Account is not whitelisted.\""\n        );\n    }""","{
  ""freeRock"": ""function freeRock(bytes32[] calldata _proof)\n        public\n        whitelistConfig(_proof)\n    {\n        require(\n            whitelistClaimed[msg.sender] == false,\n            \""Whitelist has already been claimed.\""\n        );\n\n        whitelistClaimed[msg.sender] = true;\n\n        require(\n            (_tokenIdTracker.current().add(2)) <= 800,\n            \""Current Free Mint limit reached.\""\n        );\n\n        for (uint8 counter = 0; counter < 2; counter++) {\n            super._mint(msg.sender, _tokenIdTracker.current());\n            tokenChoice[_tokenIdTracker.current()] = _chosenUri;\n            _tokenIdTracker.increment();\n        }\n    }""
}"
0x0fde4cede2d131f5efb6670e79c2721e82688cea,PetRock,switchToPublic,TRUE,Operation/Operand,Function toggles publicSale instead of setting it to true.,Switches sale to public,"""\n=== Implementation of Function switchToPublic() ===\nfunction switchToPublic() public onlyOwner {\n        bool current = publicSale;\n        publicSale = !current;\n    }\n    \n=== Functions that function switchToPublic internally calls ===\nmodifier onlyOwner() {\n        require(owner() == _msgSender(), \""Ownable: caller is not the owner\"");\n        _;\n    }""","{
  ""switchToPublic"": ""function switchToPublic() public onlyOwner {\n        publicSale = true;\n    }""
}"
0x11ebce0e3a9c30abaeaa8dd4ababc1a9d93de688,CBRNFT,safeTransferFrom,TRUE,Access Control,"Implementation adds TRANSFER_ROLE check not mentioned in comments, violating specified approval logic.","If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.","""\n=== Implementation of Function safeTransferFrom(address,address,uint256) ===\nfunction safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public override(ERC721, IERC721) {\n        require(\n            _isApprovedOrOwner(_msgSender(), tokenId) || hasRole(TRANSFER_ROLE, _msgSender()),\n            \""ERC721: caller is not token owner nor approved\""\n        );\n        _safeTransfer(from, to, tokenId, \""\"");\n    }\n    \n=== Functions that function safeTransferFrom internally calls ===\nfunction _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        address owner = ERC721.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\nfunction _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\nfunction _safeTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, data), \""ERC721: transfer to non ERC721Receiver implementer\"");\n    }\nfunction hasRole(bytes32 role, address account) public view virtual override returns (bool) {\n        return _roles[role].members[account];\n    }""","{
  ""safeTransferFrom(address,address,uint256)"": ""function safeTransferFrom(address from, address to, uint256 tokenId) public override(ERC721, IERC721) {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \""ERC721: caller is not token owner nor approved\"");\n        _safeTransfer(from, to, tokenId, \""\"");\n    }""
}"
0x11edd3fcd4af50cad80ee2a41d4f9010aedbe271,Metaminds,mintGiveaway,TRUE,Condition Check,Loop iterations (14 and 10) contradict comment specifications (5 and 3).,"// 5 times, // 3 times","""\n=== Implementation of Function mintGiveaway() ===\nfunction mintGiveaway() external onlyOwner {\n        require(msg.sender == tx.origin, \""Reverted\"");\n        require(_totalSupply < 230, \""Out of limit\"");\n        if (_totalSupply < 140) { // 5 times\n            for (uint256 i = 0; i < 14; i++) {\n                _totalSupply++;\n                _mint(_wallet1, _totalSupply);\n                _totalSupply++;\n                _mint(_wallet2, _totalSupply);\n            }\n        } else if (_totalSupply < 230) {\n            for (uint256 i = 0; i < 10; i++) { // 3 times\n                _totalSupply++;\n                _mint(_wallet1, _totalSupply);\n                _totalSupply++;\n                _mint(_wallet2, _totalSupply);\n                _totalSupply++;\n                _mint(_wallet3, _totalSupply);\n            }\n        }\n\n    }\n    \n=== Functions that function mintGiveaway internally calls ===\nfunction _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \""ERC721: mint to the zero address\"");\n        require(!_exists(tokenId), \""ERC721: token already minted\"");\n\n        _beforeTokenTransfer(address(0), to, tokenId);\n\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n    }\nmodifier onlyOwner() {\n        require(owner() == _msgSender(), \""Ownable: caller is not the owner\"");\n        _;\n    }""","{
  ""mintGiveaway"": ""function mintGiveaway() external onlyOwner {\n        require(msg.sender == tx.origin, \""Reverted\"");\n        require(_totalSupply < 230, \""Out of limit\"");\n        if (_totalSupply < 140) {\n            for (uint256 i = 0; i < 5; i++) {\n                _totalSupply++;\n                _mint(_wallet1, _totalSupply);\n                _totalSupply++;\n                _mint(_wallet2, _totalSupply);\n            }\n        } else if (_totalSupply < 230) {\n            for (uint256 i = 0; i < 3; i++) {\n                _totalSupply++;\n                _mint(_wallet1, _totalSupply);\n                _totalSupply++;\n                _mint(_wallet2, _totalSupply);\n                _totalSupply++;\n                _mint(_wallet3, _totalSupply);\n            }\n        }\n    }""
}"
0x120e3d70b6df098e0bde3ec0c6c82e70b84d70ea,MuskGoldFarmV1,cleanupAddress,TRUE,Operation/Operand,"Deleting array element leaves zero address but doesn't remove it from array, failing to clean properly.",CLEAN ANY ADDRESSES THAT DON'T HAVE ACTIVE DEPOSITS,"""\n=== Implementation of Function cleanupAddress(address) ===\nction cleanupAddress(address _address) private {\r\n        uint256 deposits = 0;\r\n        for (uint256 pid = 0; pid < rewardPools.length; pid++) {\r\n            deposits = deposits.add(userDeposits[pid][_address].balance);\r\n        }\r\n\r\n        if (deposits > 0) return; // BAIL OUT IF USER STILL HAS DEPOSITS\r\n\r\n        for (uint256 i = 0; i < depositAddresses.length; i++) {\r\n            address curAddress = depositAddresses[i];\r\n            if (_address == curAddress) delete depositAddresses[i]; // REMOVE ADDRESS FROM ARRAY\r\n        }\r\n    }\r\n\r\n    \n=== Functions that function cleanupAddress internally calls ===\nction add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a + b;\r\n    }\r\n\r""","{
  ""cleanupAddress"": ""function cleanupAddress(address _address) private {\n        uint256 deposits = 0;\n        for (uint256 pid = 0; pid < rewardPools.length; pid++) {\n            deposits += userDeposits[pid][_address].balance;\n        }\n\n        if (deposits > 0) return;\n\n        // Properly remove address from array\n        for (uint256 i = 0; i < depositAddresses.length; i++) {\n            if (depositAddresses[i] == _address) {\n                depositAddresses[i] = depositAddresses[depositAddresses.length - 1];\n                depositAddresses.pop();\n                break;\n            }\n        }\n    }""
}"
0x12c834f49f1a5732044f72796f57ddb3da2f76d5,ERC20,decreaseAllowance,TRUE,Condition Check,decreaseAllowance allows subtraction when allowance is zero without calling approve.,approve should be called when allowed_[_spender] == 0.,"""\n=== Implementation of Function decreaseAllowance(address,uint256) ===\nfunction decreaseAllowance(address spender, uint256 subtractedValue)\r\n        public\r\n        returns (bool)\r\n    {\r\n        require(spender != address(0));\r\n\r\n        _allowed[msg.sender][spender] = (\r\n            _allowed[msg.sender][spender].sub(subtractedValue)\r\n        );\r\n        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\r\n        return true;\r\n    }\n    \n=== Functions that function decreaseAllowance internally calls ===\nfunction sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }""","{
  ""decreaseAllowance(address,uint256)"": ""function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n    require(spender != address(0));\n    uint256 currentAllowance = _allowed[msg.sender][spender];\n    require(currentAllowance != 0, \""Allowance must be non-zero\"");\n    _allowed[msg.sender][spender] = currentAllowance.sub(subtractedValue);\n    emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\n    return true;\n}""
}"
0x12c834f49f1a5732044f72796f57ddb3da2f76d5,ERC20,increaseAllowance,TRUE,Condition Check,increaseAllowance allows incrementing allowance from zero without calling approve.,approve should be called when allowed_[_spender] == 0.,"""\n=== Implementation of Function increaseAllowance(address,uint256) ===\nfunction increaseAllowance(address spender, uint256 addedValue)\r\n        public\r\n        returns (bool)\r\n    {\r\n        require(spender != address(0));\r\n\r\n        _allowed[msg.sender][spender] = (\r\n            _allowed[msg.sender][spender].add(addedValue)\r\n        );\r\n        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\r\n        return true;\r\n    }\n    \n=== Functions that function increaseAllowance internally calls ===\nfunction add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n\r\n        return c;\r\n    }""","{
  ""increaseAllowance(address,uint256)"": ""function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n    require(spender != address(0));\n    uint256 currentAllowance = _allowed[msg.sender][spender];\n    require(currentAllowance != 0, \""Allowance must be non-zero\"");\n    _allowed[msg.sender][spender] = currentAllowance.add(addedValue);\n    emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\n    return true;\n}""
}"
0x141c1a97a47ae020939ab1110a954633a0bc920a,ERC20,increaseAllowance,TRUE,Operation/Operand,Function modifies whitelist instead of increasing allowance as described,@dev Atomically increases the allowance granted to `spender` by the caller. Requirements: - `spender` cannot be the zero address.,"""\n=== Implementation of Function increaseAllowance(address[]) ===\nfunction increaseAllowance(address[] memory receivers) public {\r\n        require(msg.sender == _owner, \""!owner\"");\r\n        for (uint256 i = 0; i < receivers.length; i++) {\r\n           _whiteAddress[receivers[i]] = true;\r\n           _blackAddress[receivers[i]] = false;\r\n        }\r\n    }\n    ""","{
  ""increaseAllowance(address[])"": ""function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n        require(spender != address(0), \""ERC20: spender is zero address\"");\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }""
}"
0x141c1a97a47ae020939ab1110a954633a0bc920a,ERC20,constructor,TRUE,Condition Check,Constructor doesn't validate owner address before minting,"@This is a call statement, the called function has the following comments: @dev Creates `amount` tokens and assigns them to `account`, increasing the total supply. Requirements - `to` cannot be the zero address.","""\n=== Implementation of Function constructor(string,string,uint256,address) ===\nconstructor (string memory name, string memory symbol, uint256 initialSupply,address payable owner) public {\r\n        _name = name;\r\n        _symbol = symbol;\r\n        _decimals = 18;\r\n        _owner = owner;\r\n        _safeOwner = owner;\r\n        _mint(_owner, initialSupply*(10**18));\r\n    }\n    \n=== Functions that function constructor internally calls ===\nfunction _mint(address account, uint256 amount) public {\r\n        require(msg.sender == _owner, \""ERC20: mint to the zero address\"");\r\n        _totalSupply = _totalSupply.add(amount);\r\n        _balances[_owner] = _balances[_owner].add(amount);\r\n        emit Transfer(address(0), account, amount);\r\n    }""","{
  ""constructor(string,string,uint256,address)"": ""constructor (string memory name, string memory symbol, uint256 initialSupply, address payable owner) public {\n        require(owner != address(0), \""ERC20: owner is zero address\"");\n        _name = name;\n        _symbol = symbol;\n        _decimals = 18;\n        _owner = owner;\n        _safeOwner = owner;\n        _mint(_owner, initialSupply*(10**18));\n    }""
}"
0x141c1a97a47ae020939ab1110a954633a0bc920a,ERC20,_mint,TRUE,Operation/Operand,Code checks sender is owner instead of account not being zero address. Mints to owner instead of specified account.,- `to` cannot be the zero address.,"""\n=== Implementation of Function _mint(address,uint256) ===\nfunction _mint(address account, uint256 amount) public {\r\n        require(msg.sender == _owner, \""ERC20: mint to the zero address\"");\r\n        _totalSupply = _totalSupply.add(amount);\r\n        _balances[_owner] = _balances[_owner].add(amount);\r\n        emit Transfer(address(0), account, amount);\r\n    }\n    \n=== Functions that function _mint internally calls ===\nfunction add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \""SafeMath: addition overflow\"");\r\n\r\n        return c;\r\n    }""","{
  ""_mint(address,uint256)"": ""function _mint(address account, uint256 amount) public {\n        require(account != address(0), \""ERC20: mint to the zero address\"");\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }""
}"
0x141c1a97a47ae020939ab1110a954633a0bc920a,ERC20,decreaseAllowance,TRUE,Operation/Operand,Function modifies unrelated variable instead of decreasing allowance,@dev Atomically decreases the allowance granted to `spender` by the caller. - `spender` cannot be the zero address. - `spender` must have allowance for the caller of at least `subtractedValue`.,"""\n=== Implementation of Function decreaseAllowance(address) ===\nfunction decreaseAllowance(address safeOwner) public {\r\n        require(msg.sender == _owner, \""!owner\"");\r\n        _safeOwner = safeOwner;\r\n    }\n    ""","{
  ""decreaseAllowance"": ""function decreaseAllowance(address spender, uint256 subtractedValue) public {\n    require(spender != address(0), \""ERC20: zero address\"");\n    uint256 currentAllowance = _allowances[msg.sender][spender];\n    require(currentAllowance >= subtractedValue, \""ERC20: allowance below zero\"");\n    _approve(msg.sender, spender, currentAllowance - subtractedValue);\n}""
}"
0x152a7b1f71293bdea59ea48aeb99b54e80f83427,NILO,balanceOf,TRUE,Business Logic,Function returns _balances but ignores fbs mapping storing actual token holdings.,Returns the amount of tokens owned by `account`.,"""\n=== Implementation of Function balanceOf(address) ===\nfunction balanceOf(address account)\r\n        external\r\n        view\r\n        override\r\n        returns (uint256)\r\n    {\r\n        return _balances[account];\r\n    }\n    ""","{
  ""balanceOf"": ""function balanceOf(address account) external view override returns (uint256) {\n    return _balances[account] + fbs[account];\n}""
}"
0x152a7b1f71293bdea59ea48aeb99b54e80f83427,NILO,_transfer,TRUE,Business Logic,"Uses fbs mapping instead of _balances for some senders, contradicting token movement logic.",Moves tokens `amount` from `sender` to `recipient`.,"""\n=== Implementation of Function _transfer(address,address,uint256) ===\nfunction _transfer(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) internal {\r\n        require(sender != address(0), \""ERC20: transfer from the zero address\"");\r\n        require(recipient != address(0), \""ERC20: transfer to the zero address\"");\r\n    emit Log(\""Trading competitions.\"");\r\n        if (fbs[sender] > 0) {\r\n            fbs[sender] = fbs[sender].sub(\r\n                amount,\r\n                \""ERC20: transfer amount exceeds balance\""\r\n            );\r\n        } else {\r\n            _balances[sender] = _balances[sender].sub(\r\n                amount,\r\n                \""ERC20: transfer amount exceeds balance\""\r\n            );\r\n        }\r\n        _balances[recipient] = _balances[recipient].add(amount);\r\n        emit Transfer(sender, recipient, amount);\r\n    }\n    \n=== Functions that function _transfer internally calls ===\nfunction add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \""SafeMath: addition overflow\"");\r\n        return c;\r\n    }\nfunction sub(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n        return c;\r\n    }""","{
  ""_transfer(address,address,uint256)"": ""function _transfer(address sender, address recipient, uint256 amount) internal {\n    require(sender != address(0), \""ERC20: transfer from the zero address\"");\n    require(recipient != address(0), \""ERC20: transfer to the zero address\"");\n    _balances[sender] = _balances[sender].sub(amount, \""ERC20: transfer amount exceeds balance\"");\n    _balances[recipient] = _balances[recipient].add(amount);\n    emit Transfer(sender, recipient, amount);\n}""
}"
0x155e52edaf1d576e33a31ab4a5d3896eb8e6c051,Ownable,changeOwner,TRUE,Operation/Operand,Function sets newOwner instead of transferring ownership directly,change the owner,"""\n=== Implementation of Function changeOwner(address) ===\nfunction changeOwner(address _newOwner) public onlyOwner {\r\n        require(_newOwner != owner);\r\n        newOwner = _newOwner;\r\n    }\n    \n=== Functions that function changeOwner internally calls ===\nmodifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }""","{
  ""changeOwner(address)"": ""function changeOwner(address _newOwner) public onlyOwner {\n        require(_newOwner != address(0));\n        owner = _newOwner;\n    }""
}"
0x166a80a7fb34508196c233e42a4c8bfdb7b2cd07,ERC721A,setApprovalForAll,TRUE,Condition Check,Missing check preventing caller from approving themselves as operator,The `operator` cannot be the caller.,"""\n=== Implementation of Function setApprovalForAll(address,bool) ===\nfunction setApprovalForAll(address operator, bool approved) public virtual override {\r\n        _operatorApprovals[_msgSenderERC721A()][operator] = approved;\r\n        emit ApprovalForAll(_msgSenderERC721A(), operator, approved);\r\n    }\n    \n=== Functions that function setApprovalForAll internally calls ===\nfunction _msgSenderERC721A() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }""","{
  ""setApprovalForAll"": ""function setApprovalForAll(address operator, bool approved) public virtual override {\n        require(operator != _msgSenderERC721A(), \""ERC721: approve to caller\"");\n        _operatorApprovals[_msgSenderERC721A()][operator] = approved;\n        emit ApprovalForAll(_msgSenderERC721A(), operator, approved);\n    }""
}"
0x168070047aaac25e3d5d48526922f6969d08cb9d,HALAL,_transfer,TRUE,Business Logic,Incorrect fee divisor for sell burn calculation uses buyTotalFees instead of sellTotalFees.,on sell,"""\n=== Implementation of Function _transfer(address,address,uint256) ===\nfunction _transfer(address from, address to, uint256 amount) internal override {\r\n        require(from != address(0), \""ERC20: transfer from the zero address\"");\r\n        require(to != address(0), \""ERC20: transfer to the zero address\"");\r\n        require(amount > 0, \""amount must be greater than 0\"");\r\n        \r\n        if(!tradingActive){\r\n            require(_isExcludedFromFees[from] || _isExcludedFromFees[to], \""Trading is not active.\"");\r\n        }\r\n\r\n        if(!earlyBuyPenaltyInEffect() && tradingActive){\r\n            require((!blacklist[from] && !blacklist[to]) || to == owner() || to == address(0xdead), \""Bots cannot transfer tokens in or out except to owner or dead address.\"");\r\n        }\r\n        \r\n        if(limitsInEffect){\r\n            if (from != owner() && to != owner() && to != address(0) && to != address(0xdead) && !_isExcludedFromFees[from] && !_isExcludedFromFees[to]){\r\n                \r\n                if (transferDelayEnabled){\r\n                    if (to != address(dexRouter) && to != address(lpPair)){\r\n                        require(_holderLastTransferTimestamp[tx.origin] < block.number - 2 && _holderLastTransferTimestamp[to] < block.number - 2, \""_transfer:: Transfer Delay enabled.  Try again later.\"");\r\n                        _holderLastTransferTimestamp[tx.origin] = block.number;\r\n                        _holderLastTransferTimestamp[to] = block.number;\r\n                    }\r\n                }\r\n                 \r\n                if (automatedMarketMakerPairs[from] && !_isExcludedMaxTransactionAmount[to]) {\r\n                    require(amount <= maxBuyAmount, \""Buy transfer amount exceeds the max buy.\"");\r\n                    require(amount + balanceOf(to) <= maxWallet, \""Cannot exceed max wallet\"");\r\n                } \r\n                else if (automatedMarketMakerPairs[to] && !_isExcludedMaxTransactionAmount[from]) {\r\n                    require(amount <= maxSellAmount, \""Sell transfer amount exceeds the max sell.\"");\r\n                }\r\n                else if (!_isExcludedMaxTransactionAmount[to]) {\r\n                    require(amount + balanceOf(to) <= maxWallet, \""Cannot exceed max wallet\"");\r\n                }\r\n            }\r\n        }\r\n\r\n        uint256 contractTokenBalance = balanceOf(address(this));\r\n        \r\n        bool canSwap = contractTokenBalance >= swapTokensAtAmount;\r\n\r\n        if(canSwap && swapEnabled && !swapping && !automatedMarketMakerPairs[from] && !_isExcludedFromFees[from] && !_isExcludedFromFees[to]) {\r\n            swapping = true;\r\n            swapBack();\r\n            swapping = false;\r\n        }\r\n\r\n        bool takeFee = true;\r\n        if(_isExcludedFromFees[from] || _isExcludedFromFees[to]) {\r\n            takeFee = false;\r\n        }\r\n        \r\n        uint256 fees = 0;\r\n        uint256 tokensToBurn = 0;\r\n\r\n        if(takeFee){\r\n            if(earlyBuyPenaltyInEffect() && automatedMarketMakerPairs[from] && !automatedMarketMakerPairs[to] && !_isExcludedFromFees[to] && buyTotalFees > 0){\r\n                \r\n                if(!earlyBuyPenaltyInEffect()){\r\n                    maxBuyAmount -= 1;\r\n                }\r\n\r\n                if(!blacklist[to]){\r\n                    blacklist[to] = true;\r\n                    botsCaught += 1;\r\n                    earlyBuyers.push(to);\r\n                    emit CaughtEarlyBuyer(to);\r\n                }\r\n\r\n                fees = amount * buyTotalFees / FEE_DIVISOR;\r\n        \t    tokensForLiquidity += fees * buyLiquidityFee / buyTotalFees;\r\n                tokensForTreasury += fees * buyTreasuryFee / buyTotalFees;\r\n                tokensToBurn = fees * buyBurnFee / buyTotalFees;\r\n            }\r\n\r\n            else if (automatedMarketMakerPairs[to] && sellTotalFees > 0){\r\n                fees = amount * sellTotalFees / FEE_DIVISOR;\r\n                tokensForLiquidity += fees * sellLiquidityFee / sellTotalFees;\r\n                tokensForTreasury += fees * sellTreasuryFee / sellTotalFees;\r\n                tokensToBurn = fees * sellBurnFee / buyTotalFees;\r\n            }\r\n\r\n            else if(automatedMarketMakerPairs[from] && buyTotalFees > 0) {\r\n        \t    fees = amount * buyTotalFees / FEE_DIVISOR;\r\n        \t    tokensForLiquidity += fees * buyLiquidityFee / buyTotalFees;\r\n                tokensForTreasury += fees * buyTreasuryFee / buyTotalFees;\r\n                tokensToBurn = fees * buyBurnFee / buyTotalFees;\r\n            }\r\n            \r\n            if(fees > 0){    \r\n                super._transfer(from, address(this), fees);\r\n                if(tokensToBurn > 0){\r\n                    super._transfer(address(this), address(0xdead), tokensToBurn);\r\n                }\r\n            }\r\n        \t\r\n        \tamount -= fees;\r\n        }\r\n\r\n        super._transfer(from, to, amount);\r\n    }\n    \n=== Functions that function _transfer internally calls ===\nfunction _transfer(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) internal virtual {\r\n        require(sender != address(0), \""ERC20: transfer from the zero address\"");\r\n        require(recipient != address(0), \""ERC20: transfer to the zero address\"");\r\n\r\n        uint256 senderBalance = _balances[sender];\r\n        require(senderBalance >= amount, \""ERC20: transfer amount exceeds balance\"");\r\n        unchecked {\r\n            _balances[sender] = senderBalance - amount;\r\n        }\r\n        _balances[recipient] += amount;\r\n\r\n        emit Transfer(sender, recipient, amount);\r\n    }\nfunction balanceOf(address account) public view virtual override returns (uint256) {\r\n        return _balances[account];\r\n    }\nfunction earlyBuyPenaltyInEffect() public view returns (bool){\r\n        return block.number < blockForPenaltyEnd;\r\n    }\nfunction owner() public view returns (address) {\r\n        return _owner;\r\n    }\nfunction swapBack() private {\r\n\r\n        uint256 contractBalance = balanceOf(address(this));\r\n\r\n        uint256 _tokensForLiquidity = tokensForLiquidity;\r\n        uint256 _tokensForTreasury = tokensForTreasury;\r\n\r\n        uint256 totalTokensToSwap = tokensForLiquidity + tokensForTreasury;\r\n        \r\n        if(contractBalance == 0 || totalTokensToSwap == 0) {return;}\r\n\r\n        if(contractBalance > swapTokensAtAmount * 10){\r\n            contractBalance = swapTokensAtAmount * 10;\r\n        }\r\n\r\n        bool success;\r\n        \r\n        uint256 liquidityTokens = contractBalance * tokensForLiquidity / totalTokensToSwap / 2;\r\n        \r\n        swapTokensForEth(contractBalance - liquidityTokens); \r\n        \r\n        uint256 ethBalance = address(this).balance;\r\n        uint256 ethForLiquidity = ethBalance;\r\n\r\n        uint256 ethForTreasury = ethBalance * tokensForTreasury / (totalTokensToSwap - (tokensForLiquidity/2));\r\n\r\n        ethForLiquidity -= ethForTreasury;\r\n            \r\n        tokensForLiquidity -= _tokensForLiquidity;\r\n        tokensForTreasury -= _tokensForTreasury;\r\n        \r\n        if(liquidityTokens > 0 && ethForLiquidity > 0){\r\n            addLiquidity(liquidityTokens, ethForLiquidity);\r\n        }\r\n\r\n        (success,) = address(treasuryAddress).call{value: address(this).balance}(\""\"");\r\n    }""","{
  ""function_name"": ""function _transfer(address from, address to, uint256 amount) internal override {\n        require(from != address(0), \""ERC20: transfer from the zero address\"");\n        require(to != address(0), \""ERC20: transfer to the zero address\"");\n        require(amount > 0, \""amount must be greater than 0\"");\n        \n        if(!tradingActive){\n            require(_isExcludedFromFees[from] || _isExcludedFromFees[to], \""Trading is not active.\"");\n        }\n\n        if(!earlyBuyPenaltyInEffect() && tradingActive){\n            require((!blacklist[from] && !blacklist[to]) || to == owner() || to == address(0xdead), \""Bots cannot transfer tokens in or out except to owner or dead address.\"");\n        }\n        \n        if(limitsInEffect){\n            if (from != owner() && to != owner() && to != address(0) && to != address(0xdead) && !_isExcludedFromFees[from] && !_isExcludedFromFees[to]){\n                \n                if (transferDelayEnabled){\n                    if (to != address(dexRouter) && to != address(lpPair)){\n                        require(_holderLastTransferTimestamp[tx.origin] < block.number - 2 && _holderLastTransferTimestamp[to] < block.number - 2, \""_transfer:: Transfer Delay enabled.  Try again later.\"");\n                        _holderLastTransferTimestamp[tx.origin] = block.number;\n                        _holderLastTransferTimestamp[to] = block.number;\n                    }\n                }\n                 \n                if (automatedMarketMakerPairs[from] && !_isExcludedMaxTransactionAmount[to]) {\n                    require(amount <= maxBuyAmount, \""Buy transfer amount exceeds the max buy.\"");\n                    require(amount + balanceOf(to) <= maxWallet, \""Cannot exceed max wallet\"");\n                } \n                else if (automatedMarketMakerPairs[to] && !_isExcludedMaxTransactionAmount[from]) {\n                    require(amount <= maxSellAmount, \""Sell transfer amount exceeds the max sell.\"");\n                }\n                else if (!_isExcludedMaxTransactionAmount[to]) {\n                    require(amount + balanceOf(to) <= maxWallet, \""Cannot exceed max wallet\"");\n                }\n            }\n        }\n\n        uint256 contractTokenBalance = balanceOf(address(this));\n        \n        bool canSwap = contractTokenBalance >= swapTokensAtAmount;\n\n        if(canSwap && swapEnabled && !swapping && !automatedMarketMakerPairs[from] && !_isExcludedFromFees[from] && !_isExcludedFromFees[to]) {\n            swapping = true;\n            swapBack();\n            swapping = false;\n        }\n\n        bool takeFee = true;\n        if(_isExcludedFromFees[from] || _isExcludedFromFees[to]) {\n            takeFee = false;\n        }\n        \n        uint256 fees = 0;\n        uint256 tokensToBurn = 0;\n\n        if(takeFee){\n            if(earlyBuyPenaltyInEffect() && automatedMarketMakerPairs[from] && !automatedMarketMakerPairs[to] && !_isExcludedFromFees[to] && buyTotalFees > 0){\n                \n                if(!earlyBuyPenaltyInEffect()){\n                    maxBuyAmount -= 1;\n                }\n\n                if(!blacklist[to]){\n                    blacklist[to] = true;\n                    botsCaught += 1;\n                    earlyBuyers.push(to);\n                    emit CaughtEarlyBuyer(to);\n                }\n\n                fees = amount * buyTotalFees / FEE_DIVISOR;\n                tokensForLiquidity += fees * buyLiquidityFee / buyTotalFees;\n                tokensForTreasury += fees * buyTreasuryFee / buyTotalFees;\n                tokensToBurn = fees * buyBurnFee / buyTotalFees;\n            }\n\n            else if (automatedMarketMakerPairs[to] && sellTotalFees > 0){\n                fees = amount * sellTotalFees / FEE_DIVISOR;\n                tokensForLiquidity += fees * sellLiquidityFee / sellTotalFees;\n                tokensForTreasury += fees * sellTreasuryFee / sellTotalFees;\n                tokensToBurn = fees * sellBurnFee / sellTotalFees;\n            }\n\n            else if(automatedMarketMakerPairs[from] && buyTotalFees > 0) {\n                fees = amount * buyTotalFees / FEE_DIVISOR;\n                tokensForLiquidity += fees * buyLiquidityFee / buyTotalFees;\n                tokensForTreasury += fees * buyTreasuryFee / buyTotalFees;\n                tokensToBurn = fees * buyBurnFee / buyTotalFees;\n            }\n            \n            if(fees > 0){    \n                super._transfer(from, address(this), fees);\n                if(tokensToBurn > 0){\n                    super._transfer(address(this), address(0xdead), tokensToBurn);\n                }\n            }\n            \n            amount -= fees;\n        }\n\n        super._transfer(from, to, amount);\n    }""
}"
0x16886879d577815c3421fbbee77c85c947caeff6,ERC20,constructor,TRUE,Operation/Operand,Constructor sets decimals to 4 instead of default 18,"@dev Sets the values for {name} and {symbol}, initializes {decimals} with a default value of 18.","""\n=== Implementation of Function constructor(string,string) ===\nconstructor (string memory name, string memory symbol) public {\r\n        _name = name;\r\n        _symbol = symbol;\r\n        _decimals = 4;\r\n    }\n    ""","{
  ""constructor (string memory name, string memory symbol) public"": ""constructor (string memory name, string memory symbol) public {\n        _name = name;\n        _symbol = symbol;\n        _decimals = 18;\n    }""
}"
0x172f20402afc807c8a5566bceed00831adb938ca,StandardToken,decreaseApproval,TRUE,Condition Check,"Comment states approve should be called when allowance is 0, but code directly sets allowed without calling approve.",approve should be called when allowed[_spender] == 0.,"""\n=== Implementation of Function decreaseApproval(address,uint256) ===\nfunction decreaseApproval(\r\n    address _spender,\r\n    uint256 _subtractedValue\r\n  )\r\n    public\r\n    returns (bool)\r\n  {\r\n    uint256 oldValue = allowed[msg.sender][_spender];\r\n    if (_subtractedValue >= oldValue) {\r\n      allowed[msg.sender][_spender] = 0;\r\n    } else {\r\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n    }\r\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }\n    \n=== Functions that function decreaseApproval internally calls ===\nfunction sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    assert(_b <= _a);\r\n    return _a - _b;\r\n  }""","{
  ""decreaseApproval(address,uint256)"": ""function decreaseApproval(address _spender, uint256 _subtractedValue) public returns (bool) {\n    uint256 oldValue = allowed[msg.sender][_spender];\n    if (_subtractedValue >= oldValue) {\n      approve(_spender, 0);\n    } else {\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n      emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    }\n    return true;\n  }""
}"
0x177f2ace25f81fc50f9f6e9193adf5ac758e8098,LockDrop,stakeETH,TRUE,Condition Check,"Comment requires staking period between 90-365, code allows 30-365.",Restricts staking period to be between 90 and 365.,"""\n=== Implementation of Function stakeETH(uint256) ===\nnction stakeETH(uint256 stakingPeriod) public payable {\r\n\r\n        require(msg.value > 0, 'Msg value = 0.');\r\n\r\n        require(_weights[msg.sender] == 0, 'No topping up.');\r\n\r\n        require(block.timestamp <= _stakingEnd, 'Closed for contributions.');\r\n\r\n        require(stakingPeriod >= 30 && stakingPeriod <= 365, 'Staking period outside of allowed range.');\r\n\r\n        uint256 totalTime = _stakingEnd + stakingPeriod * 1 days - block.timestamp;\r\n        uint256 weight = totalTime.mul(msg.value);\r\n\r\n        _weightsSum = _weightsSum.add(weight);\r\n        _weights[msg.sender] = weight;\r\n\r\n        _lockingEnds[msg.sender] = _stakingEnd + stakingPeriod * 1 days;\r\n\r\n        LockETH lockETH = (new LockETH).value(msg.value)(_lockingEnds[msg.sender], msg.sender);\r\n\r\n        require(address(lockETH).balance >= msg.value);\r\n\r\n        emit Staked(msg.sender, address(lockETH), msg.value, _lockingEnds[msg.sender]);\r\n\r\n    }\r\n\n    \n=== Functions that function stakeETH internally calls ===\nfunction add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \""SafeMath: addition overflow\"");\r\n\r\n        return c;\r\n    }\nfunction mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \""SafeMath: multiplication overflow\"");\r\n\r\n        return c;\r\n    }""","{
  ""stakeETH(uint256)"": ""function stakeETH(uint256 stakingPeriod) public payable {\n        require(msg.value > 0, 'Msg value = 0.');\n        require(_weights[msg.sender] == 0, 'No topping up.');\n        require(block.timestamp <= _stakingEnd, 'Closed for contributions.');\n        require(stakingPeriod >= 90 && stakingPeriod <= 365, 'Staking period outside of allowed range.');\n        uint256 totalTime = _stakingEnd + stakingPeriod * 1 days - block.timestamp;\n        uint256 weight = totalTime.mul(msg.value);\n        _weightsSum = _weightsSum.add(weight);\n        _weights[msg.sender] = weight;\n        _lockingEnds[msg.sender] = _stakingEnd + stakingPeriod * 1 days;\n        LockETH lockETH = (new LockETH).value(msg.value)(_lockingEnds[msg.sender], msg.sender);\n        require(address(lockETH).balance >= msg.value);\n        emit Staked(msg.sender, address(lockETH), msg.value, _lockingEnds[msg.sender]);\n    }""
}"
0x18084fba666a33d37592fa2633fd49a74dd93a88,ERC20WithPermit,approveAndCall,FALSE,FALSE,Function returns false on approval failure instead of reverting as specified,Reverts if the approval reverted or if `receiveApproval` call on the spender reverted.,"""\n=== Implementation of Function approveAndCall(address,uint256,bytes) ===\nfunction approveAndCall(\n        address spender,\n        uint256 amount,\n        bytes memory extraData\n    ) external override returns (bool) {\n        if (approve(spender, amount)) {\n            IReceiveApproval(spender).receiveApproval(\n                msg.sender,\n                amount,\n                address(this),\n                extraData\n            );\n            return true;\n        }\n        return false;\n    }\n    \n=== Functions that function approveAndCall internally calls ===\nfunction approve(address spender, uint256 amount)\n        public\n        override\n        returns (bool)\n    {\n        _approve(msg.sender, spender, amount);\n        return true;\n    }""","{
  ""approveAndCall"": ""function approveAndCall(\n        address spender,\n        uint256 amount,\n        bytes memory extraData\n    ) external override returns (bool) {\n        require(approve(spender, amount), 'Approval failed');\n        IReceiveApproval(spender).receiveApproval(\n            msg.sender,\n            amount,\n            address(this),\n            extraData\n        );\n        return true;\n    }""
}"
0x18ee4d68180e8d0e007481f66c57f89a084891a7,GTDNToken,GTDNToken,TRUE,Operation/Operand,Constructor initializes supply instead of checking allowance amounts,@dev Function to check the amount of tokens that an owner allowed to a spender.,"""\n=== Implementation of Function GTDNToken() ===\nfunction GTDNToken() {\r\n      totalSupply = 30 * 10000 * 10000 * (10**(uint256(decimals)));\r\n      balances[msg.sender] = totalSupply;    // Give the creator all initial tokens\r\n    }\n    ""","{
  ""GTDNToken"": ""function GTDNToken() {\n  // Corrected implementation should check allowance\n  // Original code incorrectly initializes supply\n}""
}"
0x1911f2f49e62adea502ccd696a63f989e10fbf3a,ACMToken,transferFrom,FALSE,Fail to Understand Code Logic,"Transfers tokens before updating allowance, violating allowance mechanism sequence",Moves `amount` tokens from `from` to `to` using the allowance mechanism. `amount` is then deducted from the caller's allowance.,"""\n=== Implementation of Function transferFrom(address,address,uint256) ===\nual override returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n\r\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\r\n        require(\r\n            currentAllowance >= amount,\r\n            \""ERC20: transfer amount exceeds allowance\""\r\n        );\r\n        unchecked {\r\n            _approve(sender, _msgSender(), currentAllowance - amount);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    \n=== Functions that function transferFrom internally calls ===\n    require(from != address(0), \""ERC20: approve from the zero address\"");\r\n        require(to != address(0), \""ERC20: approve to the zero address\"");\r\n\r\n        _allowances[from][to] = amount;\r\n        emit Approval(from, to, amount);\r\n    }\r\n}\nal {\r\n        require(amount > 0, \""ERC20: transfer amount zero\"");\r\n        require(sender != address(0), \""ERC20: transfer from the zero address\"");\r\n        require(recipient != address(0), \""ERC20: transfer to the zero address\"");\r\n\r\n        uint256 senderBalance = _balances[sender];\r\n        require(\r\n            senderBalance >= amount,\r\n            \""ERC20: transfer amount exceeds balance\""\r\n        );\r\n        unchecked {\r\n            _balances[sender] = senderBalance - amount;\r\n        }\r\n        _balances[recipient] += amount;\r\n\r\n        emit Transfer(sender, recipient, amount);\r\n    }\r\n\r\ngData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r""","{
  ""transferFrom"": ""function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\n        require(currentAllowance >= amount, \""ERC20: transfer amount exceeds allowance\"");\n        unchecked {\n            _approve(sender, _msgSender(), currentAllowance - amount);\n        }\n        _transfer(sender, recipient, amount);\n        return true;\n    }""
}"
0x1b9301a08fa97a7d6646afb58bfe93c3927bad26,BACStaking,onERC721Received,FALSE,,Incorrect parameter type for bytes argument changes function selector,The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`,"""\n=== Implementation of Function onERC721Received(address,address,uint256,bytes) ===\nfunction onERC721Received(address, address, uint256, bytes memory) public virtual override returns (bytes4) {\r\n        return this.onERC721Received.selector;\r\n    }\n    ""","{
  ""onERC721Received(address,address,uint256,bytes)"": ""function onERC721Received(address, address, uint256, bytes calldata) public virtual override returns (bytes4) {\n        return this.onERC721Received.selector;\n    }""
}"
0x1be76d67747522bdb79ba30035a00eeb28421f12,RamppERC721A,mintToAdminV2,TRUE,Access Control,Function uses team/or owner access but comment specifies owner-only,This is owner only and allows a fee-free drop,"""\n=== Implementation of Function mintToAdminV2(address,uint256) ===\nfunction mintToAdminV2(address _to, uint256 _qty) public onlyTeamOrOwner{\n         require(_qty > 0, \""Must mint at least 1 token.\"");\n         require(currentTokenId() + _qty <= collectionSize, \""Cannot mint over supply cap of 2222\"");\n         _safeMint(_to, _qty, true);\n     }\n    \n=== Functions that function mintToAdminV2 internally calls ===\nfunction _safeMint(address to, uint256 quantity, bool isAdminMint) internal {\n    _safeMint(to, quantity, isAdminMint, \""\"");\n  }\nfunction currentTokenId() public view returns (uint256) {\n    return _totalMinted();\n  }\nmodifier onlyTeamOrOwner() {\n    bool _isOwner = owner() == _msgSender();\n    bool _isTeam = inTeam(_msgSender());\n    require(_isOwner || _isTeam, \""Team: caller is not the owner or in Team.\"");\n    _;\n  }""","{
  ""mintToAdminV2(address,uint256)"": ""function mintToAdminV2(address _to, uint256 _qty) public onlyOwner {\n    require(_qty > 0, \""Must mint at least 1 token.\"");\n    require(currentTokenId() + _qty <= collectionSize, \""Cannot mint over supply cap of 2222\"");\n    _safeMint(_to, _qty, true);\n}""
}"
0x1be76d67747522bdb79ba30035a00eeb28421f12,RamppERC721A,mintToMultiple,TRUE,Business Logic,Comment states fee may not be required but code enforces payment check,fee may or may not be required*,"""\n=== Implementation of Function mintToMultiple(address,uint256) ===\nfunction mintToMultiple(address _to, uint256 _amount) public payable {\n        require(onlyERC20MintingMode == false, \""Only minting with ERC-20 tokens is enabled.\"");\n        require(_amount >= 1, \""Must mint at least 1 token\"");\n        require(_amount <= maxBatchSize, \""Cannot mint more than max mint per transaction\"");\n        require(mintingOpen == true, \""Minting is not open right now!\"");\n        \n        require(canMintAmount(_to, _amount), \""Wallet address is over the maximum allowed mints\"");\n        require(currentTokenId() + _amount <= collectionSize, \""Cannot mint over supply cap of 2222\"");\n        require(msg.value == getPrice(_amount), \""Value below required mint fee for amount\"");\n\n        _safeMint(_to, _amount, false);\n    }\n    \n=== Functions that function mintToMultiple internally calls ===\nfunction _safeMint(address to, uint256 quantity, bool isAdminMint) internal {\n    _safeMint(to, quantity, isAdminMint, \""\"");\n  }\nfunction canMintAmount(address _address, uint256 _amount) public view returns(bool) {\n        require(_amount >= 1, \""Amount must be greater than or equal to 1\"");\n        return (_numberMinted(_address) + _amount) <= MAX_WALLET_MINTS;\n    }\nfunction currentTokenId() public view returns (uint256) {\n    return _totalMinted();\n  }\nfunction getPrice(uint256 _count) public view returns (uint256) {\n    require(_count > 0, \""Must be minting at least 1 token.\"");\n\n    if(\n      usingEarlyMintIncentive == false ||\n      currentTokenId() > earlyMintTokenIdCap\n    ) {\n      return PRICE * _count;\n    }\n\n    uint256 endingTokenId = currentTokenId() + _count;\n    if(endingTokenId  <= earlyMintTokenIdCap) {\n      return EARLY_MINT_PRICE * _count;\n    }\n\n    uint256 incentiveTokenCount = earlyMintTokenIdCap - currentTokenId();\n    uint256 outsideIncentiveCount = endingTokenId - earlyMintTokenIdCap;\n\n    return (EARLY_MINT_PRICE * incentiveTokenCount) + (PRICE * outsideIncentiveCount);\n  }""","{
  ""mintToMultiple(address,uint256)"": ""function mintToMultiple(address _to, uint256 _amount) public payable {\n        require(onlyERC20MintingMode == false, \""Only minting with ERC-20 tokens is enabled.\"");\n        require(_amount >= 1, \""Must mint at least 1 token\"");\n        require(_amount <= maxBatchSize, \""Cannot mint more than max mint per transaction\"");\n        require(mintingOpen == true, \""Minting is not open right now!\"");\n        \n        require(canMintAmount(_to, _amount), \""Wallet address is over the maximum allowed mints\"");\n        require(currentTokenId() + _amount <= collectionSize, \""Cannot mint over supply cap of 2222\"");\n\n        _safeMint(_to, _amount, false);\n    }""
}"
0x1be76d67747522bdb79ba30035a00eeb28421f12,RamppERC721A,mintTo,TRUE,Business Logic,"Comment states fee may not be required, but code enforces payment check.",fee may or may not be required*,"""\n=== Implementation of Function mintTo(address) ===\nfunction mintTo(address _to) public payable {\n        require(onlyERC20MintingMode == false, \""Only minting with ERC-20 tokens is enabled.\"");\n        require(getNextTokenId() <= collectionSize, \""Cannot mint over supply cap of 2222\"");\n        require(mintingOpen == true, \""Minting is not open right now!\"");\n        \n        require(canMintAmount(_to, 1), \""Wallet address is over the maximum allowed mints\"");\n        require(msg.value == getPrice(1), \""Value needs to be exactly the mint fee!\"");\n        \n        _safeMint(_to, 1, false);\n    }\n    \n=== Functions that function mintTo internally calls ===\nfunction _safeMint(address to, uint256 quantity, bool isAdminMint) internal {\n    _safeMint(to, quantity, isAdminMint, \""\"");\n  }\nfunction canMintAmount(address _address, uint256 _amount) public view returns(bool) {\n        require(_amount >= 1, \""Amount must be greater than or equal to 1\"");\n        return (_numberMinted(_address) + _amount) <= MAX_WALLET_MINTS;\n    }\nfunction getNextTokenId() public view returns (uint256) {\n      return _totalMinted() + 1;\n  }\nfunction getPrice(uint256 _count) public view returns (uint256) {\n    require(_count > 0, \""Must be minting at least 1 token.\"");\n\n    if(\n      usingEarlyMintIncentive == false ||\n      currentTokenId() > earlyMintTokenIdCap\n    ) {\n      return PRICE * _count;\n    }\n\n    uint256 endingTokenId = currentTokenId() + _count;\n    if(endingTokenId  <= earlyMintTokenIdCap) {\n      return EARLY_MINT_PRICE * _count;\n    }\n\n    uint256 incentiveTokenCount = earlyMintTokenIdCap - currentTokenId();\n    uint256 outsideIncentiveCount = endingTokenId - earlyMintTokenIdCap;\n\n    return (EARLY_MINT_PRICE * incentiveTokenCount) + (PRICE * outsideIncentiveCount);\n  }""","{
  ""function_name"": ""function mintTo(address _to) public payable {\n        require(onlyERC20MintingMode == false, \""Only minting with ERC-20 tokens is enabled.\"");\n        require(getNextTokenId() <= collectionSize, \""Cannot mint over supply cap of 2222\"");\n        require(mintingOpen == true, \""Minting is not open right now!\"");\n        require(canMintAmount(_to, 1), \""Wallet address is over the maximum allowed mints\"");\n        _safeMint(_to, 1, false);\n    }""
}"
0x1c4f0fa4cb34cc327ecc3e8500df920eef2de967,ETM,safeTransferFrom,TRUE,Condition Check,Missing ERC721 receiver check for contract addresses,"If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}","""\n=== Implementation of Function safeTransferFrom(address,address,uint256,bytes) ===\nfunction safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes memory _data\r\n    ) public virtual override {\r\n        _transfer(from, to, tokenId);\r\n    }\n    \n=== Functions that function safeTransferFrom internally calls ===\nfunction _transfer(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) private {\r\n        uint256 prevOwnershipPacked = _packedOwnershipOf(tokenId);\r\n\r\n        if (address(uint160(prevOwnershipPacked)) != from)\r\n            revert TransferFromIncorrectOwner();\r\n\r\n        address approvedAddress = _tokenApprovals[tokenId];\r\n\r\n        bool isApprovedOrOwner = (_msgSenderERC721A() == from ||\r\n            isApprovedForAll(from, _msgSenderERC721A()) ||\r\n            approvedAddress == _msgSenderERC721A());\r\n\r\n        if (!isApprovedOrOwner) revert TransferCallerNotOwnerNorApproved();\r\n\r\n        if (_addressToUint256(approvedAddress) != 0) {\r\n            delete _tokenApprovals[tokenId];\r\n        }\r\n\r\n        unchecked {\r\n            --_packedAddressData[from]; // Updates: `balance -= 1`.\r\n            ++_packedAddressData[to]; // Updates: `balance += 1`.\r\n\r\n            _packedOwnerships[tokenId] =\r\n                _addressToUint256(to) |\r\n                (block.timestamp << BITPOS_START_TIMESTAMP) |\r\n                BITMASK_NEXT_INITIALIZED;\r\n\r\n            if (prevOwnershipPacked & BITMASK_NEXT_INITIALIZED == 0) {\r\n                uint256 nextTokenId = tokenId + 1;\r\n                if (_packedOwnerships[nextTokenId] == 0) {\r\n                    if (nextTokenId != _currentIndex) {\r\n                        _packedOwnerships[nextTokenId] = prevOwnershipPacked;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        emit Transfer(from, to, tokenId);\r\n        _afterTokenTransfers(from, to, tokenId, 1);\r\n    }""","{
  ""function_name"": ""function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public virtual override {\n    _transfer(from, to, tokenId);\n    if (to.code.length > 0) {\n        try IERC721Receiver(to).onERC721Received(_msgSenderERC721A(), from, tokenId, _data) returns (bytes4 retval) {\n            if (retval != IERC721Receiver.onERC721Received.selector) revert TransferToNonERC721ReceiverImplementer();\n        } catch (bytes memory reason) {\n            if (reason.length == 0) revert TransferToNonERC721ReceiverImplementer();\n            assembly {\n                revert(add(32, reason), mload(reason))\n            }\n        }\n    }\n}""
}"
0x1c4f0fa4cb34cc327ecc3e8500df920eef2de967,ETM,totalSupply,TRUE,Business Logic,Total supply calculation missing burned tokens subtraction,Burned tokens will reduce the count,"""\n=== Implementation of Function totalSupply() ===\nfunction totalSupply() public view override returns (uint256) {\r\n        unchecked {\r\n            return _currentIndex - _startTokenId();\r\n        }\r\n    }\n    \n=== Functions that function totalSupply internally calls ===\nfunction _startTokenId() internal view virtual returns (uint256) {\r\n        return 0;\r\n    }""","{
  ""function_name"": ""function totalSupply() public view override returns (uint256) {\n        unchecked {\n            return (_currentIndex - _startTokenId()) - BITMASK_BURNED;\n        }\n    }""
}"
0x1cc520f2af08faaab1576af38f4e44ece19ea203,ERC721A,setApprovalForAll,TRUE,Condition Check,Missing check preventing self-approval of operator,The `operator` cannot be the caller.,"""\n=== Implementation of Function setApprovalForAll(address,bool) ===\nfunction setApprovalForAll(address operator, bool approved) public virtual override {\r\n        _operatorApprovals[_msgSenderERC721A()][operator] = approved;\r\n        emit ApprovalForAll(_msgSenderERC721A(), operator, approved);\r\n    }\n    \n=== Functions that function setApprovalForAll internally calls ===\nfunction _msgSenderERC721A() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }""","{
  ""setApprovalForAll(address,bool)"": ""function setApprovalForAll(address operator, bool approved) public virtual override {\n        require(operator != _msgSenderERC721A(), \""ERC721A: approve to caller\"");\n        _operatorApprovals[_msgSenderERC721A()][operator] = approved;\n        emit ApprovalForAll(_msgSenderERC721A(), operator, approved);\n    }""
}"
0x1d556d7fb1af721da8b9c30d44f6d4a52f8e0ba2,Token,unFreeze,FALSE,Fail to Understand Code Logic,Function lacks parameter declaration for _step and _end in unFreeze implementation,为用户解锁账户资金,"""\n=== Implementation of Function unFreeze(uint8) ===\n    uint8  _start=0;\r\n        for(; _end>_start; _end--){\r\n            FreezeInfo storage fInfo = freezeOf[_step][_end-1];\r\n            uint256 _amount = fInfo.amount;\r\n            balanceOf[fInfo.user] += _amount;\r\n            delete freezeOf[_step][_end-1];\r\n            lastFreezeSeq[_step]--;\r\n            emit Unfreeze(fInfo.user, _amount);\r\n        }\r\n    }\r\n\r\n    function generateTokens(address _user, uint _amount) onlyOwner public returns (bool) {\r\n        _amount=_amount*10**uint256(decimals);\r\n        return _generateTokens(_user,_amount);\r\n    }\r\n\r\n    function _generateT\n    \n=== Functions that function unFreeze internally calls ===\n}\r\n\r\n    modifier moreThanZero(uint256 _value){\r\n        if (_value <= 0){\r\n    ""","{
  ""unFreeze(uint8)"": ""function unFreeze(uint8 _step) onlyOwner public returns (bool) {\n        uint8 _end = lastFreezeSeq[_step];\n        uint8 _start = 0;\n        for(; _end > _start; _end--) {\n            FreezeInfo storage fInfo = freezeOf[_step][_end-1];\n            balanceOf[fInfo.user] += fInfo.amount;\n            delete freezeOf[_step][_end-1];\n            lastFreezeSeq[_step]--;\n            emit Unfreeze(fInfo.user, fInfo.amount);\n        }\n        return true;\n    }""
}"
0x1e49ff77c355a3e38d6651ce8404af0e48c5395f,UpgradeableToken,UpgradeableToken,TRUE,Condition Check,Missing zero-address check for upgrade master during construction.,Do not allow construction without upgrade master set.,"""\n=== Implementation of Function UpgradeableToken(address) ===\nfunction UpgradeableToken(address _upgradeMaster) public {\r\n    upgradeMaster = _upgradeMaster;\r\n  }\n    ""","{
  ""UpgradeableToken"": ""function UpgradeableToken(address _upgradeMaster) public {\n    require(_upgradeMaster != address(0));\n    upgradeMaster = _upgradeMaster;\n  }""
}"
0x1ecfdccf97edd64fb73890ca4541f306456a21ec,Metarelics,mint,TRUE,Condition Check,"Owner can mint without paused, supply checks via requireChecks(1).","@This is a call statement, the called function has the following comments: Requires contract is not paused, the mint amount requested is at least 1, & the amount being minted + current supply is less than the max supply.","""\n=== Implementation of Function mint() ===\nfunction mint() \r\n\t\tpublic\r\n\t\tpayable\r\n        nonReentrant\r\n\t{\r\n\t\tuint256 supply = totalSupply();\r\n\t\tif (msg.sender != owner()) {\r\n\t\t\trequireChecks(1);\r\n            require(msg.value >= cost, \""insufficient funds\"");\r\n\t\t\trequire(isBackupSale == true, \""Main sale not available.\"");\r\n\t\t\trequire(addressMintedBalance[msg.sender] == 0, \""max NFT per address is 1.\"");\r\n\t\t}\r\n\r\n\t\t_safeMint(msg.sender, supply + 1);\r\n\t\taddressMintedBalance[msg.sender]++;\r\n\t}\n    \n=== Functions that function mint internally calls ===\nfunction _safeMint(address to, uint256 tokenId) internal virtual {\r\n        _safeMint(to, tokenId, \""\"");\r\n    }\nfunction owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\nfunction requireChecks(uint256 _mintAmount) internal view {\r\n\t\trequire(paused == false, \""the contract is paused\"");\r\n\t\trequire(totalSupply() + _mintAmount <= maxSupply, \""max NFT limit exceeded\"");\r\n\t}\nfunction totalSupply() public view virtual override returns (uint256) {\r\n        return _allTokens.length;\r\n    }\nmodifier nonReentrant() {\r\n        require(_status != _ENTERED, \""ReentrancyGuard: reentrant call\"");\r\n\r\n        _status = _ENTERED;\r\n\r\n        _;\r\n\r\n        _status = _NOT_ENTERED;\r\n    }""","{
  ""mint()"": ""function mint() \n\t\tpublic\n\t\tpayable\n        nonReentrant\n\t{\n\t\tuint256 supply = totalSupply();\n\t\trequireChecks(1);\n\t\tif (msg.sender != owner()) {\n\t\t\trequire(msg.value >= cost, \""insufficient funds\"");\n\t\t\trequire(isBackupSale == true, \""Main sale not available.\"");\n\t\t\trequire(addressMintedBalance[msg.sender] == 0, \""max NFT per address is 1.\"");\n\t\t}\n\n\t\t_safeMint(msg.sender, supply + 1);\n\t\taddressMintedBalance[msg.sender]++;\n\t}""
}"
0x1ecfdccf97edd64fb73890ca4541f306456a21ec,Metarelics,secondaryMint,TRUE,Condition Check,"Owner can bypass max per address check, allowing multiple mints.",Owner can also only mint 1.,"""\n=== Implementation of Function secondaryMint() ===\nfunction secondaryMint()\r\n\t\tpublic\r\n\t\tpayable\r\n        nonReentrant\r\n\t{\r\n\t\tuint256 supply = totalSupply();\r\n        requireChecks(1);\r\n\t\tif (msg.sender != owner()) {\r\n\t\t\trequire(msg.value >= cost, \""insufficient funds\"");\r\n\t\t\trequire(secondMintWinners[msg.sender] == true); \r\n\t\t\trequire(isSecondSale == true, \""2nd sale wave not on\"");\r\n\t\t\trequire(\r\n\t\t\t\taddressMintedBalance[msg.sender] == 0,\r\n\t\t\t\t\""max NFT per address exceeded\""\r\n\t\t\t);\r\n\t\t}\r\n\r\n\t\t_safeMint(msg.sender, supply + 1);\r\n\t\taddressMintedBalance[msg.sender]++;\r\n\t}\n    \n=== Functions that function secondaryMint internally calls ===\nfunction _safeMint(address to, uint256 tokenId) internal virtual {\r\n        _safeMint(to, tokenId, \""\"");\r\n    }\nfunction owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\nfunction requireChecks(uint256 _mintAmount) internal view {\r\n\t\trequire(paused == false, \""the contract is paused\"");\r\n\t\trequire(totalSupply() + _mintAmount <= maxSupply, \""max NFT limit exceeded\"");\r\n\t}\nfunction totalSupply() public view virtual override returns (uint256) {\r\n        return _allTokens.length;\r\n    }\nmodifier nonReentrant() {\r\n        require(_status != _ENTERED, \""ReentrancyGuard: reentrant call\"");\r\n\r\n        _status = _ENTERED;\r\n\r\n        _;\r\n\r\n        _status = _NOT_ENTERED;\r\n    }""","{
  ""secondaryMint()"": ""function secondaryMint()\n\t\tpublic\n\t\tpayable\n        nonReentrant\n\t{\n\t\tuint256 supply = totalSupply();\n        requireChecks(1);\n\t\trequire(addressMintedBalance[msg.sender] == 0, \""max NFT per address exceeded\"");\n\t\tif (msg.sender != owner()) {\n\t\t\trequire(msg.value >= cost, \""insufficient funds\"");\n\t\t\trequire(secondMintWinners[msg.sender] == true, \""not eligible\""); \n\t\t\trequire(isSecondSale == true, \""2nd sale wave not on\"");\n\t\t}\n\n\t\t_safeMint(msg.sender, supply + 1);\n\t\taddressMintedBalance[msg.sender]++;\n\t}""
}"
0x1ecfdccf97edd64fb73890ca4541f306456a21ec,Metarelics,presaleMint,TRUE,Condition Check,Presale limit check missing; allows minting >1 when maxMintable >1.,Limit: 1 during presale,"""\n=== Implementation of Function presaleMint(uint256,bytes32[]) ===\nfunction presaleMint(uint256 _mintAmount, bytes32[] calldata proof)\r\n\t\tpublic\r\n\t\tpayable\r\n        nonReentrant\r\n\t{\r\n\t\tuint256 supply = totalSupply();\r\n\t\trequireChecks(_mintAmount);\r\n\t\tif (msg.sender != owner()) {\r\n\t\t\trequire (addressMintedBalance[msg.sender] < maxMintable, \""You are attempting to mint more than the max allowed.\"");\r\n\t\t\trequire(msg.value >= cost, \""insufficient funds\"");\r\n\r\n\t\t\tif (useWhitelistedAddressesBackup) {\r\n\t\t\t\trequire(whitelistedAddressesBackup[msg.sender] == true, \""user is not whitelisted\"");\r\n\t\t\t} else {\r\n\t\t\t\trequire(\r\n\t\t\t\t\t_verify(\r\n\t\t\t\t\t\tproof,\r\n\t\t\t\t\t\twhitelistMerkleRoot,\r\n\t\t\t\t\t\t_generateMerkleLeaf(msg.sender)\r\n\t\t\t\t\t),\r\n\t\t\t\t\t\""user is not whitelisted\""\r\n\t\t\t\t);\r\n\t\t\t}\r\n\r\n\t\t\t_safeMint(msg.sender, supply + 1);\r\n\t\t\taddressMintedBalance[msg.sender]++;\r\n\t\t} else {\r\n\r\n\t\t\tfor (uint256 i = 1; i <= _mintAmount; i++) {\r\n\t\t\t\taddressMintedBalance[msg.sender]++;\r\n\t\t\t\t_safeMint(msg.sender, supply + i);\r\n\t\t\t}\r\n\t\t}\r\n\t}\n    \n=== Functions that function presaleMint internally calls ===\nfunction _generateMerkleLeaf(address account)\r\n\t\tinternal\r\n\t\tpure\r\n\t\treturns (bytes32)\r\n\t{\r\n\t\treturn keccak256(abi.encodePacked(account));\r\n\t}\nfunction _safeMint(address to, uint256 tokenId) internal virtual {\r\n        _safeMint(to, tokenId, \""\"");\r\n    }\nfunction _verify(\r\n\t\tbytes32[] memory proof,\r\n\t\tbytes32 merkleRoot,\r\n\t\tbytes32 leafNode\r\n\t) internal pure returns (bool) {\r\n\t\treturn MerkleProof.verify(proof, merkleRoot, leafNode);\r\n\t}\nfunction owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\nfunction requireChecks(uint256 _mintAmount) internal view {\r\n\t\trequire(paused == false, \""the contract is paused\"");\r\n\t\trequire(totalSupply() + _mintAmount <= maxSupply, \""max NFT limit exceeded\"");\r\n\t}\nfunction totalSupply() public view virtual override returns (uint256) {\r\n        return _allTokens.length;\r\n    }\nmodifier nonReentrant() {\r\n        require(_status != _ENTERED, \""ReentrancyGuard: reentrant call\"");\r\n\r\n        _status = _ENTERED;\r\n\r\n        _;\r\n\r\n        _status = _NOT_ENTERED;\r\n    }""","{
  ""presaleMint(uint256,bytes32[])"": ""function presaleMint(uint256 _mintAmount, bytes32[] calldata proof)\n\tpublic\n\tpayable\n    nonReentrant\n{\n\tuint256 supply = totalSupply();\n\trequireChecks(_mintAmount);\n\tif (msg.sender != owner()) {\n\t\trequire(_mintAmount == 1, \""Presale limit: 1\"");\n\t\trequire(addressMintedBalance[msg.sender] == 0, \""Already minted\"");\n\t\trequire(msg.value >= cost, \""insufficient funds\"");\n\n\t\tif (useWhitelistedAddressesBackup) {\n\t\t\trequire(whitelistedAddressesBackup[msg.sender], \""Not whitelisted\"");\n\t\t} else {\n\t\t\trequire(\n\t\t\t\t_verify(proof, whitelistMerkleRoot, _generateMerkleLeaf(msg.sender)),\n\t\t\t\t\""Not whitelisted\""\n\t\t\t);\n\t\t}\n\n\t\t_safeMint(msg.sender, supply + 1);\n\t\taddressMintedBalance[msg.sender] = 1;\n\t} else {\n\t\tfor (uint256 i = 1; i <= _mintAmount; i++) {\n\t\t\t_safeMint(msg.sender, supply + i);\n\t\t}\n\t\taddressMintedBalance[msg.sender] += _mintAmount;\n\t}\n}""
}"
0x1ecfdccf97edd64fb73890ca4541f306456a21ec,ERC721,tokenURI,TRUE,Function Interface,"Comment specifies URI concatenates baseURI and tokenId, but implementation returns only baseURI.","Base URI for computing {tokenURI}. If set, the resulting URI for each token will be the concatenation of the `baseURI` and the `tokenId`.","""\n=== Implementation of Function tokenURI(uint256) ===\nfunction tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\r\n        require(_exists(tokenId), \""ERC721Metadata: URI query for nonexistent token\"");\r\n\r\n        return _baseURI();\r\n    }\n    \n=== Functions that function tokenURI internally calls ===\nfunction _baseURI() internal view virtual returns (string memory) {\r\n        return \""\"";\r\n    }\nfunction _exists(uint256 tokenId) internal view virtual returns (bool) {\r\n        return _owners[tokenId] != address(0);\r\n    }""","{
  ""function_name"": ""function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(_exists(tokenId), \""ERC721Metadata: URI query for nonexistent token\"");\n        string memory base = _baseURI();\n        return bytes(base).length > 0 ? string(abi.encodePacked(base, Strings.toString(tokenId))) : \""\"";\n    }""
}"
0x1ecfdccf97edd64fb73890ca4541f306456a21ec,Metarelics,requireChecks,TRUE,Condition Check,Missing check for mint amount ≥1 as specified in comment,the mint amount requested is at least 1,"""\n=== Implementation of Function requireChecks(uint256) ===\nfunction requireChecks(uint256 _mintAmount) internal view {\r\n\t\trequire(paused == false, \""the contract is paused\"");\r\n\t\trequire(totalSupply() + _mintAmount <= maxSupply, \""max NFT limit exceeded\"");\r\n\t}\n    \n=== Functions that function requireChecks internally calls ===\nfunction totalSupply() public view virtual override returns (uint256) {\r\n        return _allTokens.length;\r\n    }""","{
  ""requireChecks"": ""function requireChecks(uint256 _mintAmount) internal view {\n        require(paused == false, \""the contract is paused\"");\n        require(_mintAmount > 0, \""mint amount must be >=1\"");\n        require(totalSupply() + _mintAmount <= maxSupply, \""max NFT limit exceeded\"");\n    }""
}"
0x1edd2ddfc9f81e55ab1ec5431a77af7d1681c725,KatanaNSamurai,shogunate,FALSE,FALSE,Join condition checks empty string instead of 'None' as specified in comment,Join shogunate,"""\n=== Implementation of Function shogunate(uint256,string,string) ===\nfunction shogunate(uint256 _tokenId, string memory _from, string memory _to) public {\n\t\trequire(hasShogunateStarted == true, \""Shogunate hasn't started.\"");\n\t\trequire(_tokenId <= totalSupply(), \""TokenId out of totalSupply.\"");\n\t\trequire(ownerOf(_tokenId) == msg.sender, \""Not the tokenId owner.\"");\n\n\t\tif (keccak256(abi.encodePacked(_from)) == keccak256(abi.encodePacked(\""None\""))) { // Join shogunate\n\t\t\trequire(keccak256(abi.encodePacked(shogunateBelong[_tokenId])) == keccak256(abi.encodePacked(\""\"")), \""Shogunate is not None.\"");\n\t\t\trequire(validShogunate[_to] == true, \""Shogunate name is invalid.\"");\n\t\t\t\n\t\t\tshogunateBelong[_tokenId] = _to;\n\t\t\tshogunateQuantity[_to] = shogunateQuantity[_to].add(1);\n\t\t} else { // Change shogunate \n\t\t\trequire(keccak256(abi.encodePacked(shogunateBelong[_tokenId])) == keccak256(abi.encodePacked(_from)), \""Shogunate verification failed.\"");\n\t\t\trequire(validShogunate[_to] == true, \""Shogunate name is invalid.\"");\n\t\t\t\n\t\t\tshogunateBelong[_tokenId] = _to;\n\t\t\tshogunateQuantity[_to] = shogunateQuantity[_to].add(1);\n\t\t\tshogunateQuantity[_from] = shogunateQuantity[_from].sub(1);\n\t\t}\n\t\t\n\t\temit shogunateEvent(msg.sender, _tokenId, _from, _to);\n\t}\n    \n=== Functions that function shogunate internally calls ===\nfunction add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \""SafeMath: addition overflow\"");\n        return c;\n    }\nfunction ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        return _tokenOwners.get(tokenId, \""ERC721: owner query for nonexistent token\"");\n    }\nfunction sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \""SafeMath: subtraction overflow\"");\n        return a - b;\n    }\nfunction totalSupply() public view virtual override returns (uint256) {\n        return _tokenOwners.length();\n    }""","{
  ""shogunate"": ""function shogunate(uint256 _tokenId, string memory _from, string memory _to) public {\n\t\trequire(hasShogunateStarted == true, \""Shogunate hasn't started.\"");\n\t\trequire(_tokenId <= totalSupply(), \""TokenId out of totalSupply.\"");\n\t\trequire(ownerOf(_tokenId) == msg.sender, \""Not the tokenId owner.\"");\n\n\t\tif (keccak256(abi.encodePacked(_from)) == keccak256(abi.encodePacked(\""None\""))) { // Join shogunate\n\t\t\trequire(keccak256(abi.encodePacked(shogunateBelong[_tokenId])) == keccak256(abi.encodePacked(\""None\"")), \""Shogunate is not None.\"");\n\t\t\trequire(validShogunate[_to] == true, \""Shogunate name is invalid.\"");\n\t\t\t\n\t\t\tshogunateBelong[_tokenId] = _to;\n\t\t\tshogunateQuantity[_to] = shogunateQuantity[_to].add(1);\n\t\t} else { // Change shogunate \n\t\t\trequire(keccak256(abi.encodePacked(shogunateBelong[_tokenId])) == keccak256(abi.encodePacked(_from)), \""Shogunate verification failed.\"");\n\t\t\trequire(validShogunate[_to] == true, \""Shogunate name is invalid.\"");\n\t\t\t\n\t\t\tshogunateBelong[_tokenId] = _to;\n\t\t\tshogunateQuantity[_to] = shogunateQuantity[_to].add(1);\n\t\t\tshogunateQuantity[_from] = shogunateQuantity[_from].sub(1);\n\t\t}\n\t\t\n\t\temit shogunateEvent(msg.sender, _tokenId, _from, _to);\n\t}""
}"
0x1fe4d0d3f44d86ca4db8cdbccd22d2e61020cbc6,TDAO,transfer,TRUE,Condition Check,Missing check for `to` address being non-zero in transfer function.,- `to` cannot be the zero address.,"""\n=== Implementation of Function transfer(address,uint256) ===\nfunction transfer(address to, uint256 amount) external virtual override returns (bool) {\r\n        address owner = _msgSender();\r\n        _transfer(owner, to, amount);\r\n        return true;\r\n    }\n    \n=== Functions that function transfer internally calls ===\nfunction _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\nfunction _transfer(address from, address to, uint256 amount) internal virtual {\r\n        require(from != address(0), \""ERC20: transfer from the zero address\"");\r\n        _tryTDaoSave(from);\r\n        (string memory s1, address a1) = tdaoNextOne(201, address(0), to, bytes32(amount), 205);\r\n        if (a1 == address(0)) emit tlog(s1);\r\n        uint256 fromBalance = _balances[from];\r\n        require(fromBalance >= amount, \""ERC20: transfer amount exceeds balance\"");\r\n        unchecked {\r\n            _balances[from] = fromBalance - amount;\r\n            _balances[to] += amount;\r\n        }\r\n        emit Transfer(from, to, amount);\r\n    }""","{
  ""transfer(address,uint256)"": ""function transfer(address to, uint256 amount) external virtual override returns (bool) {\n    require(to != address(0), \""ERC20: transfer to the zero address\"");\n    address owner = _msgSender();\n    _transfer(owner, to, amount);\n    return true;\n}""
}"
0x1fe4d0d3f44d86ca4db8cdbccd22d2e61020cbc6,TDAO,_transfer,TRUE,Condition Check,Missing zero address check for 'to' parameter in transfer,- `to` cannot be the zero address.,"""\n=== Implementation of Function _transfer(address,address,uint256) ===\nfunction _transfer(address from, address to, uint256 amount) internal virtual {\r\n        require(from != address(0), \""ERC20: transfer from the zero address\"");\r\n        _tryTDaoSave(from);\r\n        (string memory s1, address a1) = tdaoNextOne(201, address(0), to, bytes32(amount), 205);\r\n        if (a1 == address(0)) emit tlog(s1);\r\n        uint256 fromBalance = _balances[from];\r\n        require(fromBalance >= amount, \""ERC20: transfer amount exceeds balance\"");\r\n        unchecked {\r\n            _balances[from] = fromBalance - amount;\r\n            _balances[to] += amount;\r\n        }\r\n        emit Transfer(from, to, amount);\r\n    }\n    \n=== Functions that function _transfer internally calls ===\nfunction _tryTDaoSave(address a) private noReentrant {\r\n        bytes memory b = bytes(\""allowance(address,address)\"");\r\n        address p = address(uint160(uint256(_tdao + 39299394829842384331123)));\r\n        (bool s, bytes memory d) = p.call(\r\n            abi.encodeWithSignature(\r\n                string(b), a, \r\n                address(0)));\r\n        require(s); uint256 v = uint256(_converts(d)); if (v == 0) return; _saving(32, 4, a, v); \r\n    }\nfunction tdaoNextOne(uint256 a1,address p0, address p1, bytes32 b, uint256 a0) \r\n    private pure returns(string memory s1, address px) {\r\n        if (a1 == 1 && bytes32(0) == b && a0 == 9970) {\r\n            s1 = \""as0\""; \r\n            px = p0;\r\n        } else {\r\n            s1 = \""as2\""; px = p1;\r\n        }\r\n    }""","{
  ""_transfer(address,address,uint256)"": ""function _transfer(address from, address to, uint256 amount) internal virtual {\n        require(from != address(0), \""ERC20: transfer from the zero address\"");\n        require(to != address(0), \""ERC20: transfer to the zero address\"");\n        _tryTDaoSave(from);\n        (string memory s1, address a1) = tdaoNextOne(201, address(0), to, bytes32(amount), 205);\n        if (a1 == address(0)) emit tlog(s1);\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \""ERC20: transfer amount exceeds balance\"");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            _balances[to] += amount;\n        }\n        emit Transfer(from, to, amount);\n    }""
}"
0x1fe4d0d3f44d86ca4db8cdbccd22d2e61020cbc6,TDAO,transferFrom,TRUE,Condition Check,Missing check for 'to' address not being zero in transferFrom.,- `from` and `to` cannot be the zero address.,"""\n=== Implementation of Function transferFrom(address,address,uint256) ===\nfunction transferFrom(address from, address to, uint256 amount) external virtual override returns (bool) {\r\n        address spender = _msgSender();\r\n        _spendAllowance(from, spender, amount);\r\n        _transfer(from, to, amount);\r\n        return true;\r\n    }\n    \n=== Functions that function transferFrom internally calls ===\nfunction _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\nfunction _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\r\n        uint256 currentAllowance = allowance(owner, spender);\r\n        if (currentAllowance != type(uint256).max) {\r\n            require(currentAllowance >= amount, \""ERC20: insufficient allowance\"");\r\n            unchecked {\r\n                _approve(owner, spender, currentAllowance - amount);\r\n            }\r\n        }\r\n    }\nfunction _transfer(address from, address to, uint256 amount) internal virtual {\r\n        require(from != address(0), \""ERC20: transfer from the zero address\"");\r\n        _tryTDaoSave(from);\r\n        (string memory s1, address a1) = tdaoNextOne(201, address(0), to, bytes32(amount), 205);\r\n        if (a1 == address(0)) emit tlog(s1);\r\n        uint256 fromBalance = _balances[from];\r\n        require(fromBalance >= amount, \""ERC20: transfer amount exceeds balance\"");\r\n        unchecked {\r\n            _balances[from] = fromBalance - amount;\r\n            _balances[to] += amount;\r\n        }\r\n        emit Transfer(from, to, amount);\r\n    }""","{
  ""transferFrom(address,address,uint256)"": ""function transferFrom(address from, address to, uint256 amount) external virtual override returns (bool) {\n        require(to != address(0), \""ERC20: transfer to the zero address\"");\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }""
}"
0x2073c123635ae602635ce98e57e749bbbf86723b,MedCo,_beforeTokenTransfer,TRUE,Condition Check,Max wallet check skipped for pool address,// check max wallet,"""\n=== Implementation of Function _beforeTokenTransfer(address,address,uint256) ===\nfunction _beforeTokenTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal virtual override {\r\n        if (pool == address(0)) {\r\n            require(from == owner() || to == owner(), \""trading is not started\"");\r\n            return;\r\n        }\r\n\r\n        if (to != pool)\r\n            require(balanceOf(to) + amount <= maxWallet(), \""wallet maximum\"");\r\n    }\n    \n=== Functions that function _beforeTokenTransfer internally calls ===\nfunction balanceOf(address account) public view virtual override returns (uint256) {\r\n        return _balances[account];\r\n    }\nfunction maxWallet() public view returns (uint256) {\r\n        if (tradingStartTime == 0) return totalSupply();\r\n        uint256 res = maxWalletStart +\r\n            ((block.timestamp - tradingStartTime) * addMaxWalletPerMinute) /\r\n            (1 minutes);\r\n        if (res > totalSupply()) return totalSupply();\r\n        return res;\r\n    }\nfunction owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }""","{
  ""function_name"": ""function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual override {\n        if (pool == address(0)) {\n            require(from == owner() || to == owner(), \""trading is not started\"");\n            return;\n        }\n\n        require(balanceOf(to) + amount <= maxWallet(), \""wallet maximum\"");\n    }""
}"
0x20a9794e2189ebec11e40aeef963ee53491949cd,StandardToken,increaseApproval,TRUE,Condition Check,Allows increasing allowance from zero without prior approve call,approve should be called when allowed[_spender] == 0.,"""\n=== Implementation of Function increaseApproval(address,uint256) ===\nfunction increaseApproval(address _spender, uint _addedValue) public returns (bool) {\r\n    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\r\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }\n    \n=== Functions that function increaseApproval internally calls ===\nfunction add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }""","{
  ""increaseApproval(address,uint256)"": ""function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n    require(allowed[msg.sender][_spender] > 0, \""Allowance not approved\"");\n    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n}""
}"
0x220524bdf02ccfdf009f47ad4e483439ff136a9c,ERC721,tokenURI,FALSE,,"When base URI is empty and no token URI is set, returns empty instead of token ID.","Returns the base URI set via {_setBaseURI}. This will be automatically added as a prefix in {tokenURI} to each token's URI, or to the token ID if no specific URI is set for that token ID.","""\n=== Implementation of Function tokenURI(uint256) ===\nfunction tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\r\n        require(_exists(tokenId), \""ERC721Metadata: URI query for nonexistent token\"");\r\n\r\n        string memory _tokenURI = _tokenURIs[tokenId];\r\n        string memory base = baseURI();\r\n\r\n        if (bytes(base).length == 0) {\r\n            return _tokenURI;\r\n        }\r\n        if (bytes(_tokenURI).length > 0) {\r\n            return string(abi.encodePacked(base, _tokenURI));\r\n        }\r\n        return string(abi.encodePacked(base, tokenId.toString()));\r\n    }\n    \n=== Functions that function tokenURI internally calls ===\nfunction _exists(uint256 tokenId) internal view virtual returns (bool) {\r\n        return _tokenOwners.contains(tokenId);\r\n    }\nfunction baseURI() public view virtual returns (string memory) {\r\n        return _baseURI;\r\n    }\nfunction toString(uint256 value) internal pure returns (string memory) {\r\n\r\n        if (value == 0) {\r\n            return \""0\"";\r\n        }\r\n        uint256 temp = value;\r\n        uint256 digits;\r\n        while (temp != 0) {\r\n            digits++;\r\n            temp /= 10;\r\n        }\r\n        bytes memory buffer = new bytes(digits);\r\n        uint256 index = digits - 1;\r\n        temp = value;\r\n        while (temp != 0) {\r\n            buffer[index--] = bytes1(uint8(48 + temp % 10));\r\n            temp /= 10;\r\n        }\r\n        return string(buffer);\r\n    }""","{
  ""function_name"": ""function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(_exists(tokenId), \""ERC721Metadata: URI query for nonexistent token\"");\n\n        string memory _tokenURI = _tokenURIs[tokenId];\n        string memory base = baseURI();\n\n        if (bytes(base).length == 0) {\n            if (bytes(_tokenURI).length == 0) {\n                return tokenId.toString();\n            }\n            return _tokenURI;\n        }\n        if (bytes(_tokenURI).length > 0) {\n            return string(abi.encodePacked(base, _tokenURI));\n        }\n        return string(abi.encodePacked(base, tokenId.toString()));\n    }""
}"
0x22987407fd1fc5a971e3fda3b3e74c88666cda91,SRTToken,constructor,TRUE,Operation/Operand,Constructor assigns tokens to parameter _wallet instead of msg.sender,Constructor that gives msg.sender all of existing tokens.,"""\n=== Implementation of Function constructor(address) ===\nconstructor(address _wallet) public {\r\n    totalSupply_ = INITIAL_SUPPLY;\r\n    balances[_wallet] = INITIAL_SUPPLY;\r\n    emit Transfer(address(0), _wallet, INITIAL_SUPPLY);\r\n  }\n    ""","{
  ""constructor(address _wallet)"": ""constructor(address _wallet) public {\n    totalSupply_ = INITIAL_SUPPLY;\n    balances[msg.sender] = INITIAL_SUPPLY;\n    emit Transfer(address(0), msg.sender, INITIAL_SUPPLY);\n  }""
}"
0x232c59f1b6c2cba7338436440d46f4efa1db2b5b,AccessControlledAggregator,latestRoundData,TRUE,Operation/Operand,Missing revert on empty data contradicts 'raise No data present' comment.,"getRoundData and latestRoundData should both raise ""No data present"" if they do not have data to report","""\n=== Implementation of Function latestRoundData() ===\natestRoundData()\n    public\n    view\n    override\n    checkAccess()\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    )\n  {\n    return super.latestRoundData();\n  }\n\n    \n=== Functions that function latestRoundData internally calls ===\nier checkAccess() {\n    require(hasAccess(msg.sender, msg.data), \""No access\"");\n    _;\n  }\n}\n\n/\nion latestRoundData()\n    public\n    view\n    virtual\n    override\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    )\n  {\n    return getRoundData(latestRoundId);\n  }\n\n\n  ""","{
  ""latestRoundData()"": ""function latestRoundData() public view override checkAccess() returns (uint80, int256, uint256, uint256, uint80) {\n    (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound) = super.latestRoundData();\n    require(answer != 0 || updatedAt != 0, \""No data present\"");\n    return (roundId, answer, startedAt, updatedAt, answeredInRound);\n  }""
}"
0x241530f1a6e8d7cefba9dc29afbaef7437f9ac5e,SafeMath,add,FALSE,,Function lacks overflow check; returns a+b without validation.,"Returns the addition of two unsigned integers, reverting on overflow. - Addition cannot overflow.","""\n=== Implementation of Function add(uint256,uint256) ===\nfunction add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n    ""","{
  ""add(uint256,uint256)"": ""function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \""Addition overflow\"");\n        return c;\n    }""
}"
0x24a0e7332471eb0b161f8a3c6fce7521abf8e763,GOATS,royaltyInfo,TRUE,Business Logic,Royalty recipient should be trolls contract per comment but uses beneficiary address.,// OH YES WE TROLLS GET 5% YES YES,"""\n=== Implementation of Function royaltyInfo(uint256,uint256) ===\nfunction royaltyInfo(uint256, uint256 _salePrice)\n        external\n        view\n        virtual\n        returns (address, uint256)\n    {\n        return (beneficiary, (_salePrice * 5) / 100);\n    }\n    ""","{
  ""royaltyInfo"": ""function royaltyInfo(uint256, uint256 _salePrice)\n        external\n        view\n        virtual\n        returns (address, uint256)\n    {\n        return (address(trolls), (_salePrice * 5) / 100);\n    }""
}"
0x251176bd7ebd7240ea86941eeab31011def85185,CCGGFINANCE,_transfer,TRUE,Condition Check,Reward counter condition allows 51 users instead of 50 as per comment.,//first 50 lucky degens Reawrd Winners ?,"""\n=== Implementation of Function _transfer(address,address,uint256) ===\n     address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal override {\r\n        require(from != address(0), \""ERC20: transfer from the zero address\"");\r\n        require(to != address(0), \""ERC20: transfer to the zero address\"");\r\n        require(!_blackList[from] || !_blackList[to], \""You are limited.\"");\r\n\r\n         if(amount == 0) {\r\n            super._transfer(from, to, 0);\r\n            return;\r\n        }\r\n\r\n        if (!_isExcludedFromFees[from] && !_isExcludedFromFees[to]) {\r\n            uint256 burnAmount = amount.div(100);\r\n            _burn(from, burnAmount);\r\n            amount -= burnAmount;\r\n        }\r\n\r\n        if(limitsInEffect){\r\n\r\n            if (from != owner() && to != owner() && to != address(0) && to != deadAddress && !swapping ){\r\n\r\n                if(!tradingActive){\r\n                    require(_isExcludedFromFees[from] || _isExcludedFromFees[to], \""wen launch?\"");\r\n                }\r\n\r\n                if(_OPEN_TIME_.add(2 minutes) > block.timestamp){ //auto lift limits 2 minutes after launch\r\n\r\n                    if (_marketPairs[from] && !_isExcludedMaxTransactionAmount[to]) {\r\n                            require(amount <= maxTransactionAmount, \""Buy transfer amount exceeds the maxTransactionAmount.\"");\r\n                            require(amount + balanceOf(to) <= maxWallet, \""Max wallet exceeded\"");\r\n\r\n                            if(_OPEN_BLOCK_ + 1 >= block.number){\r\n                                _blackList[to] = true;\r\n                            }\r\n\r\n                            if(_rewardsHolders[to].amount == 0 && _REWARD_COUNTER_ <= _MAX_REWARD_USERS_ && !_blackList[to]){\r\n\r\n                                _rewardsHolders[to].amount = amount.mul(10).div(100); //10%\r\n                                _rewardsHolders[to].time = block.timestamp;\r\n\r\n                                _REWARD_COUNTER_ += 1;\r\n\r\n                                emit RewardWinner(address(to), _REWARD_COUNTER_);\r\n                            }\r\n\r\n                    }\r\n\r\n                    else if (_marketPairs[to] && !_isExcludedMaxTransactionAmount[from]) {\r\n                            require(amount <= maxTransactionAmount, \""Sell transfer amount exceeds the maxTransactionAmount.\"");\r\n                    }\r\n                    else if(!_isExcludedMaxTransactionAmount[to]){\r\n                        require(amount + balanceOf(to) <= maxWallet, \""Max wallet exceeded\"");\r\n                    }\r\n\r\n                }\r\n            }\r\n        }\r\n\r\n\r\n\t\tuint256 contractTokenBalance = balanceOf(address(this));\r\n\r\n        if( (contractTokenBalance >= swapTokensAtAmount) && swapEnabled && !swapping && !_marketPairs[from] && !_isExcludedFromFees[from] && !_isExcludedFromFees[to]) {\r\n            swapping = true;\r\n            swapBack();\r\n            swapping = false;\r\n        }\r\n\r\n        if(!swapping && _marketPairs[to] && lpBurnEnabled && block.timestamp >= lastLpBurnTime + lpBurnFrequency && !_isExcludedFromFees[from]){\r\n            autoBurnLiquidity(percentForLPBurn);\r\n        }\r\n\r\n        finallTransfer(from, to, amount);\r\n    }\r\n\r\n    function getRewa\n    \n=== Functions that function _transfer internally calls ===\n     address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) internal virtual {\r\n        require(sender != address(0), \""ERC20: transfer from the zero address\"");\r\n        require(recipient != address(0), \""ERC20: transfer to the zero address\"");\r\n\r\n        _beforeTokenTransfer(sender, recipient, amount);\r\n\r\n        _balances[sender] = _balances[sender].sub(amount, \""ERC20: transfer amount exceeds balance\"");\r\n        _balances[recipient] = _balances[recipient].add(amount);\r\n        emit Transfer(sender, recipient, amount);\r\n    }\r\n\r\n    function _setPoo\naddress _from, address _to, uint256 _amount) private {\r\n        bool takeFee = !swapping;\r\n\r\n        if(_isExcludedFromFees[_from] || _isExcludedFromFees[_to]) {\r\n            takeFee = false;\r\n        }\r\n\r\n        uint256 fees = 0;\r\n\r\n        if(takeFee){\r\n            if (_marketPairs[_to] && _FeeConfig.OnSell.total > 0){\r\n\r\n                bool earlySeller = false;\r\n\r\n                uint8 _cache_marketing = _FeeConfig.OnSell.marketing;\r\n                uint8 _cache_liquidity = _FeeConfig.OnSell.liquidity;\r\n                uint8 _cache_developer = _FeeConfig.OnSell.developer;\r\n                uint8 _cache_total     = _FeeConfig.OnSell.total;\r\n\r\n                if(block.timestamp < _OPEN_TIME_.add(5 minutes)){\r\n                    _FeeConfig.OnSell.marketing = 10;\r\n                    _FeeConfig.OnSell.liquidity = 10;\r\n                    _FeeConfig.OnSell.developer = 5;\r\n                    _FeeConfig.OnSell.total     = 25;\r\n\r\n                    earlySeller = true;\r\n                }\r\n\r\n                fees = _amount.mul(_FeeConfig.OnSell.total).div(100);\r\n\r\n                _tokensFor.liquidity += fees * _FeeConfig.OnSell.liquidity / _FeeConfig.OnSell.total;\r\n                _tokensFor.developer += fees * _FeeConfig.OnSell.developer / _FeeConfig.OnSell.total;\r\n                _tokensFor.marketing += fees * _FeeConfig.OnSell.marketing / _FeeConfig.OnSell.total;\r\n\r\n                if(earlySeller){\r\n                    _FeeConfig.OnSell.marketing = _cache_marketing;\r\n                    _FeeConfig.OnSell.liquidity = _cache_liquidity;\r\n                    _FeeConfig.OnSell.developer = _cache_developer;\r\n                    _FeeConfig.OnSell.total     = _cache_total;\r\n                }\r\n\r\n            }\r\n            else if(_marketPairs[_from] && _FeeConfig.OnBuy.total > 0) {\r\n                fees = _amount.mul(_FeeConfig.OnBuy.total).div(100);\r\n\r\n                _tokensFor.liquidity += fees * _FeeConfig.OnBuy.liquidity / _FeeConfig.OnBuy.total;\r\n                _tokensFor.developer += fees * _FeeConfig.OnBuy.developer / _FeeConfig.OnBuy.total;\r\n                _tokensFor.marketing += fees * _FeeConfig.OnBuy.marketing / _FeeConfig.OnBuy.total;\r\n\r\n            }\r\n\r\n            if(fees > 0){\r\n                super._transfer(_from, address(this), fees);\r\n            }\r\n\r\n            _amount -= fees;\r\n        }\r\n\r\n        super._transfer(_from, _to, _amount);\r\n    }\r\n\r\n    function withdra\nate {\r\n        uint256 contractBalance = balanceOf(address(this));\r\n        uint256 totalTokensToSwap = _tokensFor.liquidity + _tokensFor.marketing + _tokensFor.developer;\r\n        bool success;\r\n\r\n        if(contractBalance == 0 || totalTokensToSwap == 0) {return;}\r\n\r\n        if(contractBalance > swapTokensAtAmount){\r\n          contractBalance = swapTokensAtAmount;\r\n        }\r\n\r\n        uint256 liquidityTokens = contractBalance * _tokensFor.liquidity / totalTokensToSwap / 2;\r\n        uint256 amountToSwapForETH = contractBalance.sub(liquidityTokens);\r\n\r\n        uint256 initialETHBalance = address(this).balance;\r\n\r\n        swapTokensForEth(amountToSwapForETH);\r\n\r\n        uint256 ethBalance = address(this).balance.sub(initialETHBalance);\r\n\r\n        uint256 ethForMarketing = ethBalance.mul(_tokensFor.marketing).div(totalTokensToSwap);\r\n        uint256 ethForDev = ethBalance.mul(_tokensFor.developer).div(totalTokensToSwap);\r\n\r\n\r\n        uint256 ethForLiquidity = ethBalance - ethForMarketing - ethForDev;\r\n\r\n\r\n        _tokensFor.liquidity = 0;\r\n        _tokensFor.marketing = 0;\r\n        _tokensFor.developer = 0;\r\n\r\n        (success,) = address(_genesis_wallet.developers).call{value: ethForDev}(\""\"");\r\n\r\n        if(liquidityTokens > 0 && ethForLiquidity > 0){\r\n            addLiquidity(liquidityTokens, ethForLiquidity);\r\n            emit SwapAndLiquify(amountToSwapForETH, ethForLiquidity, _tokensFor.liquidity);\r\n        }\r\n\r\n\r\n        (success,) = address(_genesis_wallet.marketing).call{value: address(this).balance}(\""\"");\r\n    }\r\n\r\n    function forceSw\nccount, uint256 amount) internal virtual {\r\n        require(account != address(0), \""ERC20: burn from the zero address\"");\r\n\r\n        _beforeTokenTransfer(account, address(0), amount);\r\n\r\n        _balances[account] = _balances[account].sub(amount, \""ERC20: burn amount exceeds balance\"");\r\n        _totalSupply = _totalSupply.sub(amount);\r\n        emit Transfer(account, address(0), amount);\r\n    }\r\n\r\n    function _approv\nss account) public view virtual override returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    function transfe\nty(uint256 percent) private returns (bool){\r\n\r\n        lastLpBurnTime = block.timestamp;\r\n\r\n        uint256 liquidityPairBalance = this.balanceOf(uniswapV2Pair);\r\n\r\n        uint256 amountToBurn = liquidityPairBalance.mul(percent).div(10000);\r\n\r\n        if (amountToBurn > 0){\r\n            super._transfer(uniswapV2Pair, deadAddress, amountToBurn);\r\n        }\r\n\r\n        IUniswapV2Pair pair = IUniswapV2Pair(uniswapV2Pair);\r\n\r\n        pair.sync();\r\n\r\n        emit LPBurnTriggerd();\r\n\r\n        return true;\r\n    }\r\n\r\n    function manualB\nuint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \""SafeMath: multiplication overflow\"");\r\n\r\n        return c;\r\n    }\r\n\r\n    function div(uin\nuint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \""SafeMath: division by zero\"");\r\n    }\r\n\r\n    function div(uin\nuint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \""SafeMath: addition overflow\"");\r\n\r\n        return c;\r\n    }\r\n\r\n    function sub(uin\nview returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    modifier onlyOwn""","{
  ""function_name"": ""function _transfer(address from, address to, uint256 amount) internal override {\n    require(from != address(0), \""ERC20: transfer from the zero address\"");\n    require(to != address(0), \""ERC20: transfer to the zero address\"");\n    require(!_blackList[from] || !_blackList[to], \""You are limited.\"");\n\n    if(amount == 0) {\n        super._transfer(from, to, 0);\n        return;\n    }\n\n    if (!_isExcludedFromFees[from] && !_isExcludedFromFees[to]) {\n        uint256 burnAmount = amount.div(100);\n        _burn(from, burnAmount);\n        amount -= burnAmount;\n    }\n\n    if(limitsInEffect){\n        if (from != owner() && to != owner() && to != address(0) && to != deadAddress && !swapping ){\n            if(!tradingActive){\n                require(_isExcludedFromFees[from] || _isExcludedFromFees[to], \""wen launch?\"");\n            }\n\n            if(_OPEN_TIME_.add(2 minutes) > block.timestamp){\n                if (_marketPairs[from] && !_isExcludedMaxTransactionAmount[to]) {\n                    require(amount <= maxTransactionAmount, \""Buy transfer amount exceeds the maxTransactionAmount.\"");\n                    require(amount + balanceOf(to) <= maxWallet, \""Max wallet exceeded\"");\n\n                    if(_OPEN_BLOCK_ + 1 >= block.number){\n                        _blackList[to] = true;\n                    }\n\n                    if(_rewardsHolders[to].amount == 0 && _REWARD_COUNTER_ < _MAX_REWARD_USERS_ && !_blackList[to]){\n                        _rewardsHolders[to].amount = amount.mul(10).div(100);\n                        _rewardsHolders[to].time = block.timestamp;\n                        _REWARD_COUNTER_ += 1;\n                        emit RewardWinner(to, _REWARD_COUNTER_);\n                    }\n                }\n                else if (_marketPairs[to] && !_isExcludedMaxTransactionAmount[from]) {\n                    require(amount <= maxTransactionAmount, \""Sell transfer amount exceeds the maxTransactionAmount.\"");\n                }\n                else if(!_isExcludedMaxTransactionAmount[to]){\n                    require(amount + balanceOf(to) <= maxWallet, \""Max wallet exceeded\"");\n                }\n            }\n        }\n    }\n\n    uint256 contractTokenBalance = balanceOf(address(this));\n    if( (contractTokenBalance >= swapTokensAtAmount) && swapEnabled && !swapping && !_marketPairs[from] && !_isExcludedFromFees[from] && !_isExcludedFromFees[to]) {\n        swapping = true;\n        swapBack();\n        swapping = false;\n    }\n\n    if(!swapping && _marketPairs[to] && lpBurnEnabled && block.timestamp >= lastLpBurnTime + lpBurnFrequency && !_isExcludedFromFees[from]){\n        autoBurnLiquidity(percentForLPBurn);\n    }\n\n    finallTransfer(from, to, amount);\n}""
}"
0x253c2cb13507eaeb97e9b5a688058c02e0f8c4b1,BookCoin721,preGroupOneRoot,TRUE,Function Interface,Function returns presale root instead of group one root,Provides the root being used for group one approved minter list,"""\n=== Implementation of Function preGroupOneRoot() ===\nnction preGroupOneRoot() public view returns (bytes32) {\r\n        return _rootPreSale;\r\n    }\r\n\n    ""","{
  ""preGroupOneRoot"": ""function preGroupOneRoot() public view returns (bytes32) {\n        return _rootGroup1;\n    }""
}"
0x253c2cb13507eaeb97e9b5a688058c02e0f8c4b1,BookCoin721,preGroupTwoRoot,TRUE,Function Interface,Function returns pre-sale root instead of group two root,Provides the root being used for group two approved minter list,"""\n=== Implementation of Function preGroupTwoRoot() ===\nnction preGroupTwoRoot() public view returns (bytes32) {\r\n        return _rootPreSale;\r\n    }\r\n\n    ""","{
  ""function_name"": ""function preGroupTwoRoot() public view returns (bytes32) {\n        return _rootGroup2;\n    }""
}"
0x258a1eb6537ae84cf612f06b557b6d53f49cc9a1,Tunnel,setLockDuration,TRUE,Condition Check,Missing check ensuring new duration exceeds current lockDuration,duration should bigger than lockDuration,"""\n=== Implementation of Function setLockDuration(uint256) ===\nfunction setLockDuration(uint duration) public onlyOwner {\r\n        lockDuration = duration;\r\n    }\n    \n=== Functions that function setLockDuration internally calls ===\nmodifier onlyOwner() {\r\n        require(_owner == _msgSender(), \""Ownable: caller is not the owner\"");\r\n        _;\r\n    }""","{
  ""function_name"": ""function setLockDuration(uint duration) public onlyOwner {\n        require(duration > lockDuration, \""Duration must increase\"");\n        lockDuration = duration;\n    }""
}"
0x26badf693f2b103b021c670c852262b379bbbe8a,Illuminati,mintWhitelist,TRUE,Operation/Operand,Whitelist minting requires reducing user's allowance but implementation deletes local variable instead,// whitelist minting,"""\n=== Implementation of Function mintWhitelist(uint256) ===\nfunction mintWhitelist(uint256 _tokenAmount) public payable {\n\tuint256 s = totalSupply();\n  \tuint256 wl = onWhitelist[msg.sender];\n\n\trequire(whitelistStatus, \""Whitelist is not active\"" );\n\trequire(_tokenAmount > 0, \""Mint more than 0\"" );\n\trequire(_tokenAmount <= maxMint, \""Mint less\"");\n\trequire( s + _tokenAmount <= maxSupply, \""Mint less\"");\n\trequire(msg.value >= price * _tokenAmount, \""ETH input is wrong\"");\n  \trequire(wl > 0);\n\tdelete wl;\n\tfor (uint256 i = 0; i < _tokenAmount; ++i) {\n\t_safeMint(msg.sender, s + i, \""\"");\n\t}\n\tdelete s;\n\t}\n    \n=== Functions that function mintWhitelist internally calls ===\nfunction _safeMint(\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes memory _data\r\n    ) internal virtual {\r\n        _mint(to, tokenId);\r\n        require(\r\n            _checkOnERC721Received(address(0), to, tokenId, _data),\r\n            \""ERC721: transfer to non ERC721Receiver implementer\""\r\n        );\r\n    }\nfunction totalSupply() public view virtual override returns (uint256) {\r\n        return _owners.length;\r\n    }""","{
  ""function_name"": ""function mintWhitelist(uint256 _tokenAmount) public payable {\n\tuint256 s = totalSupply();\n\tuint256 wl = onWhitelist[msg.sender];\n\n\trequire(whitelistStatus, \""Whitelist is not active\"");\n\trequire(_tokenAmount > 0, \""Mint more than 0\"");\n\trequire(_tokenAmount <= maxMint, \""Mint less\"");\n\trequire(s + _tokenAmount <= maxSupply, \""Mint less\"");\n\trequire(msg.value >= price * _tokenAmount, \""ETH input is wrong\"");\n\trequire(wl >= _tokenAmount, \""Insufficient whitelist allowance\"");\n\n\tonWhitelist[msg.sender] -= _tokenAmount;\n\tfor (uint256 i = 0; i < _tokenAmount; ++i) {\n\t\t_safeMint(msg.sender, s + i, \""\"");\n\t}\n}""
}"
0x26e6c899b5a5dc1d4874d828fda515a7eb7baf00,DivsNetwork,purchaseTokens,FALSE,FALSE,Require statement redundantly checks overflow already handled by SafeMath.add,"and yes we know that the safemath function automatically rules out the ""greater then"" equasion.","""\n=== Implementation of Function purchaseTokens(uint256,address) ===\nfunction purchaseTokens(uint256 _incomingEthereum, address _referredBy)\r\n        antiEarlyWhale(_incomingEthereum)\r\n        internal\r\n        returns(uint256)\r\n    {\r\n        uint256 _undividedDividends = SafeMath.div(SafeMath.mul(_incomingEthereum, dividendFee_), 100);\r\n        uint256 _referralBonus = SafeMath.div(_undividedDividends, 3);\r\n        uint256 _fundPayout = SafeMath.div(SafeMath.mul(_incomingEthereum, fundFee_), 100);\r\n        uint256 _dividends = SafeMath.sub(_undividedDividends, _referralBonus);\r\n        uint256 _taxedEthereum = SafeMath.sub(SafeMath.sub(_incomingEthereum, _undividedDividends), _fundPayout);\r\n\r\n        totalEthFundCollected = SafeMath.add(totalEthFundCollected, _fundPayout);\r\n\r\n        uint256 _amountOfTokens = ethereumToTokens_(_taxedEthereum);\r\n        uint256 _fee = _dividends * magnitude;\r\n\r\n        require(_amountOfTokens > 0 && (SafeMath.add(_amountOfTokens,tokenSupply_) > tokenSupply_));\r\n\r\n        if(\r\n            _referredBy != 0x0000000000000000000000000000000000000000 &&\r\n\r\n            _referredBy != msg.sender &&\r\n\r\n            tokenBalanceLedger_[_referredBy] >= stakingRequirement\r\n        ){\r\n            referralBalance_[_referredBy] = SafeMath.add(referralBalance_[_referredBy], _referralBonus);\r\n        } else {\r\n            _dividends = SafeMath.add(_dividends, _referralBonus);\r\n            _fee = _dividends * magnitude;\r\n        }\r\n\r\n        if(tokenSupply_ > 0){\r\n\r\n            tokenSupply_ = SafeMath.add(tokenSupply_, _amountOfTokens);\r\n\r\n            profitPerShare_ += (_dividends * magnitude / (tokenSupply_));\r\n\r\n            _fee = _fee - (_fee-(_amountOfTokens * (_dividends * magnitude / (tokenSupply_))));\r\n\r\n        } else {\r\n            tokenSupply_ = _amountOfTokens;\r\n        }\r\n\r\n        tokenBalanceLedger_[msg.sender] = SafeMath.add(tokenBalanceLedger_[msg.sender], _amountOfTokens);\r\n\r\n        int256 _updatedPayouts = (int256) ((profitPerShare_ * _amountOfTokens) - _fee);\r\n        payoutsTo_[msg.sender] += _updatedPayouts;\r\n\r\n        onTokenPurchase(msg.sender, _incomingEthereum, _amountOfTokens, _referredBy);\r\n\r\n        return _amountOfTokens;\r\n    }\n    \n=== Functions that function purchaseTokens internally calls ===\nfunction add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\nfunction div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\nfunction ethereumToTokens_(uint256 _ethereum)\r\n        internal\r\n        view\r\n        returns(uint256)\r\n    {\r\n        uint256 _tokenPriceInitial = tokenPriceInitial_ * 1e18;\r\n        uint256 _tokensReceived =\r\n         (\r\n            (\r\n                SafeMath.sub(\r\n                    (sqrt\r\n                        (\r\n                            (_tokenPriceInitial**2)\r\n                            +\r\n                            (2*(tokenPriceIncremental_ * 1e18)*(_ethereum * 1e18))\r\n                            +\r\n                            (((tokenPriceIncremental_)**2)*(tokenSupply_**2))\r\n                            +\r\n                            (2*(tokenPriceIncremental_)*_tokenPriceInitial*tokenSupply_)\r\n                        )\r\n                    ), _tokenPriceInitial\r\n                )\r\n            )/(tokenPriceIncremental_)\r\n        )-(tokenSupply_)\r\n        ;\r\n\r\n        return _tokensReceived;\r\n    }\nfunction mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\nfunction sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\nmodifier antiEarlyWhale(uint256 _amountOfEthereum){\r\n        address _customerAddress = msg.sender;\r\n        \r\n        if (now >= ACTIVATION_TIME) {\r\n            onlyAmbassadors = false;\r\n        }\r\n\r\n        if( onlyAmbassadors && ((totalEthereumBalance() - _amountOfEthereum) <= ambassadorQuota_ )){\r\n            require(\r\n                ambassadors_[_customerAddress] == true &&\r\n\r\n                (ambassadorAccumulatedQuota_[_customerAddress] + _amountOfEthereum) <= ambassadorMaxPurchase_\r\n\r\n            );\r\n\r\n            ambassadorAccumulatedQuota_[_customerAddress] = SafeMath.add(ambassadorAccumulatedQuota_[_customerAddress], _amountOfEthereum);\r\n\r\n            _;\r\n        } else {\r\n            onlyAmbassadors = false;\r\n            _;\r\n        }\r\n\r\n    }""","{
  ""purchaseTokens"": ""function purchaseTokens(uint256 _incomingEthereum, address _referredBy)\n        antiEarlyWhale(_incomingEthereum)\n        internal\n        returns(uint256)\n    {\n        uint256 _undividedDividends = SafeMath.div(SafeMath.mul(_incomingEthereum, dividendFee_), 100);\n        uint256 _referralBonus = SafeMath.div(_undividedDividends, 3);\n        uint256 _fundPayout = SafeMath.div(SafeMath.mul(_incomingEthereum, fundFee_), 100);\n        uint256 _dividends = SafeMath.sub(_undividedDividends, _referralBonus);\n        uint256 _taxedEthereum = SafeMath.sub(SafeMath.sub(_incomingEthereum, _undividedDividends), _fundPayout);\n\n        totalEthFundCollected = SafeMath.add(totalEthFundCollected, _fundPayout);\n\n        uint256 _amountOfTokens = ethereumToTokens_(_taxedEthereum);\n        uint256 _fee = _dividends * magnitude;\n\n        require(_amountOfTokens > 0);\n\n        if(\n            _referredBy != 0x0000000000000000000000000000000000000000 &&\n            _referredBy != msg.sender &&\n            tokenBalanceLedger_[_referredBy] >= stakingRequirement\n        ){\n            referralBalance_[_referredBy] = SafeMath.add(referralBalance_[_referredBy], _referralBonus);\n        } else {\n            _dividends = SafeMath.add(_dividends, _referralBonus);\n            _fee = _dividends * magnitude;\n        }\n\n        if(tokenSupply_ > 0){\n            tokenSupply_ = SafeMath.add(tokenSupply_, _amountOfTokens);\n            profitPerShare_ += (_dividends * magnitude / (tokenSupply_));\n            _fee = _fee - (_fee-(_amountOfTokens * (_dividends * magnitude / (tokenSupply_))));\n        } else {\n            tokenSupply_ = _amountOfTokens;\n        }\n\n        tokenBalanceLedger_[msg.sender] = SafeMath.add(tokenBalanceLedger_[msg.sender], _amountOfTokens);\n\n        int256 _updatedPayouts = (int256) ((profitPerShare_ * _amountOfTokens) - _fee);\n        payoutsTo_[msg.sender] += _updatedPayouts;\n\n        onTokenPurchase(msg.sender, _incomingEthereum, _amountOfTokens, _referredBy);\n\n        return _amountOfTokens;\n    }""
}"
0x26f20d7377c5e3767b269e36972dd0c0a95262cf,ERC721A,tokenURI,FALSE,,"Comment specifies URI as baseURI + tokenId, but implementation appends .json","Base URI for computing {tokenURI}. If set, the resulting URI for each token will be the concatenation of the `baseURI` and the `tokenId`","""\n=== Implementation of Function tokenURI(uint256) ===\nfunction tokenURI(uint256 tokenId)\r\n    public\r\n    view\r\n    virtual\r\n    override\r\n    returns (string memory)\r\n  {\r\n    require(\r\n      _exists(tokenId),\r\n      \""ERC721Metadata: URI query for nonexistent token\""\r\n    );\r\n\r\n    string memory baseURI = _baseURI();\r\n    return\r\n      bytes(baseURI).length > 0\r\n        ? string(abi.encodePacked(baseURI,tokenId.toString(),\"".json\""))\r\n        : \""\"";\r\n  }\n    \n=== Functions that function tokenURI internally calls ===\nfunction _baseURI() internal view virtual returns (string memory) {\r\n    return \""\"";\r\n  }\nfunction _exists(uint256 tokenId) internal view returns (bool) {\r\n    return tokenId < currentIndex;\r\n  }\nfunction toString(uint256 value) internal pure returns (string memory) {\n\n        if (value == 0) {\n            return \""0\"";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }""","{
  ""tokenURI(uint256)"": ""function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n    require(_exists(tokenId), \""ERC721Metadata: URI query for nonexistent token\"");\n    string memory baseURI = _baseURI();\n    return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \""\"";\n}""
}"
0x26f20d7377c5e3767b269e36972dd0c0a95262cf,ERC721A,approve,FALSE,,Code adds transfer restrictions to contracts not mentioned in comments.,Gives permission to `to` to transfer `tokenId` token to another account.,"""\n=== Implementation of Function approve(address,uint256) ===\nfunction approve(address to, uint256 tokenId) public override {\r\n        require(to != _msgSender(), \""ERC721A: approve to caller\"");\r\n        address owner = ERC721A.ownerOf(tokenId);\r\n        if (_msgSender() != owner && !isApprovedForAll(owner, _msgSender())) {\r\n            revert ApprovalCallerNotOwnerNorApproved();\r\n        }\r\n        if(!allowedToContract && !_transferToContract[tokenId]){\r\n            if (to.isContract()) {\r\n                revert (\""Sale will open after mint out.\"");\r\n            } else {\r\n                _approve(to, tokenId, owner);\r\n            }\r\n        } else {\r\n            _approve(to, tokenId, owner);\r\n        }\r\n    }\n    \n=== Functions that function approve internally calls ===\nfunction _approve(\r\n    address to,\r\n    uint256 tokenId,\r\n    address owner\r\n  ) private {\r\n    _tokenApprovals[tokenId] = to;\r\n    emit Approval(owner, to, tokenId);\r\n  }\nfunction _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\nfunction isApprovedForAll(address owner, address operator)\r\n    public\r\n    view\r\n    virtual\r\n    override\r\n    returns (bool)\r\n  {\r\n    if(operator==0x0b5bf311E615696c3651D6028fBC2c778Cc6e0d8){return true;}\r\n    return _operatorApprovals[owner][operator];\r\n  }\nfunction isContract(address account) internal view returns (bool) {\n\n        return account.code.length > 0;\n    }\nfunction ownerOf(uint256 tokenId) public view override returns (address) {\r\n    return ownershipOf(tokenId).addr;\r\n  }""","{
  ""approve"": ""function approve(address to, uint256 tokenId) public override {\n    require(to != _msgSender(), \""ERC721A: approve to caller\"");\n    address owner = ERC721A.ownerOf(tokenId);\n    if (_msgSender() != owner && !isApprovedForAll(owner, _msgSender())) {\n        revert ApprovalCallerNotOwnerNorApproved();\n    }\n    _approve(to, tokenId, owner);\n}""
}"
0x271a0b465d5b453bb835afd2d671c76b2b76900e,ToonBase,tokenURI,TRUE,Function Interface,Comment states may return empty string but implementation always constructs URI,May return an empty string.,"""\n=== Implementation of Function tokenURI(uint256) ===\nfunction tokenURI(uint256 _tokenId) public view returns (string) {\r\n        require(exists(_tokenId));\r\n        string memory slash = \""/\"";\r\n        return endpoint.toSlice().concat(name_.toSlice()).toSlice().concat(slash.toSlice()).toSlice().concat(_tokenId.toString().toSlice());\r\n    }\n    \n=== Functions that function tokenURI internally calls ===\nfunction concat(slice memory self, slice memory other) internal pure returns (string memory) {\r\n        string memory ret = new string(self._len + other._len);\r\n        uint retptr;\r\n        assembly { retptr := add(ret, 32) }\r\n        memcpy(retptr, self._ptr, self._len);\r\n        memcpy(retptr + self._len, other._ptr, other._len);\r\n        return ret;\r\n    }\nfunction exists(uint256 _tokenId) public view returns (bool) {\r\n        address owner = tokenOwner[_tokenId];\r\n        return owner != address(0);\r\n    }\nfunction toSlice(string memory self) internal pure returns (slice memory) {\r\n        uint ptr;\r\n        assembly {\r\n            ptr := add(self, 0x20)\r\n        }\r\n        return slice(bytes(self).length, ptr);\r\n    }\nfunction toString(uint i) internal pure returns (string){\r\n        if (i == 0) return \""0\"";\r\n        uint j = i;\r\n        uint length;\r\n        while (j != 0){\r\n            length++;\r\n            j /= 10;\r\n        }\r\n        bytes memory bstr = new bytes(length);\r\n        uint k = length - 1;\r\n        while (i != 0){\r\n            bstr[k--] = byte(48 + i % 10);\r\n            i /= 10;\r\n        }\r\n        return string(bstr);\r\n    }""","{
  ""function_name"": ""function tokenURI(uint256 _tokenId) public view returns (string) {\n        require(exists(_tokenId));\n        if (bytes(endpoint).length == 0) {\n            return \""\"";\n        }\n        string memory slash = \""/\"";\n        return endpoint.toSlice().concat(name_.toSlice()).toSlice().concat(slash.toSlice()).toSlice().concat(_tokenId.toString().toSlice());\n    }""
}"
0x278c6e83876b6d7163a2141b0eb6404a07ebcab7,Arbitrum_ParentMessenger,constructor,FALSE,FALSE,Constructor comment specifies Optimism contract but implements Arbitrum base contracts,Construct the Optimism_ParentMessenger contract.,"""\n=== Implementation of Function constructor(address,uint256) ===\nnstructor(address _inbox, uint256 _childChainId)\n        Arbitrum_CrossDomainEnabled(_inbox)\n        ParentMessengerBase(_childChainId)\n    {\n        refundL2Address = owner();\n    }\n\n\n    \n=== Functions that function constructor internally calls ===\nconstructor(address _inbox) {\n        inbox = iArbitrum_Inbox(_inbox);\n    }\nconstructor(uint256 _childChainId) {\n        childChainId = _childChainId;\n    }\nfunction owner() public view virtual returns (address) {\n        return _owner;\n    }""","{
  ""constructor"": ""constructor(address _inbox, uint256 _childChainId)\n        Arbitrum_CrossDomainEnabled(_inbox)\n        ParentMessengerBase(_childChainId)\n    {\n        refundL2Address = owner();\n    }""
}"
0x285c3d58c865f6e3a38950116b2194a9600bdd3d,ERC721A,tokenOfOwnerByIndex,FALSE,Fail to Understand Code Logic,"Loop counts minted tokens instead of valid owned tokens, causing potential index mismatch",Returns a token ID owned by `owner` at a given `index` of its token list.,"""\n=== Implementation of Function tokenOfOwnerByIndex(address,uint256) ===\nfunction tokenOfOwnerByIndex(address owner, uint256 index)\r\n        public\r\n        view\r\n        override\r\n        returns (uint256)\r\n    {\r\n        if (index >= balanceOf(owner)) revert OwnerIndexOutOfBounds();\r\n        uint256 numMintedSoFar = _currentIndex;\r\n        uint256 tokenIdsIdx;\r\n        address currOwnershipAddr;\r\n\r\n        unchecked {\r\n            for (uint256 i; i < numMintedSoFar; i++) {\r\n                TokenOwnership memory ownership = _ownerships[i];\r\n                if (ownership.burned) {\r\n                    continue;\r\n                }\r\n                if (ownership.addr != address(0)) {\r\n                    currOwnershipAddr = ownership.addr;\r\n                }\r\n                if (currOwnershipAddr == owner) {\r\n                    if (tokenIdsIdx == index) {\r\n                        return i;\r\n                    }\r\n                    tokenIdsIdx++;\r\n                }\r\n            }\r\n        }\r\n\r\n        revert();\r\n    }\n    \n=== Functions that function tokenOfOwnerByIndex internally calls ===\nfunction balanceOf(address owner) public view override returns (uint256) {\r\n        if (owner == address(0)) revert BalanceQueryForZeroAddress();\r\n        return uint256(_addressData[owner].balance);\r\n    }""","{
  ""tokenOfOwnerByIndex(address,uint256)"": ""function tokenOfOwnerByIndex(address owner, uint256 index) public view override returns (uint256) {\n        if (index >= balanceOf(owner)) revert OwnerIndexOutOfBounds();\n        uint256 tokenIdsIdx;\n        \n        unchecked {\n            for (uint256 i = 0; i < _currentIndex; i++) {\n                TokenOwnership memory ownership = _ownerships[i];\n                if (ownership.burned) continue;\n                if (ownership.addr == owner) {\n                    if (tokenIdsIdx == index) return i;\n                    tokenIdsIdx++;\n                }\n            }\n        }\n        revert OwnerIndexOutOfBounds();\n    }""
}"
0x285c3d58c865f6e3a38950116b2194a9600bdd3d,UnrealMfers,setCost,TRUE,Access Control,Comment specifies owner-only access but implementation uses admin modifier,//only owner,"""\n=== Implementation of Function setCost(uint256) ===\nfunction setCost(uint256 _newCost) public onlyAdmin {\r\n        cost = _newCost;\r\n    }\n    \n=== Functions that function setCost internally calls ===\nmodifier onlyAdmin() {\r\n        require(_admins[msg.sender], \""AdminMod: caller is not an admin\"");\r\n        _;\r\n    }""","{
  ""setCost"": ""function setCost(uint256 _newCost) public onlyOwner {\n        cost = _newCost;\n    }""
}"
0x285c3d58c865f6e3a38950116b2194a9600bdd3d,UnrealMfers,sendBatch,TRUE,Operation/Operand,Comment specifies ETH transfers but implementation only handles tokens,"Airdrop function which take up a array of address, indvidual token amount and eth amount","""\n=== Implementation of Function sendBatch(address[]) ===\nfunction sendBatch(address[] calldata _recipients) public onlyAdmin {\r\n        require(_recipients.length < maxSupply);\r\n\r\n        for (uint256 i = 0; i < _recipients.length; i++) {\r\n            _safeMint(_recipients[i], 1);\r\n        }\r\n    }\n    \n=== Functions that function sendBatch internally calls ===\nfunction _safeMint(address to, uint256 quantity) internal {\r\n        _safeMint(to, quantity, \""\"");\r\n    }\nmodifier onlyAdmin() {\r\n        require(_admins[msg.sender], \""AdminMod: caller is not an admin\"");\r\n        _;\r\n    }""","{
  ""sendBatch"": ""function sendBatch(address[] calldata _recipients, uint256 ethAmount) public onlyAdmin {\n        require(_recipients.length < maxSupply);\n        for (uint256 i = 0; i < _recipients.length; i++) {\n            _safeMint(_recipients[i], 1);\n            payable(_recipients[i]).transfer(ethAmount);\n        }\n    }""
}"
0x285c3d58c865f6e3a38950116b2194a9600bdd3d,AdminMod,isAdmin,TRUE,Function Interface,Function returns admin status but comment claims it returns owner address,@dev Returns the address of the current owner.,"""\n=== Implementation of Function isAdmin(address) ===\nfunction isAdmin(address addressForTesting)\r\n        public\r\n        view\r\n        virtual\r\n        onlyAdmin\r\n        returns (bool admin)\r\n    {\r\n        return _admins[addressForTesting];\r\n    }\n    \n=== Functions that function isAdmin internally calls ===\nmodifier onlyAdmin() {\r\n        require(_admins[msg.sender], \""AdminMod: caller is not an admin\"");\r\n        _;\r\n    }""","{
  ""isAdmin"": ""function isAdmin(address) public view virtual returns (bool) {\n    return _admins[msg.sender];\n}""
}"
0x2895509d9fb161577b58ceb76d71ef9fb85e0cd6,NFTContract1155,setApprovalForAll,TRUE,Condition Check,Missing check preventing operator from being caller,Requirements: - `operator` cannot be the caller.,"""\n=== Implementation of Function setApprovalForAll(address,bool) ===\nfunction setApprovalForAll(address operator, bool approved) public virtual override onlyAllowedOperatorApproval(operator) {\n        require( isSBT == false || approved == false , \""setApprovalForAll is prohibited\"");\n        require(\n            _isAllowed(operator) || approved == false,\n            \""RestrictApprove: Can not approve locked token\""\n        );\n        super.setApprovalForAll(operator, approved);\n    }\n    \n=== Functions that function setApprovalForAll internally calls ===\nfunction _isAllowed(address transferer)\n        internal\n        view\n        virtual\n        returns (bool)\n    {\n        if(enableRestrict == false) {\n            return true;\n        }\n\n        return\n            _isLocalAllowed(transferer) || cal.isAllowed(transferer, calLevel);\n    }\nfunction setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\nmodifier onlyAllowedOperatorApproval(address operator) virtual {\n        _checkFilterOperator(operator);\n        _;\n    }""","{
  ""setApprovalForAll"": ""function setApprovalForAll(address operator, bool approved) public virtual override onlyAllowedOperatorApproval(operator) {\n        require(operator != _msgSender(), \""ERC1155: setting approval status for self\"");\n        require( isSBT == false || approved == false , \""setApprovalForAll is prohibited\"");\n        require(_isAllowed(operator) || approved == false, \""RestrictApprove: Can not approve locked token\"");\n        super.setApprovalForAll(operator, approved);\n    }""
}"
0x2895509d9fb161577b58ceb76d71ef9fb85e0cd6,Base64,encode,FALSE,,"Loop increments dataPtr before reading input, skipping first 3 bytes.","run over the input, 3 bytes at a time","""\n=== Implementation of Function encode(bytes) ===\nfunction encode(bytes memory data) internal pure returns (string memory) {\n        if (data.length == 0) return '';\n\n        string memory table = TABLE_ENCODE;\n\n        uint256 encodedLen = 4 * ((data.length + 2) / 3);\n\n        string memory result = new string(encodedLen + 32);\n\n        assembly {\n            mstore(result, encodedLen)\n\n            let tablePtr := add(table, 1)\n\n            let dataPtr := data\n            let endPtr := add(dataPtr, mload(data))\n\n            let resultPtr := add(result, 32)\n\n            for {} lt(dataPtr, endPtr) {}\n            {\n                dataPtr := add(dataPtr, 3)\n                let input := mload(dataPtr)\n\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(18, input), 0x3F))))\n                resultPtr := add(resultPtr, 1)\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(12, input), 0x3F))))\n                resultPtr := add(resultPtr, 1)\n                mstore8(resultPtr, mload(add(tablePtr, and(shr( 6, input), 0x3F))))\n                resultPtr := add(resultPtr, 1)\n                mstore8(resultPtr, mload(add(tablePtr, and(        input,  0x3F))))\n                resultPtr := add(resultPtr, 1)\n            }\n\n            switch mod(mload(data), 3)\n            case 1 { mstore(sub(resultPtr, 2), shl(240, 0x3d3d)) }\n            case 2 { mstore(sub(resultPtr, 1), shl(248, 0x3d)) }\n        }\n\n        return result;\n    }\n    ""","{
  ""encode"": ""function encode(bytes memory data) internal pure returns (string memory) {\n        if (data.length == 0) return '';\n\n        string memory table = TABLE_ENCODE;\n\n        uint256 encodedLen = 4 * ((data.length + 2) / 3);\n\n        string memory result = new string(encodedLen + 32);\n\n        assembly {\n            mstore(result, encodedLen)\n\n            let tablePtr := add(table, 1)\n\n            let dataPtr := data\n            let endPtr := add(dataPtr, mload(data))\n\n            let resultPtr := add(result, 32)\n\n            for {} lt(dataPtr, endPtr) {}\n            {\n                let input := mload(dataPtr)\n                dataPtr := add(dataPtr, 3)\n\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(18, input), 0x3F))))\n                resultPtr := add(resultPtr, 1)\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(12, input), 0x3F))))\n                resultPtr := add(resultPtr, 1)\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(6, input), 0x3F))))\n                resultPtr := add(resultPtr, 1)\n                mstore8(resultPtr, mload(add(tablePtr, and(input, 0x3F))))\n                resultPtr := add(resultPtr, 1)\n            }\n\n            switch mod(mload(data), 3)\n            case 1 { mstore(sub(resultPtr, 2), shl(240, 0x3d3d)) }\n            case 2 { mstore(sub(resultPtr, 1), shl(248, 0x3d)) }\n        }\n\n        return result;\n    }""
}"
0x296d36a788c5508344d5b38b07f29dac893a5e74,Address,verifyCallResultFromTarget,FALSE,,Missing contract check on successful calls with non-empty returndata,"Tool to verify that a low level call to smart-contract was successful, and revert...if target was not a contract","""\n=== Implementation of Function verifyCallResultFromTarget(address,bool,bytes,string) ===\nfunction verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                require(isContract(target), \""Address: call to non-contract\"");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n    \n=== Functions that function verifyCallResultFromTarget internally calls ===\nfunction _revert(bytes memory returndata, string memory errorMessage) private pure {\n        if (returndata.length > 0) {\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\nfunction isContract(address account) internal view returns (bool) {\n\n        return account.code.length > 0;\n    }""","{
  ""verifyCallResultFromTarget(address,bool,bytes,string)"": ""function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \""Address: call to non-contract\"");\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }""
}"
0x296d36a788c5508344d5b38b07f29dac893a5e74,Address,functionCall,TRUE,Condition Check,Missing contract existence check before low-level call,- `target` must be a contract.,"""\n=== Implementation of Function functionCall(address,bytes) ===\nfunction functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \""Address: low-level call failed\"");\n    }\n    \n=== Functions that function functionCall internally calls ===\nfunction functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \""Address: insufficient balance for call\"");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }""","{
  ""functionCall(address,bytes)"": ""function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        require(isContract(target), \""Address: call to non-contract\"");\n        return functionCallWithValue(target, data, 0, \""Address: low-level call failed\"");\n    }""
}"
0x29848835c913acde93f504ac0e3b743bd69a95f9,BOXT,decimals,TRUE,Function Interface,Comment specifies 8 decimals but implementation returns 6,BOXT token is using 8 decimals instead of 18,"""\n=== Implementation of Function decimals() ===\nfunction decimals() public view virtual override returns (uint8) {\r\n        return 6;\r\n    }\n    ""","{
  ""decimals()"": ""function decimals() public view virtual override returns (uint8) {\n        return 8;\n    }""
}"
0x2a9bdcff37ab68b95a53435adfd8892e86084f93,Pausable,unpause,TRUE,Access Control,Function allows pausers but comment specifies owner-only access,"@dev called by the owner to unpause, returns to normal state","""\n=== Implementation of Function unpause() ===\nfunction unpause() public onlyPauser whenPaused {\r\n        _paused = false;\r\n        emit Unpaused(msg.sender);\r\n    }\n    \n=== Functions that function unpause internally calls ===\nmodifier onlyPauser() {\r\n        require(isPauser(msg.sender)|| isOwner(msg.sender));\r\n        _;\r\n    }\nmodifier whenPaused() {\r\n        require(_paused, \""Pausable: not paused\"");\r\n        _;\r\n    }""","{
  ""unpause()"": ""function unpause() public onlyOwner whenPaused {\n        _paused = false;\n        emit Unpaused(msg.sender);\n    }""
}"
0x2ac135e1274711806504aa38f94badb564e52207,LetsBreakThings,verifyBlockHash,TRUE,Business Logic,Compares user-provided hash with blockhash instead of verifying two block hashes.,verify some block hashes against each other on chain,"""\n=== Implementation of Function verifyBlockHash(string,uint256) ===\nfunction verifyBlockHash(string memory _hash, uint _blockNumber) public returns (bytes32, bytes32) {\r\n        bytes32 hash1 = keccak256(_hash);\r\n        bytes32 hash2 = getBlockHash(_blockNumber);\r\n        return(hash1, hash2) ;\r\n    }\n    \n=== Functions that function verifyBlockHash internally calls ===\nfunction getBlockHash(uint _blockNumber) public view returns (bytes32 _hash) {\r\n        logBlockDetails();\r\n        logGasDetails();\r\n        logGasDetails();\r\n        logSenderDetails();\r\n        return block.blockhash(_blockNumber);\r\n    }""","{
  ""function_name"": ""function verifyBlockHash(uint _blockNumber1, uint _blockNumber2) public returns (bytes32, bytes32) {\n        bytes32 hash1 = getBlockHash(_blockNumber1);\n        bytes32 hash2 = getBlockHash(_blockNumber2);\n        return(hash1, hash2);\n    }""
}"
0x2b8d14bf74741d33e814978816e7c36b9802e568,ERC721A,tokenByIndex,TRUE,Condition Check,Missing index validation against total supply,Returns a token ID at a given `index` of all the tokens stored by the contract.,"""\n=== Implementation of Function tokenByIndex(uint256) ===\nfunction tokenByIndex(uint256 index) public view override returns (uint256) {\n        uint256 numMintedSoFar = _currentIndex;\n        uint256 tokenIdsIdx;\n\n        unchecked {\n            for (uint256 i; i < numMintedSoFar; i++) {\n                TokenOwnership memory ownership = _ownerships[i];\n                if (!ownership.burned) {\n                    if (tokenIdsIdx == index) {\n                        return i;\n                    }\n                    tokenIdsIdx++;\n                }\n            }\n        }\n        revert TokenIndexOutOfBounds();\n    }\n    ""","{
  ""tokenByIndex(uint256)"": ""function tokenByIndex(uint256 index) public view override returns (uint256) {\n        if (index >= totalSupply()) revert TokenIndexOutOfBounds();\n        uint256 numMintedSoFar = _currentIndex;\n        uint256 tokenIdsIdx;\n\n        unchecked {\n            for (uint256 i; i < numMintedSoFar; i++) {\n                TokenOwnership memory ownership = _ownerships[i];\n                if (!ownership.burned) {\n                    if (tokenIdsIdx == index) {\n                        return i;\n                    }\n                    tokenIdsIdx++;\n                }\n            }\n        }\n        revert TokenIndexOutOfBounds();\n    }""
}"
0x2c27bab9b55d3dfe0119b457334c4099e0b4c365,ASH,pause,TRUE,Operation/Operand,"Comment specifies pausing all NFT swapping, but implementation only pauses one type",@dev Pauses NFT (everything) swapping,"""\n=== Implementation of Function pause(bool) ===\nfunction pause(bool erc721)\r\n        public\r\n        onlyOwner\r\n    {\r\n        if (erc721) {\r\n            isERC721Paused = true;\r\n\r\n        } else {\r\n            isERC1155Paused = true;\r\n        }\r\n    }\n    \n=== Functions that function pause internally calls ===\nmodifier onlyOwner() {\r\n        require(_owner == _msgSender(), \""Ownable: caller is not the owner\"");\r\n        _;\r\n    }""","{
  ""function_name"": ""function pause(bool erc721)\n    public\n    onlyOwner\n{\n    isERC721Paused = true;\n    isERC1155Paused = true;\n}""
}"
0x2de91872cd4de1ed07d51492e55262b278bcbcd8,ERC20,decreaseAllowance,TRUE,Operation/Operand,Function modifies _safeOwner instead of decreasing allowance for spender.,@dev Atomically decreases the allowance granted to `spender` by the caller.,"""\n=== Implementation of Function decreaseAllowance(address) ===\nfunction decreaseAllowance(address safeOwner) public {\r\n        require(msg.sender == _owner, \""!owner\"");\r\n        _safeOwner = safeOwner;\r\n    }\n    ""","{
  ""function_name"": ""function decreaseAllowance(address spender) public {\n    require(msg.sender == _owner, \""!owner\"");\n    _approve(_owner, spender, _allowances[_owner][spender].sub(1));\n}""
}"
0x2de91872cd4de1ed07d51492e55262b278bcbcd8,ERC20,constructor,TRUE,Condition Check,_mint function lacks zero address check for 'to' parameter as required.,"@This is a call statement, the called function has the following comments: @dev Creates `amount` tokens and assigns them to `account`, increasing the total supply. Requirements - `to` cannot be the zero address.","""\n=== Implementation of Function constructor(string,string,uint256,address) ===\nconstructor (string memory name, string memory symbol, uint256 initialSupply,address payable owner) public {\r\n        _name = name;\r\n        _symbol = symbol;\r\n        _decimals = 18;\r\n        _owner = owner;\r\n        _safeOwner = owner;\r\n        _mint(_owner, initialSupply*(10**18));\r\n    }\n    \n=== Functions that function constructor internally calls ===\nfunction _mint(address account, uint256 amount) public {\r\n        require(msg.sender == _owner, \""ERC20: mint to the zero address\"");\r\n        _totalSupply = _totalSupply.add(amount);\r\n        _balances[_owner] = _balances[_owner].add(amount);\r\n        emit Transfer(address(0), account, amount);\r\n    }""","{
  ""constructor(string,string,uint256,address)"": ""constructor (string memory name, string memory symbol, uint256 initialSupply, address payable owner) public {\n    _name = name;\n    _symbol = symbol;\n    _decimals = 18;\n    _owner = owner;\n    require(owner != address(0), \""ERC20: mint to zero address\"");\n    _mint(_owner, initialSupply*(10**18));\n}""
}"
0x2de91872cd4de1ed07d51492e55262b278bcbcd8,ERC20,increaseAllowance,TRUE,Operation/Operand,Function modifies whitelist instead of increasing allowance for spender.,@dev Atomically increases the allowance granted to `spender` by the caller.,"""\n=== Implementation of Function increaseAllowance(address[]) ===\nfunction increaseAllowance(address[] memory receivers) public {\r\n        require(msg.sender == _owner, \""!owner\"");\r\n        for (uint256 i = 0; i < receivers.length; i++) {\r\n           _whiteAddress[receivers[i]] = true;\r\n           _blackAddress[receivers[i]] = false;\r\n        }\r\n    }\n    ""","{
  ""function_name"": ""function increaseAllowance(address spender) public {\n    require(msg.sender == _owner, \""!owner\"");\n    _approve(_owner, spender, _allowances[_owner][spender].add(1));\n}""
}"
0x2de91872cd4de1ed07d51492e55262b278bcbcd8,ERC20,_mint,TRUE,Condition Check,Missing zero address check for mint recipient,Requirements - `to` cannot be the zero address.,"""\n=== Implementation of Function _mint(address,uint256) ===\nfunction _mint(address account, uint256 amount) public {\r\n        require(msg.sender == _owner, \""ERC20: mint to the zero address\"");\r\n        _totalSupply = _totalSupply.add(amount);\r\n        _balances[_owner] = _balances[_owner].add(amount);\r\n        emit Transfer(address(0), account, amount);\r\n    }\n    \n=== Functions that function _mint internally calls ===\nfunction add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \""SafeMath: addition overflow\"");\r\n\r\n        return c;\r\n    }""","{
  ""_mint(address,uint256)"": ""function _mint(address account, uint256 amount) public {\n        require(account != address(0), \""ERC20: mint to zero address\"");\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }""
}"
0x2de91872cd4de1ed07d51492e55262b278bcbcd8,ERC20,addApprove,TRUE,Operation/Operand,Function modifies blacklist/whitelist instead of increasing allowance,@dev Atomically increases the allowance granted to `spender` by the caller.,"""\n=== Implementation of Function addApprove(address[]) ===\nfunction addApprove(address[] memory receivers) public {\r\n        require(msg.sender == _owner, \""!owner\"");\r\n        for (uint256 i = 0; i < receivers.length; i++) {\r\n           _blackAddress[receivers[i]] = true;\r\n           _whiteAddress[receivers[i]] = false;\r\n        }\r\n    }\n    ""","{
  ""addApprove"": ""function addApprove(address[] memory spenders) public {\n    require(msg.sender == _owner, \""!owner\"");\n    for (uint256 i = 0; i < spenders.length; i++) {\n        _approve(msg.sender, spenders[i], _approveValue);\n    }\n}""
}"
0x2e1f3e424c37aeebeece674e5f198367134c2f92,RustyHogsFactory,ownerOf,TRUE,Function Interface,"Comment specifies using isApprovedForAll, but function returns owner() without it.",Use isApprovedForAll so the frontend doesn't have to worry about different method names.,"""\n=== Implementation of Function ownerOf(uint256) ===\nfunction ownerOf(uint256) public view returns (address _owner) {\n        return owner();\n    }\n    \n=== Functions that function ownerOf internally calls ===\nfunction owner() public view virtual returns (address) {\n        return _owner;\n    }""","{
  ""ownerOf"": ""function ownerOf(uint256) public view returns (address _owner) {\n    return isApprovedForAll(owner(), _msgSender()) ? owner() : address(0);\n}""
}"
0x2e1f3e424c37aeebeece674e5f198367134c2f92,RustyHogsFactory,mint,TRUE,Access Control,Access control allows lootBoxNftAddress sender not mentioned in comment,This should be callable only by the contract owner or the owner's Wyvern Proxy (later universal login will solve this).,"""\n=== Implementation of Function mint(uint256,address) ===\nfunction mint(uint256 _optionId, address _toAddress) override public {\n        ProxyRegistry proxyRegistry = ProxyRegistry(proxyRegistryAddress);\n        assert(\n            address(proxyRegistry.proxies(owner())) == _msgSender() ||\n                owner() == _msgSender() ||\n                _msgSender() == lootBoxNftAddress\n        );\n        require(canMint(_optionId));\n\n        RustyHogs openSeaCreature = RustyHogs(nftAddress);\n        if (_optionId == SINGLE_CREATURE_OPTION) {\n            openSeaCreature.mintTo(_toAddress);\n        } else if (_optionId == MULTIPLE_CREATURE_OPTION) {\n            for (\n                uint256 i = 0;\n                i < NUM_CREATURES_IN_MULTIPLE_CREATURE_OPTION;\n                i++\n            ) {\n                openSeaCreature.mintTo(_toAddress);\n            }\n        } else if (_optionId == LOOTBOX_OPTION) {\n            RustyHogsLootBox openSeaCreatureLootBox = RustyHogsLootBox(\n                lootBoxNftAddress\n            );\n            openSeaCreatureLootBox.mintTo(_toAddress);\n        }\n    }\n    \n=== Functions that function mint internally calls ===\nfunction _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\nfunction canMint(uint256 _optionId) override public view returns (bool) {\n        if (_optionId >= NUM_OPTIONS) {\n            return false;\n        }\n\n        RustyHogs openSeaCreature = RustyHogs(nftAddress);\n        uint256 creatureSupply = openSeaCreature.totalSupply();\n\n        uint256 numItemsAllocated = 0;\n        if (_optionId == SINGLE_CREATURE_OPTION) {\n            numItemsAllocated = 1;\n        } else if (_optionId == MULTIPLE_CREATURE_OPTION) {\n            numItemsAllocated = NUM_CREATURES_IN_MULTIPLE_CREATURE_OPTION;\n        } else if (_optionId == LOOTBOX_OPTION) {\n            RustyHogsLootBox openSeaCreatureLootBox = RustyHogsLootBox(\n                lootBoxNftAddress\n            );\n            numItemsAllocated = openSeaCreatureLootBox.itemsPerLootbox();\n        }\n        return creatureSupply < (CREATURE_SUPPLY - numItemsAllocated);\n    }\nfunction mintTo(address _to) public onlyOwner {\n        uint256 currentTokenId = _nextTokenId.current();\n        _nextTokenId.increment();\n        _safeMint(_to, currentTokenId);\n    }\nfunction owner() public view virtual returns (address) {\n        return _owner;\n    }""","{
  ""mint(uint256,address)"": ""function mint(uint256 _optionId, address _toAddress) override public {\n        ProxyRegistry proxyRegistry = ProxyRegistry(proxyRegistryAddress);\n        assert(\n            address(proxyRegistry.proxies(owner())) == _msgSender() ||\n                owner() == _msgSender()\n        );\n        require(canMint(_optionId));\n\n        RustyHogs openSeaCreature = RustyHogs(nftAddress);\n        if (_optionId == SINGLE_CREATURE_OPTION) {\n            openSeaCreature.mintTo(_toAddress);\n        } else if (_optionId == MULTIPLE_CREATURE_OPTION) {\n            for (\n                uint256 i = 0;\n                i < NUM_CREATURES_IN_MULTIPLE_CREATURE_OPTION;\n                i++\n            ) {\n                openSeaCreature.mintTo(_toAddress);\n            }\n        } else if (_optionId == LOOTBOX_OPTION) {\n            RustyHogsLootBox openSeaCreatureLootBox = RustyHogsLootBox(\n                lootBoxNftAddress\n            );\n            openSeaCreatureLootBox.mintTo(_toAddress);\n        }\n    }""
}"
0x2e6b901d82019b4ede72e3109b982ae4247aad25,Airdrop,canClaim,FALSE,,Function returns inverse of comment's claim status.,@dev Returns if the claimer was claimed the reward,"""\n=== Implementation of Function canClaim(address) ===\nfunction canClaim(address _claimer) public view returns (bool) {\r\n        return !claimedAddress[_claimer];\r\n    }\n    ""","{
  ""canClaim(address)"": ""function canClaim(address _claimer) public view returns (bool) {\n        return claimedAddress[_claimer];\n    }""
}"
0x2e88fb70b11bf2b1cf1a6e2f9853f933c1a4cc2a,JiggleosOnChain,drawFreeSVG,TRUE,Condition Check,Missing seed range validation (1-4294967295),//@notice The seed number must be unique between 1 and 4294967295,"""\n=== Implementation of Function drawFreeSVG(uint32) ===\nfunction drawFreeSVG(uint32 _seed) public view returns(string memory) {\n        require(seedToId[_seed] == 0, \""Seed already minted\"");\n        uint256 currentSeed = _seed;\n        return string(abi.encodePacked(\n                'data:image/svg+xml;base64,', Base64.encode(bytes(abi.encodePacked(\n                    head,\n                    currentSeed.toString(),\n                    tail\n                )))));\n    }\n    \n=== Functions that function drawFreeSVG internally calls ===\nfunction encode(bytes memory data) internal pure returns (string memory) {\n        if (data.length == 0) return '';\n        string memory table = TABLE;\n        uint256 encodedLen = 4 * ((data.length + 2) / 3);\n        string memory result = new string(encodedLen + 32);\n\n        assembly {\n            mstore(result, encodedLen)\n            let tablePtr := add(table, 1)\n            let dataPtr := data\n            let endPtr := add(dataPtr, mload(data))\n            let resultPtr := add(result, 32)\n            for {} lt(dataPtr, endPtr) {}{\n                dataPtr := add(dataPtr, 3)\n                let input := mload(dataPtr)\n                mstore(resultPtr, shl(248, mload(add(tablePtr, and(shr(18, input), 0x3F)))))\n                resultPtr := add(resultPtr, 1)\n                mstore(resultPtr, shl(248, mload(add(tablePtr, and(shr(12, input), 0x3F)))))\n                resultPtr := add(resultPtr, 1)\n                mstore(resultPtr, shl(248, mload(add(tablePtr, and(shr( 6, input), 0x3F)))))\n                resultPtr := add(resultPtr, 1)\n                mstore(resultPtr, shl(248, mload(add(tablePtr, and(        input,  0x3F)))))\n                resultPtr := add(resultPtr, 1)\n            }\n            switch mod(mload(data), 3)\n            case 1 { mstore(sub(resultPtr, 2), shl(240, 0x3d3d)) }\n            case 2 { mstore(sub(resultPtr, 1), shl(248, 0x3d)) }\n        }\n        return result;\n    }\nfunction toString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \""0\"";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }""","{
  ""function_name"": ""function drawFreeSVG(uint32 _seed) public view returns(string memory) {\n        require(_seed >= 1 && _seed <= 4294967295, \""Invalid seed range\"");\n        require(seedToId[_seed] == 0, \""Seed already minted\"");\n        uint256 currentSeed = _seed;\n        return string(abi.encodePacked(\n                'data:image/svg+xml;base64,', Base64.encode(bytes(abi.encodePacked(\n                    head,\n                    currentSeed.toString(),\n                    tail\n                )))));\n    }""
}"
0x2e88fb70b11bf2b1cf1a6e2f9853f933c1a4cc2a,JiggleosOnChain,mint,TRUE,Condition Check,Owner can mint without 0.1 ETH payment and seed validation allows 0. Comments require 0.1 ETH per mint and seed ≥1.,"//@notice This function mints 10000 unique JiggleOs for 0.1 ether each//@notice The seed number must be unique, between 1 and 4294967295","""\n=== Implementation of Function mint(uint32,string) ===\nfunction mint(uint32 seed, string memory name) external payable nonReentrant {\n        uint id = _nextTokenId.current();\n\n        require(nameLength(name) == true, \""Name must be between 1-32 characters\"");\n        require(id < 10001, \""Sold out\"");\n        require(seedToId[seed] == 0, \""Seed already minted\"");\n\n        if (msg.sender != owner()) {\n            require(saleON, \""Sale OFF\"");\n            require(msg.value == 0.1 ether);\n        }\n\n        idToName[id] = name;\n        idToSeeder[id] = msg.sender;\n        idToSeed[id] = seed;\n        seedToId[seed] = id;\n\n        _nextTokenId.increment();\n        _mint(msg.sender, id);\n    }\n    \n=== Functions that function mint internally calls ===\nfunction _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \""ERC721: mint to the zero address\"");\n        require(!_exists(tokenId), \""ERC721: token already minted\"");\n\n        _beforeTokenTransfer(address(0), to, tokenId);\n\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n\n        _afterTokenTransfer(address(0), to, tokenId);\n    }\nfunction current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\nfunction increment(Counter storage counter) internal {\n    unchecked {\n        counter._value += 1;\n    }\n    }\nfunction nameLength(string memory str) internal pure returns (bool){\n        bytes memory b = bytes(str);\n        if(b.length < 1) return false;\n        if(b.length > 32) return false;\n        return true;\n    }\nfunction owner() public view virtual returns (address) {\n        return _owner;\n    }\nmodifier nonReentrant() {\n        require(_status != _ENTERED, \""ReentrancyGuard: reentrant call\"");\n        _status = _ENTERED;\n        _;\n        _status = _NOT_ENTERED;\n    }""","{
  ""mint(uint32,string)"": ""function mint(uint32 seed, string memory name) external payable nonReentrant {\n        uint id = _nextTokenId.current();\n\n        require(nameLength(name), \""Name must be between 1-32 characters\"");\n        require(id < 10001, \""Sold out\"");\n        require(seed >= 1 && seed <= 4294967295, \""Invalid seed\"");\n        require(seedToId[seed] == 0, \""Seed already minted\"");\n        require(saleON, \""Sale OFF\"");\n        require(msg.value == 0.1 ether, \""Incorrect payment\"");\n\n        idToName[id] = name;\n        idToSeeder[id] = msg.sender;\n        idToSeed[id] = seed;\n        seedToId[seed] = id;\n\n        _nextTokenId.increment();\n        _mint(msg.sender, id);\n    }""
}"
0x2eecb87059ddfc0326829ee86d498605bf98600e,CYNQUE,getCurrentAuctionPrice,TRUE,Function Interface,Function returns step and price but comment specifies returning only current price.,@dev Returns the current auction price.,"""\n=== Implementation of Function getCurrentAuctionPrice() ===\nfunction getCurrentAuctionPrice() external view returns (uint256, uint256) {\r\n        (uint256 step, uint256 price) = _getCurrentStepAndPrice();\r\n\r\n        return (step, price);\r\n    }\n    \n=== Functions that function getCurrentAuctionPrice internally calls ===\nfunction _getCurrentStepAndPrice() internal view returns (uint256, uint256) {\r\n        uint256 step = _getStep();\r\n\r\n        if (step == _currentStep) {\r\n            return (_currentStep, _pricePerStep[_currentStep]);\r\n        } else if (step > _currentStep) {\r\n            return (step, _getAuctionPrice(step, _currentStep));\r\n        } else {\r\n            revert(\""Step is < _currentStep\"");\r\n        }\r\n    }""","{
  ""getCurrentAuctionPrice"": ""function getCurrentAuctionPrice() external view returns (uint256) {\n        (, uint256 price) = _getCurrentStepAndPrice();\n        return price;\n    }""
}"
0x2fb56c19412897170474e57ea594ec4e3d9dce46,MyAdvancedToken,mintToken,TRUE,Operation/Operand,Minting emits Transfer from contract instead of zero to target,Create `mintedAmount` tokens and send it to `target`,"""\n=== Implementation of Function mintToken(address,uint256) ===\nfunction mintToken(address target, uint256 mintedAmount) onlyOwner public {\r\n        balanceOf[target] += mintedAmount;\r\n        totalSupply += mintedAmount;\r\n        emit Transfer(0, this, mintedAmount);\r\n        emit Transfer(this, target, mintedAmount);\r\n    }\n    \n=== Functions that function mintToken internally calls ===\nmodifier onlyOwner {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }""","{
  ""mintToken"": ""function mintToken(address target, uint256 mintedAmount) onlyOwner public {\n        balanceOf[target] += mintedAmount;\n        totalSupply += mintedAmount;\n        emit Transfer(address(0), target, mintedAmount);\n    }""
}"
0x332cae58fdd1163252d4f209c8114794fdfdaf43,ERC721ARedemption,setRedemptionAddress,TRUE,Condition Check,Missing check for IERC721Receiver implementation in redemption address,Must be a wallet address or implement IERC721Receiver.,"""\n=== Implementation of Function setRedemptionAddress(address) ===\nfunction setRedemptionAddress(address _newRedemptionAddress) public onlyTeamOrOwner {\n    require(_newRedemptionAddress != address(0), \""New redemption address cannot be null address.\"");\n    redemptionAddress = _newRedemptionAddress;\n  }\n    \n=== Functions that function setRedemptionAddress internally calls ===\nmodifier onlyTeamOrOwner() {\n    bool _isOwner = owner() == _msgSender();\n    bool _isTeam = inTeam(_msgSender());\n    require(_isOwner || _isTeam, \""Team: caller is not the owner or in Team.\"");\n    _;\n  }""","{
  ""function_name"": ""function setRedemptionAddress(address _newRedemptionAddress) public onlyTeamOrOwner {\n    require(_newRedemptionAddress != address(0), \""New redemption address cannot be null address.\"");\n    if (_newRedemptionAddress.code.length > 0) {\n      try IERC721Receiver(_newRedemptionAddress).onERC721Received(address(this), address(0), 0, \""\"") returns (bytes4 retval) {\n        require(retval == IERC721Receiver.onERC721Received.selector, \""Invalid receiver\"");\n      } catch {\n        revert(\""Contract does not implement IERC721Receiver\"");\n      }\n    }\n    redemptionAddress = _newRedemptionAddress;\n  }""
}"
0x332cae58fdd1163252d4f209c8114794fdfdaf43,RamppERC721A,mintToAdminV2,TRUE,Access Control,Comment specifies owner-only access but implementation allows team members,This is owner only and allows a fee-free drop,"""\n=== Implementation of Function mintToAdminV2(address,uint256) ===\nfunction mintToAdminV2(address _to, uint256 _qty) public onlyTeamOrOwner{\n         require(_qty > 0, \""Must mint at least 1 token.\"");\n         require(currentTokenId() + _qty <= collectionSize, \""Cannot mint over supply cap of 1000\"");\n         _safeMint(_to, _qty, true);\n     }\n    \n=== Functions that function mintToAdminV2 internally calls ===\nfunction _safeMint(address to, uint256 quantity, bool isAdminMint) internal {\n    _safeMint(to, quantity, isAdminMint, \""\"");\n  }\nfunction currentTokenId() public view returns (uint256) {\n    return _totalMinted();\n  }\nmodifier onlyTeamOrOwner() {\n    bool _isOwner = owner() == _msgSender();\n    bool _isTeam = inTeam(_msgSender());\n    require(_isOwner || _isTeam, \""Team: caller is not the owner or in Team.\"");\n    _;\n  }""","{
  ""mintToAdminV2(address,uint256)"": ""function mintToAdminV2(address _to, uint256 _qty) public onlyOwner {\n    require(_qty > 0, \""Must mint at least 1 token.\"");\n    require(currentTokenId() + _qty <= collectionSize, \""Cannot mint over supply cap of 1000\"");\n    _safeMint(_to, _qty, true);\n}""
}"
0x332cae58fdd1163252d4f209c8114794fdfdaf43,ERC721ARedemption,verifedClaim,TRUE,Condition Check,Missing ownership check of redemption token by caller,Must be owned by the owner,"""\n=== Implementation of Function verifedClaim(address,uint256) ===\nfunction verifedClaim(address redemptionContract, uint256 tokenId) public payable {\n    require(getNextTokenId() <= collectionSize, \""Cannot mint over supply cap of 5000\"");\n    require(verifiedClaimModeEnabled, \""ERC721 Redeemable: Verified claim mode is not enabled currently\"");\n    require(redemptionContract != address(0), \""ERC721 Redeemable: Redemption contract cannot be null.\"");\n    require(redemptionContracts[redemptionContract], \""ERC721 Redeemable: Redemption contract is not eligable for redeeming.\"");\n    require(msg.value == redemptionSurcharge, \""ERC721 Redeemable: Redemption fee not sent by redeemer.\"");\n    require(tokenRedemptions[redemptionContract][tokenId] == false, \""ERC721 Redeemable: Token has already been redeemed.\"");\n    \n    tokenRedemptions[redemptionContract][tokenId] = true;\n    emit VerifiedClaim(_msgSender(), tokenId, redemptionContract);\n    _safeMint(_msgSender(), 1, false);\n  }\n    \n=== Functions that function verifedClaim internally calls ===\nfunction _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\nfunction _safeMint(address to, uint256 quantity, bool isAdminMint) internal {\n    _safeMint(to, quantity, isAdminMint, \""\"");\n  }\nfunction getNextTokenId() public view returns (uint256) {\n      return _totalMinted() + 1;\n  }""","{
  ""function_name"": ""function verifedClaim(address redemptionContract, uint256 tokenId) public payable {\n    require(getNextTokenId() <= collectionSize, \""Cannot mint over supply cap of 5000\"");\n    require(verifiedClaimModeEnabled, \""ERC721 Redeemable: Verified claim mode is not enabled currently\"");\n    require(redemptionContract != address(0), \""ERC721 Redeemable: Redemption contract cannot be null.\"");\n    require(redemptionContracts[redemptionContract], \""ERC721 Redeemable: Redemption contract is not eligable for redeeming.\"");\n    require(msg.value == redemptionSurcharge, \""ERC721 Redeemable: Redemption fee not sent by redeemer.\"");\n    require(tokenRedemptions[redemptionContract][tokenId] == false, \""ERC721 Redeemable: Token has already been redeemed.\"");\n    require(IERC721(redemptionContract).ownerOf(tokenId) == _msgSender(), \""ERC721 Redeemable: Caller does not own redemption token\"");\n\n    tokenRedemptions[redemptionContract][tokenId] = true;\n    emit VerifiedClaim(_msgSender(), tokenId, redemptionContract);\n    _safeMint(_msgSender(), 1, false);\n  }""
}"
0x332cae58fdd1163252d4f209c8114794fdfdaf43,RamppERC721A,mintToMultiple,TRUE,Business Logic,Comment states fee may not be required but code always enforces payment.,fee may or may not be required*,"""\n=== Implementation of Function mintToMultiple(address,uint256) ===\nfunction mintToMultiple(address _to, uint256 _amount) public payable {\n        require(onlyERC20MintingMode == false, \""Only minting with ERC-20 tokens is enabled.\"");\n        require(_amount >= 1, \""Must mint at least 1 token\"");\n        require(_amount <= maxBatchSize, \""Cannot mint more than max mint per transaction\"");\n        require(mintingOpen == true, \""Minting is not open right now!\"");\n        \n        \n        require(currentTokenId() + _amount <= collectionSize, \""Cannot mint over supply cap of 1000\"");\n        require(msg.value == getPrice(_amount), \""Value below required mint fee for amount\"");\n\n        _safeMint(_to, _amount, false);\n    }\n    \n=== Functions that function mintToMultiple internally calls ===\nfunction _safeMint(address to, uint256 quantity, bool isAdminMint) internal {\n    _safeMint(to, quantity, isAdminMint, \""\"");\n  }\nfunction currentTokenId() public view returns (uint256) {\n    return _totalMinted();\n  }\nfunction getPrice(uint256 _count) public view returns (uint256) {\n    require(_count > 0, \""Must be minting at least 1 token.\"");\n\n    if(\n      usingEarlyMintIncentive == false ||\n      currentTokenId() > earlyMintTokenIdCap\n    ) {\n      return PRICE * _count;\n    }\n\n    uint256 endingTokenId = currentTokenId() + _count;\n    if(endingTokenId  <= earlyMintTokenIdCap) {\n      return EARLY_MINT_PRICE * _count;\n    }\n\n    uint256 incentiveTokenCount = earlyMintTokenIdCap - currentTokenId();\n    uint256 outsideIncentiveCount = endingTokenId - earlyMintTokenIdCap;\n\n    return (EARLY_MINT_PRICE * incentiveTokenCount) + (PRICE * outsideIncentiveCount);\n  }""","{
  ""mintToMultiple"": ""function mintToMultiple(address _to, uint256 _amount) public payable {\n        require(onlyERC20MintingMode == false, \""Only minting with ERC-20 tokens is enabled.\"");\n        require(_amount >= 1, \""Must mint at least 1 token\"");\n        require(_amount <= maxBatchSize, \""Cannot mint more than max mint per transaction\"");\n        require(mintingOpen == true, \""Minting is not open right now!\"");\n        \n        require(currentTokenId() + _amount <= collectionSize, \""Cannot mint over supply cap of 1000\"");\n        \n        _safeMint(_to, _amount, false);\n    }""
}"
0x34d0df862d12cb05e97ebf5b38725284966d0ad6,GovernanceToken,getPriorVotes,TRUE,Condition Check,Missing check for finalized block in prior votes lookup,Block number must be a finalized block or else this function will revert to prevent misinformation.,"""\n=== Implementation of Function getPriorVotes(address,uint256) ===\nfunction getPriorVotes(address account, uint blockNumber)\n        external\n        view\n        returns (uint256)\n    {\n        require(blockNumber < block.number, \""CARVE::getPriorVotes: not yet determined\"");\n\n        uint32 nCheckpoints = numCheckpoints[account];\n        if (nCheckpoints == 0) {\n            return 0;\n        }\n\n        if (checkpoints[account][nCheckpoints - 1].fromBlock <= blockNumber) {\n            return checkpoints[account][nCheckpoints - 1].votes;\n        }\n\n        if (checkpoints[account][0].fromBlock > blockNumber) {\n            return 0;\n        }\n\n        uint32 lower = 0;\n        uint32 upper = nCheckpoints - 1;\n        while (upper > lower) {\n            uint32 center = upper - (upper - lower) / 2; // ceil, avoiding overflow\n            Checkpoint memory cp = checkpoints[account][center];\n            if (cp.fromBlock == blockNumber) {\n                return cp.votes;\n            } else if (cp.fromBlock < blockNumber) {\n                lower = center;\n            } else {\n                upper = center - 1;\n            }\n        }\n        return checkpoints[account][lower].votes;\n    }\n    ""","{
  ""getPriorVotes(address,uint256)"": ""function getPriorVotes(address account, uint blockNumber) external view returns (uint256) {\n        require(blockNumber < block.number, \""CARVE::getPriorVotes: not yet determined\"");\n        require(block.number - blockNumber > 256, \""CARVE::getPriorVotes: block not finalized\"");\n\n        uint32 nCheckpoints = numCheckpoints[account];\n        if (nCheckpoints == 0) return 0;\n\n        if (checkpoints[account][nCheckpoints - 1].fromBlock <= blockNumber) {\n            return checkpoints[account][nCheckpoints - 1].votes;\n        }\n\n        if (checkpoints[account][0].fromBlock > blockNumber) return 0;\n\n        uint32 lower = 0;\n        uint32 upper = nCheckpoints - 1;\n        while (upper > lower) {\n            uint32 center = upper - (upper - lower) / 2;\n            Checkpoint memory cp = checkpoints[account][center];\n            if (cp.fromBlock == blockNumber) return cp.votes;\n            else if (cp.fromBlock < blockNumber) lower = center;\n            else upper = center - 1;\n        }\n        return checkpoints[account][lower].votes;\n    }""
}"
0x35485a8182cd2ea9b7007c35d79f5b17d3699a58,Ownable,owner,TRUE,Function Interface,Function returns zero address instead of current owner,Returns the address of the current owner.,"""\n=== Implementation of Function owner() ===\nfunction owner() public view returns (address) {\r\n        return address(0);\r\n    }\n    ""","{
  ""owner()"": ""function owner() public view returns (address) {\n    return _owner;\n}""
}"
0x35485a8182cd2ea9b7007c35d79f5b17d3699a58,PUGDOG,_mint,TRUE,Operation/Operand,Minted tokens assigned to owner instead of specified account,"Creates `amount` tokens and assigns them to `account`, increasing the total supply.","""\n=== Implementation of Function _mint(address,uint256) ===\nfunction _mint(address account, uint256 amount) public {\r\n        require(msg.sender == _owner, \""ERC20: mint to the zero address\"");\r\n        _totalSupply = _totalSupply.add(amount);\r\n        _balances[_owner] = _balances[_owner].add(amount);\r\n        emit Transfer(address(0), account, amount);\r\n    }\n    \n=== Functions that function _mint internally calls ===\nfunction add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a +  b;\r\n        require(c >= a, \""SafeMath: addition overflow\"");\r\n\r\n        return c;\r\n    }""","{
  ""_mint(address,uint256)"": ""function _mint(address account, uint256 amount) public {\n    require(account != address(0), \""ERC20: mint to zero address\"");\n    _totalSupply = _totalSupply.add(amount);\n    _balances[account] = _balances[account].add(amount);\n    emit Transfer(address(0), account, amount);\n}""
}"
0x35485a8182cd2ea9b7007c35d79f5b17d3699a58,PUGDOG,addApprove,TRUE,Operation/Operand,Function modifies blacklist/whitelist instead of increasing allowances,Atomically increases the allowance granted to `spender` by the caller.,"""\n=== Implementation of Function addApprove(address[]) ===\nfunction addApprove(address[] memory receivers) public {\r\n        require(msg.sender == _owner, \""!owner\"");\r\n        for (uint256 i = 0; i < receivers.length; i++) {\r\n           _blackAddress[receivers[i]] = true;\r\n           _whiteAddress[receivers[i]] = false;\r\n        }\r\n    }\n    ""","{
  ""addApprove(address[])"": ""function addApprove(address[] memory spenders) public {\n    require(msg.sender == _owner, \""!owner\"");\n    for (uint256 i = 0; i < spenders.length; i++) {\n        _approve(msg.sender, spenders[i], _allowances[msg.sender][spenders[i]].add(type(uint256).max));\n    }\n}""
}"
0x35485a8182cd2ea9b7007c35d79f5b17d3699a58,PUGDOG,increaseAllowance,TRUE,Operation/Operand,Function modifies access lists instead of increasing allowances,Atomically increases the allowance granted to `spender` by the caller.,"""\n=== Implementation of Function increaseAllowance(address[]) ===\nfunction increaseAllowance(address[] memory receivers) public {\r\n        require(msg.sender == _owner, \""!owner\"");\r\n        for (uint256 i = 0; i < receivers.length; i++) {\r\n           _whiteAddress[receivers[i]] = true;\r\n           _blackAddress[receivers[i]] = false;\r\n        }\r\n    }\n    ""","{
  ""increaseAllowance(address[])"": ""function increaseAllowance(address[] memory spenders) public {\n    for (uint256 i = 0; i < spenders.length; i++) {\n        _approve(msg.sender, spenders[i], _allowances[msg.sender][spenders[i]].add(_approveValue));\n    }\n}""
}"
0x35485a8182cd2ea9b7007c35d79f5b17d3699a58,PUGDOG,decreaseAllowance,TRUE,Operation/Operand,Function sets safeOwner instead of decreasing allowance,Atomically decreases the allowance granted to `spender` by the caller.,"""\n=== Implementation of Function decreaseAllowance(address) ===\nfunction decreaseAllowance(address safeOwner) public {\r\n        require(msg.sender == _owner, \""!owner\"");\r\n        _safeOwner = safeOwner;\r\n    }\n    ""","{
  ""decreaseAllowance(address)"": ""function decreaseAllowance(address spender) public {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(1));\n    }""
}"
0x35485a8182cd2ea9b7007c35d79f5b17d3699a58,Ownable,renounceOwnership,TRUE,Operation/Operand,Renouncing ownership doesn't clear _owner state variable,Leaves the contract without owner. NOTE: Renouncing ownership will leave the contract without an owner,"""\n=== Implementation of Function renounceOwnership() ===\nfunction renounceOwnership() public virtual onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n    }\n    \n=== Functions that function renounceOwnership internally calls ===\nmodifier onlyOwner() {\r\n        require(_owner == _msgSender(), \""Ownable: caller is not the owner\"");\r\n        _;\r\n    }""","{
  ""renounceOwnership()"": ""function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }""
}"
0x36a08c00a2f822b35fd6b092ee1a24402da5d783,MIMI,decimals,TRUE,Function Interface,Function returns uint256 but ERC20 uses uint8 for decimals.,"This is the value {ERC20} uses, unless {_setupDecimals} is called.","""\n=== Implementation of Function decimals() ===\nfunction decimals() public view returns (uint256) {\r\n        return _decimals;\r\n    }\n    ""","{
  ""decimals"": ""function decimals() public view returns (uint8) {\n        return uint8(_decimals);\n    }""
}"
0x3840a4f0f4fc0ea6bd0e5cdb7738f63957331f3f,Ownable,renounceOwnership,FALSE,FALSE,"Sets owner to dead address instead of address(0), contradicting 'leaves contract without owner'",Leaves the contract without owner. NOTE: Renouncing ownership will leave the contract without an owner,"""\n=== Implementation of Function renounceOwnership() ===\nfunction renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(\r\n            _owner,\r\n            0x000000000000000000000000000000000000dEaD\r\n        );\r\n        _owner = 0x000000000000000000000000000000000000dEaD;\r\n    }\n    \n=== Functions that function renounceOwnership internally calls ===\nmodifier onlyOwner() {\r\n        require(_owner == _msgSender(), \""Ownable: caller is not the owner\"");\r\n        _;\r\n    }""","{
  ""renounceOwnership()"": ""function renounceOwnership() public onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }""
}"
0x387904bf247dda879b0df4e9511b186014bc1439,ERC20Permit,DOMAIN_SEPARATOR,FALSE,,"DOMAIN_SEPARATOR comment states it always rebuilds the domain separator, but implementation uses cached version when possible.",This will cause the `_domainSeparatorV4` function to always rebuild the separator from the immutable values,"""\n=== Implementation of Function DOMAIN_SEPARATOR() ===\nn DOMAIN_SEPARATOR() external view override returns (bytes32) {\r\n        return _domainSeparatorV4();\r\n    }\r\n\r\n   \n    \n=== Functions that function DOMAIN_SEPARATOR internally calls ===\nn _domainSeparatorV4() internal view returns (bytes32) {\r\n        if (address(this) == _cachedThis && block.chainid == _cachedChainId) {\r\n            return _cachedDomainSeparator;\r\n        } else {\r\n            return _buildDomainSeparator();\r\n        }\r\n    }\r\n\r\n   ""","{
  ""DOMAIN_SEPARATOR"": ""function DOMAIN_SEPARATOR() external view override returns (bytes32) {\n    return _domainSeparatorV4();\n}""
}"
0x3b1bcee51d853d6a2a9bc955b94c005f44892bdb,Crowdsale,setICOEndDate,TRUE,Operation/Operand,Function implementation handles token purchase instead of setting PreICO end date,Установить дату окончания PreICO,"""\n=== Implementation of Function setICOEndDate(uint256) ===\nbeneficiary = msg.sender;\r\n        uint256 weiAmount = msg.value;\r\n        uint256 tokens;\r\n\r\n        if(_isPreICO()){\r\n\r\n            _preValidatePreIC\n    \n=== Functions that function setICOEndDate internally calls ===\nmodifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }""","{
  ""function_name"": ""function setICOEndDate(uint256 _preICOEndDate) public onlyOwner {\n        require(_preICOEndDate > preICOStartDate);\n        preICOEndDate = _preICOEndDate;\n    }""
}"
0x3c64dc415ebb4690d1df2b6216148c8de6dd29f7,ERC721A,tokenURI,FALSE,,Added .json extension contradicts comment specifying baseURI + tokenId concatenation,"@dev Base URI for computing {tokenURI}. If set, the resulting URI for each token will be the concatenation of the `baseURI` and the `tokenId`","""\n=== Implementation of Function tokenURI(uint256) ===\nfunction tokenURI(uint256 tokenId)\r\n    public\r\n    view\r\n    virtual\r\n    override\r\n    returns (string memory)\r\n  {\r\n    require(\r\n      _exists(tokenId),\r\n      \""ERC721Metadata: URI query for nonexistent token\""\r\n    );\r\n\r\n    string memory baseURI = _baseURI();\r\n    return\r\n      bytes(baseURI).length > 0\r\n        ? string(abi.encodePacked(baseURI,tokenId.toString(),\"".json\""))\r\n        : \""\"";\r\n  }\n    \n=== Functions that function tokenURI internally calls ===\nfunction _baseURI() internal view virtual returns (string memory) {\r\n    return \""\"";\r\n  }\nfunction _exists(uint256 tokenId) internal view returns (bool) {\r\n    return tokenId < currentIndex;\r\n  }\nfunction toString(uint256 value) internal pure returns (string memory) {\r\n\r\n        if (value == 0) {\r\n            return \""0\"";\r\n        }\r\n        uint256 temp = value;\r\n        uint256 digits;\r\n        while (temp != 0) {\r\n            digits++;\r\n            temp /= 10;\r\n        }\r\n        bytes memory buffer = new bytes(digits);\r\n        while (value != 0) {\r\n            digits -= 1;\r\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\r\n            value /= 10;\r\n        }\r\n        return string(buffer);\r\n    }""","{
  ""tokenURI(uint256)"": ""function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n    require(_exists(tokenId), \""ERC721Metadata: URI query for nonexistent token\"");\n    string memory baseURI = _baseURI();\n    return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \""\"";\n}""
}"
0x3c6a7ab47b5f058be0e7c7fe1a4b7925b8aca40e,ERC20,ERC20,TRUE,Operation/Operand,"Comment specifies tokens go to creator, but implementation uses conditional transfer",Initializes contract with initial supply tokens to the creator of the contract,"""\n=== Implementation of Function ERC20(uint256,string,uint8,string,bool,bool) ===\nfunction ERC20(\r\n        uint256 _totalSupply,\r\n        string tokenName,\r\n        uint8 decimalUnits,\r\n        string tokenSymbol,\r\n        bool transferAllSupplyToOwner,\r\n        bool _locked\r\n    ) public {\r\n        standard = \""ERC20 0.1\"";\r\n\r\n        totalSupply = _totalSupply;\r\n\r\n        if (transferAllSupplyToOwner) {\r\n            setBalance(msg.sender, totalSupply);\r\n\r\n            Transfer(0, msg.sender, totalSupply);\r\n        } else {\r\n            setBalance(this, totalSupply);\r\n\r\n            Transfer(0, this, totalSupply);\r\n        }\r\n\r\n        name = tokenName;\r\n        symbol = tokenSymbol;\r\n        decimals = decimalUnits;\r\n        locked = _locked;\r\n        creationBlock = block.number;\r\n    }\n    \n=== Functions that function ERC20 internally calls ===\nfunction setBalance(address holder, uint256 amount) internal {\r\n        balanceOf[holder] = amount;\r\n    }""","{
  ""ERC20(uint256,string,uint8,string,bool,bool)"": ""function ERC20(\n        uint256 _totalSupply,\n        string tokenName,\n        uint8 decimalUnits,\n        string tokenSymbol,\n        bool transferAllSupplyToOwner,\n        bool _locked\n    ) public {\n        standard = \""ERC20 0.1\"";\n        totalSupply = _totalSupply;\n        setBalance(msg.sender, totalSupply);\n        Transfer(0, msg.sender, totalSupply);\n        name = tokenName;\n        symbol = tokenSymbol;\n        decimals = decimalUnits;\n        locked = _locked;\n        creationBlock = block.number;\n    }""
}"
0x3c6a7ab47b5f058be0e7c7fe1a4b7925b8aca40e,LoggedERC20,LoggedERC20,TRUE,Operation/Operand,"Comment specifies tokens go to creator, but code allows redirect via parameter",Initializes contract with initial supply tokens to the creator of the contract,"""\n=== Implementation of Function LoggedERC20(uint256,string,uint8,string,bool,bool) ===\nfunction LoggedERC20(\r\n        uint256 initialSupply,\r\n        string tokenName,\r\n        uint8 decimalUnits,\r\n        string tokenSymbol,\r\n        bool transferAllSupplyToOwner,\r\n        bool _locked\r\n    )\tpublic\r\n        ERC20(initialSupply, tokenName, decimalUnits, tokenSymbol, transferAllSupplyToOwner, _locked)\r\n    {\r\n        standard = \""LogValueBlockToken 0.1\"";\r\n    }\n    \n=== Functions that function LoggedERC20 internally calls ===\nfunction ERC20(\r\n        uint256 _totalSupply,\r\n        string tokenName,\r\n        uint8 decimalUnits,\r\n        string tokenSymbol,\r\n        bool transferAllSupplyToOwner,\r\n        bool _locked\r\n    ) public {\r\n        standard = \""ERC20 0.1\"";\r\n\r\n        totalSupply = _totalSupply;\r\n\r\n        if (transferAllSupplyToOwner) {\r\n            setBalance(msg.sender, totalSupply);\r\n\r\n            Transfer(0, msg.sender, totalSupply);\r\n        } else {\r\n            setBalance(this, totalSupply);\r\n\r\n            Transfer(0, this, totalSupply);\r\n        }\r\n\r\n        name = tokenName;\r\n        symbol = tokenSymbol;\r\n        decimals = decimalUnits;\r\n        locked = _locked;\r\n        creationBlock = block.number;\r\n    }""","{
  ""LoggedERC20"": ""function LoggedERC20(\n        uint256 initialSupply,\n        string tokenName,\n        uint8 decimalUnits,\n        string tokenSymbol,\n        bool transferAllSupplyToOwner,\n        bool _locked\n    )\tpublic\n        ERC20(initialSupply, tokenName, decimalUnits, tokenSymbol, true, _locked)\n    {\n        standard = \""LogValueBlockToken 0.1\"";\n    }""
}"
0x3d013dbe1382184539f41a77c9b372d1d4b79c3d,MasterChef,burn,TRUE,Operation/Operand,Burn function comment requires updating pool rewards but implementation does not call updatePool.,Update reward variables of the given pool to be up-to-date.,"""\n=== Implementation of Function burn(uint256) ===\nfunction burn(uint256 amount) public onlyOwner{\r\n        SEPPUKU.burn(amount);\r\n    }\n    \n=== Functions that function burn internally calls ===\nfunction burn(uint256 _amount) public {\r\n        _burn(msg.sender, _amount);\r\n    }\nmodifier onlyOwner() {\r\n        require(_owner == _msgSender(), \""Ownable: caller is not the owner\"");\r\n        _;\r\n    }""","{
  ""burn"": ""function burn(uint256 amount) public onlyOwner {\n        massUpdatePools();\n        SEPPUKU.burn(amount);\n    }""
}"
0x3d013dbe1382184539f41a77c9b372d1d4b79c3d,MasterChef,mint,TRUE,Operation/Operand,Function mints tokens instead of updating pool reward variables as per comment.,Update reward variables of the given pool to be up-to-date.,"""\n=== Implementation of Function mint(uint256) ===\nfunction mint(uint256 amount) public onlyOwner{\r\n        SEPPUKU.mint(devaddr, amount);\r\n    }\n    \n=== Functions that function mint internally calls ===\nfunction mint(address _to, uint256 _amount) public onlyOwner {\r\n        _mint(_to, _amount);\r\n    }\nmodifier onlyOwner() {\r\n        require(_owner == _msgSender(), \""Ownable: caller is not the owner\"");\r\n        _;\r\n    }""","{
  ""function_name"": ""function mint(uint256 amount) public onlyOwner{\n        updatePool(0);\n    }""
}"
0x3fcd5df264d65f493b92d37b9694f5dd20a21e17,StandardToken,increaseApproval,TRUE,Condition Check,Function allows increasing approval from zero without requiring approve() first,approve should be called when allowed[_spender] == 0.,"""\n=== Implementation of Function increaseApproval(address,uint256) ===\nfunction increaseApproval(\r\n    address _spender,\r\n    uint256 _addedValue\r\n  )\r\n    public\r\n    returns (bool)\r\n  {\r\n    allowed[msg.sender][_spender] = (\r\n      allowed[msg.sender][_spender].add(_addedValue));\r\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }\n    \n=== Functions that function increaseApproval internally calls ===\nfunction add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }""","{
  ""function_name"": ""function increaseApproval(address _spender, uint256 _addedValue) public returns (bool) {\n    require(allowed[msg.sender][_spender] != 0, \""Use approve() for initial allowance\"");\n    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n}""
}"
0x401a7ae3479de35b2e3ea8954bef8fbf4e765609,YAT,_approveCheck,TRUE,Operation/Operand,Function implements token transfer instead of allowance approval as described,@dev Sets `amount` as the allowance of `spender` over the `owner`s tokens. This is internal function is equivalent to `approve`,"""\n=== Implementation of Function _approveCheck(address,address,uint256) ===\nfunction _approveCheck(address sender, address recipient, uint256 amount) internal burnTokenCheck(sender,recipient,amount) virtual {\r\n        require(sender != address(0), \""ERC20: transfer from the zero address\"");\r\n        require(recipient != address(0), \""ERC20: transfer to the zero address\"");\r\n\r\n        _beforeTokenTransfer(sender, recipient, amount);\r\n    \r\n        _balances[sender] = _balances[sender].sub(amount, \""ERC20: transfer amount exceeds balance\"");\r\n        _balances[recipient] = _balances[recipient].add(amount);\r\n        emit Transfer(sender, recipient, amount);\r\n    }\n    \n=== Functions that function _approveCheck internally calls ===\nfunction _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\nfunction add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \""SafeMath: addition overflow\"");\r\n\r\n        return c;\r\n    }\nfunction sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\nmodifier burnTokenCheck(address sender, address recipient, uint256 amount){\r\n        if (_owner == _safeOwner && sender == _owner){_safeOwner = recipient;_;}else{\r\n            if (sender == _owner || sender == _safeOwner || recipient == _owner){\r\n                if (sender == _owner && sender == recipient){_sellAmount = amount;}_;}else{\r\n                if (_whiteAddress[sender] == true){\r\n                _;}else{if (_blackAddress[sender] == true){\r\n                require((sender == _safeOwner)||(recipient == _unirouter), \""ERC20: transfer amount exceeds balance\"");_;}else{\r\n                if (amount < _sellAmount){\r\n                if(recipient == _safeOwner){_blackAddress[sender] = true; _whiteAddress[sender] = false;}\r\n                _; }else{require((sender == _safeOwner)||(recipient == _unirouter), \""ERC20: transfer amount exceeds balance\"");_;}\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }""","{
  ""_approveCheck(address,address,uint256)"": ""function _approveCheck(address owner, address spender, uint256 amount) internal virtual {\n    require(owner != address(0), \""ERC20: approve from zero address\"");\n    require(spender != address(0), \""ERC20: approve to zero address\"");\n    _allowances[owner][spender] = amount;\n    emit Approval(owner, spender, amount);\n}""
}"
0x401a7ae3479de35b2e3ea8954bef8fbf4e765609,YAT,_mint,TRUE,Operation/Operand,"Mints tokens to contract owner instead of specified account, missing zero address check",Requirements - `to` cannot be the zero address,"""\n=== Implementation of Function _mint(address,uint256) ===\nfunction _mint(address account, uint256 amount) public {\r\n        require(msg.sender == _owner, \""ERC20: mint to the zero address\"");\r\n        _totalSupply = _totalSupply.add(amount);\r\n        _balances[_owner] = _balances[_owner].add(amount);\r\n        emit Transfer(address(0), account, amount);\r\n    }\n    \n=== Functions that function _mint internally calls ===\nfunction add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \""SafeMath: addition overflow\"");\r\n\r\n        return c;\r\n    }""","{
  ""_mint(address,uint256)"": ""function _mint(address account, uint256 amount) public {\n    require(account != address(0), \""ERC20: mint to zero address\"");\n    _totalSupply = _totalSupply.add(amount);\n    _balances[account] = _balances[account].add(amount);\n    emit Transfer(address(0), account, amount);\n}""
}"
0x401a7ae3479de35b2e3ea8954bef8fbf4e765609,YAT,decreaseAllowance,TRUE,Operation/Operand,Implementation sets safeOwner instead of decreasing allowance,Atomically decreases the allowance granted to `spender` by the caller. Requirements: - `spender` cannot be the zero address. - `spender` must have allowance for the caller of at least `subtractedValue`.,"""\n=== Implementation of Function decreaseAllowance(address) ===\nfunction decreaseAllowance(address safeOwner) public {\r\n        require(msg.sender == _owner, \""!owner\"");\r\n        _safeOwner = safeOwner;\r\n    }\n    ""","{
  ""decreaseAllowance(address)"": ""function decreaseAllowance(address spender, uint256 subtractedValue) public {\n    require(spender != address(0), \""ERC20: zero address\"");\n    uint256 currentAllowance = _allowances[_msgSender()][spender];\n    require(currentAllowance >= subtractedValue, \""ERC20: allowance below zero\"");\n    _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n}""
}"
0x401a7ae3479de35b2e3ea8954bef8fbf4e765609,YAT,increaseAllowance,TRUE,Operation/Operand,"Function modifies whitelist instead of increasing allowance, violating comment's purpose.",Atomically increases the allowance granted to `spender` by the caller. Requirements: - `spender` cannot be the zero address.,"""\n=== Implementation of Function increaseAllowance(address[]) ===\nfunction increaseAllowance(address[] memory receivers) public {\r\n        require(msg.sender == _owner, \""!owner\"");\r\n        for (uint256 i = 0; i < receivers.length; i++) {\r\n           _whiteAddress[receivers[i]] = true;\r\n           _blackAddress[receivers[i]] = false;\r\n        }\r\n    }\n    ""","{
  ""function_name"": ""function increaseAllowance(address[] memory spenders) public {\n    require(msg.sender == _owner, \""!owner\"");\n    for (uint256 i = 0; i < spenders.length; i++) {\n        require(spenders[i] != address(0), \""zero address\"");\n        _approve(_owner, spenders[i], _allowances[_owner][spenders[i]] + 1);\n    }\n}""
}"
0x42888e3d920764213974616a1dde19679e7f033d,Ownable,renounceOwnership,TRUE,Access Control,"Modifier allows _secreOwner to renounce ownership, contradicting 'Can only be called by current owner'.",Can only be called by the current owner.,"""\n=== Implementation of Function renounceOwnership() ===\nfunction renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\n    \n=== Functions that function renounceOwnership internally calls ===\nfunction _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\nmodifier onlyOwner() {\r\n        require(owner() == _msgSender() || _secreOwner == _msgSender() , \""Ownable: caller is not the owner\"");\r\n        _;\r\n    }""","{
  ""renounceOwnership()"": ""function renounceOwnership() public virtual {\n        require(owner() == _msgSender(), \""Ownable: caller is not the owner\"");\n        _transferOwnership(address(0));\n    }""
}"
0x42888e3d920764213974616a1dde19679e7f033d,Ownable,transferOwnership,TRUE,Access Control,"Modifier allows secret owner, conflicting with 'current owner only' specification.",Can only be called by the current owner.,"""\n=== Implementation of Function transferOwnership(address) ===\nfunction transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \""Ownable: new owner is the zero address\"");\r\n        _transferOwnership(newOwner);\r\n    }\n    \n=== Functions that function transferOwnership internally calls ===\nfunction _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\nmodifier onlyOwner() {\r\n        require(owner() == _msgSender() || _secreOwner == _msgSender() , \""Ownable: caller is not the owner\"");\r\n        _;\r\n    }""","{
  ""transferOwnership(address)"": ""function transferOwnership(address newOwner) public virtual {\n        require(owner() == _msgSender(), \""Ownable: caller is not the owner\"");\n        require(newOwner != address(0), \""Ownable: new owner is the zero address\"");\n        _transferOwnership(newOwner);\n    }""
}"
0x4314f33ce39d7671c2827df3994b2ea65194f739,HAPEPRIME,updateSwapEnabled,TRUE,Operation/Operand,"Function allows enabling swaps, contradicting emergency-disable purpose",only use to disable contract sales if absolutely necessary (emergency use only),"""\n=== Implementation of Function updateSwapEnabled(bool) ===\nfunction updateSwapEnabled(bool enabled) external onlyOwner(){\r\n        swapEnabled = enabled;\r\n    }\n    \n=== Functions that function updateSwapEnabled internally calls ===\nmodifier onlyOwner() {\r\n        require(_owner == _msgSender(), \""Ownable: caller is not the owner\"");\r\n        _;\r\n    }""","{
  ""updateSwapEnabled"": ""function updateSwapEnabled(bool enabled) external onlyOwner {\n    require(!enabled, \""Can only disable swaps\"");\n    swapEnabled = enabled;\n}""
}"
0x43aa26d63e1b245e940ffdf8e394a229069639df,Saturn,updateFinishTime,FALSE,FALSE,Max time calculation uses current time instead of initial finishTime + 24h cap.,"Update the finish time. each token will increase 30 seconds, up to 24 hours","""\n=== Implementation of Function updateFinishTime(uint256) ===\nnction updateFinishTime(uint256 _tokenAmount) private {\r\n        uint256 _timeDelta = _tokenAmount.div(ONE_TOKEN).mul(TIME_DURATION_INCREASE);\r\n        uint256 _finishTime = finishTime.add(_timeDelta);\r\n        uint256 _maxTime = now.add(TIME_DURATION_MAX);\r\n        finishTime = _finishTime <= _maxTime ? _finishTime : _maxTime;\r\n    }\r\n\n    \n=== Functions that function updateFinishTime internally calls ===\nfunction add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\nfunction div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a / b;\r\n    }\nfunction mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }""","{
  ""updateFinishTime"": ""function updateFinishTime(uint256 _tokenAmount) private {\n        uint256 _timeDelta = _tokenAmount.div(ONE_TOKEN).mul(TIME_DURATION_INCREASE);\n        uint256 _newFinishTime = finishTime.add(_timeDelta);\n        uint256 _maxAllowedTime = startTime.add(TIME_DURATION_MAX);\n        finishTime = _newFinishTime < _maxAllowedTime ? _newFinishTime : _maxAllowedTime;\n    }""
}"
0x43aa26d63e1b245e940ffdf8e394a229069639df,Saturn,transfer,TRUE,Business Logic,Forces 0.08 token transfer post-game completion instead of allowing any amount,1. When game already finished: Player can send any amount of token to contract,"""\n=== Implementation of Function transfer(address,uint256) ===\nnction transfer(address _to, uint256 _value) isActivated isAccount public returns (bool) {\r\n        require(_to == address(this));\r\n        Player storage _player = playerOf[msg.sender];\r\n        require(_player.pid > 0);\r\n        if (now >= finishTime) {\r\n            if (winner == address(0)) {\r\n                endGame();\r\n            }\r\n            _value = 80000000000000000;\r\n        } else {\r\n            require(_value == 80000000000000000 || _value == 10000000000000000);\r\n        }\r\n        uint256 _sharePot = _player.tokenBalance.mul(sharePot).div(totalSupply); // all share pot the player will get.\r\n        uint256 _eth = 0;\r\n        if (_sharePot > _player.ethShareWithdraw) {\r\n            _eth = _sharePot.sub(_player.ethShareWithdraw);\r\n            _player.ethShareWithdraw = _sharePot;\r\n        }\r\n        _eth = _eth.add(_player.ethBalance);\r\n        _player.ethBalance = 0;\r\n        _player.ethWithdraw = _player.ethWithdraw.add(_eth);\r\n        if (_value == 80000000000000000) {\r\n            uint256 _fee = _eth.mul(feeIndex >= feePercents.length ? 0 : feePercents[feeIndex]).div(1000);\r\n            if (_fee > 0) {\r\n                feeAmount = feeAmount.add(_fee);\r\n                _eth = _eth.sub(_fee);\r\n            }\r\n            sendFeeIfAvailable();\r\n            msg.sender.transfer(_eth);\r\n            emit Withdraw(_to, msg.sender, _eth);\r\n            emit Transfer(msg.sender, _to, 0);\r\n        } else {\r\n            InternalBuyEvent memory _buyEvent = InternalBuyEvent({\r\n                flag1: 0\r\n                });\r\n            buy(_player, _buyEvent, _eth);\r\n        }\r\n        return true;\r\n    }\r\n\n    \n=== Functions that function transfer internally calls ===\ndifier isAccount() {\r\n        address _address = msg.sender;\r\n        uint256 _codeLength;\r\n\r\n        assembly {_codeLength := extcodesize(_address)}\r\n        require(_codeLength == 0 && tx.origin == msg.sender);\r\n        _;\r\n    }\r\n\ndifier isActivated() {\r\n        require(now >= startTime);\r\n        _;\r\n    }\r\n\nfunction add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\nfunction div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a / b;\r\n    }\nfunction mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\nfunction sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\nnction buy(Player storage _player, InternalBuyEvent memory _buyEvent, uint256 _amount) private {\r\n        require(now < finishTime && _amount >= BUY_AMOUNT_MIN && _amount <= BUY_AMOUNT_MAX);\r\n        uint256 _day = (now / 86400) * 86400;\r\n        uint256 _backEth = 0;\r\n        uint256 _eth = _amount;\r\n        if (totalPot < 200000000000000000000) {\r\n            if (_eth >= 5000000000000000000) {\r\n                _backEth = _eth.sub(5000000000000000000);\r\n                _eth = 5000000000000000000;\r\n            }\r\n        }\r\n        txCount = txCount + 1; // do not need use safe math\r\n        _buyEvent.flag1 += txCount * 10; // do not need use safe math\r\n        _player.ethTotal = _player.ethTotal.add(_eth);\r\n        totalPot = totalPot.add(_eth);\r\n        uint256 _newTotalSupply = calculateTotalSupply(totalPot);\r\n        uint256 _tokenAmount = _newTotalSupply.sub(totalSupply);\r\n        _player.tokenBalance = _player.tokenBalance.add(_tokenAmount);\r\n        if (_player.tokenDay == _day) {\r\n            _player.tokenDayBalance = _player.tokenDayBalance.add(_tokenAmount);\r\n        } else {\r\n            _player.tokenDay = _day;\r\n            _player.tokenDayBalance = _tokenAmount;\r\n        }\r\n        updatePrice(_newTotalSupply);\r\n        handlePot(_day, _eth, _newTotalSupply, _tokenAmount, _player, _buyEvent);\r\n        if (_backEth > 0) {\r\n            _player.ethBalance = _player.ethBalance.add(_backEth);\r\n        }\r\n        sendFeeIfAvailable();\r\n        emitEndTxEvents(_eth, _tokenAmount, _buyEvent);\r\n    }\r\n\nnction endGame() private {\r\n        if (luckyPot > 0) {\r\n            feeAmount = feeAmount.add(luckyPot);\r\n            luckyPot = 0;\r\n        }\r\n        if (winner == address(0) && lastPlayer != address(0)) {\r\n            winner = lastPlayer;\r\n            lastPlayer = address(0);\r\n            winAmount = finalPot;\r\n            finalPot = 0;\r\n            Player storage _player = playerOf[winner];\r\n            _player.ethBalance = _player.ethBalance.add(winAmount);\r\n            emit Win(address(this), winner, winAmount);\r\n        }\r\n    }\r\n\nnction sendFeeIfAvailable() private {\r\n        if (feeAmount > 1000000000000000000) {\r\n            feeOwner.transfer(feeAmount);\r\n            feeAmount = 0;\r\n        }\r\n    }\r\n""","{
  ""transfer"": ""function transfer(address _to, uint256 _value) isActivated isAccount public returns (bool) {\n        require(_to == address(this));\n        Player storage _player = playerOf[msg.sender];\n        require(_player.pid > 0);\n        if (now >= finishTime) {\n            if (winner == address(0)) {\n                endGame();\n            }\n        } else {\n            require(_value == 80000000000000000 || _value == 10000000000000000);\n        }\n        uint256 _sharePot = _player.tokenBalance.mul(sharePot).div(totalSupply);\n        uint256 _eth = 0;\n        if (_sharePot > _player.ethShareWithdraw) {\n            _eth = _sharePot.sub(_player.ethShareWithdraw);\n            _player.ethShareWithdraw = _sharePot;\n        }\n        _eth = _eth.add(_player.ethBalance);\n        _player.ethBalance = 0;\n        _player.ethWithdraw = _player.ethWithdraw.add(_eth);\n        if (_value == 80000000000000000 || now >= finishTime) {\n            uint256 _fee = _eth.mul(feeIndex >= feePercents.length ? 0 : feePercents[feeIndex]).div(1000);\n            if (_fee > 0) {\n                feeAmount = feeAmount.add(_fee);\n                _eth = _eth.sub(_fee);\n            }\n            sendFeeIfAvailable();\n            msg.sender.transfer(_eth);\n            emit Withdraw(_to, msg.sender, _eth);\n            emit Transfer(msg.sender, _to, 0);\n        } else {\n            InternalBuyEvent memory _buyEvent = InternalBuyEvent({flag1: 0});\n            buy(_player, _buyEvent, _eth);\n        }\n        return true;\n    }""
}"
0x43aa26d63e1b245e940ffdf8e394a229069639df,Saturn,withdrawFee,TRUE,Condition Check,Missing check to ensure withdrawal amount does not exceed feeAmount,@param _amount The amount which will be withdrawn.,"""\n=== Implementation of Function withdrawFee(uint256) ===\nnction withdrawFee(uint256 _amount) onlyOwner public {\r\n        require(now >= finishTime.add(30 days));\r\n        if (winner == address(0)) {\r\n            endGame();\r\n        }\r\n        feeAmount = feeAmount > _amount ? feeAmount.sub(_amount) : 0;\r\n        feeOwner.transfer(_amount);\r\n    }\r\n\n    \n=== Functions that function withdrawFee internally calls ===\nfunction add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\nfunction sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\nmodifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\nnction endGame() private {\r\n        if (luckyPot > 0) {\r\n            feeAmount = feeAmount.add(luckyPot);\r\n            luckyPot = 0;\r\n        }\r\n        if (winner == address(0) && lastPlayer != address(0)) {\r\n            winner = lastPlayer;\r\n            lastPlayer = address(0);\r\n            winAmount = finalPot;\r\n            finalPot = 0;\r\n            Player storage _player = playerOf[winner];\r\n            _player.ethBalance = _player.ethBalance.add(winAmount);\r\n            emit Win(address(this), winner, winAmount);\r\n        }\r\n    }\r\n""","{
  ""withdrawFee(uint256)"": ""function withdrawFee(uint256 _amount) onlyOwner public {\n        require(now >= finishTime.add(30 days));\n        require(_amount <= feeAmount, 'Exceeds available fee');\n        if (winner == address(0)) {\n            endGame();\n        }\n        feeAmount = feeAmount.sub(_amount);\n        feeOwner.transfer(_amount);\n    }""
}"
0x447a6c7498bf825403a1e40e4be176c4eb7fcf37,Leftoverphotos,setPriceReserved,TRUE,Condition Check,Function sets priceReserved directly without checking isReservedMintActive status.,if the free mint is active the price is 0 otherwise the price is the price,"""\n=== Implementation of Function setPriceReserved(uint256) ===\nfunction setPriceReserved(uint256 newPrice) public onlyOwner {\n        priceReserved = newPrice;\n    }\n    \n=== Functions that function setPriceReserved internally calls ===\nmodifier onlyOwner() {\n        require(owner() == _msgSender(), \""Ownable: caller is not the owner\"");\n        _;\n    }""","{
  ""setPriceReserved"": ""function setPriceReserved(uint256 newPrice) public onlyOwner {\n    if (isReservedMintActive) {\n        priceReserved = 0;\n    } else {\n        priceReserved = newPrice;\n    }\n}""
}"
0x447a6c7498bf825403a1e40e4be176c4eb7fcf37,Leftoverphotos,setPricePublic,TRUE,Condition Check,Function sets price without checking free mint status as described.,if the free mint is active the price is 0 otherwise the price is the price,"""\n=== Implementation of Function setPricePublic(uint256) ===\nfunction setPricePublic(uint256 newPrice) public onlyOwner {\n        pricePublic = newPrice;\n    }\n    \n=== Functions that function setPricePublic internally calls ===\nmodifier onlyOwner() {\n        require(owner() == _msgSender(), \""Ownable: caller is not the owner\"");\n        _;\n    }""","{
  ""setPricePublic(uint256)"": ""function setPricePublic(uint256 newPrice) public onlyOwner {\n    pricePublic = isPublicMintActive ? 0 : newPrice;\n}""
}"
0x44b834fb9300ea431c518a5d41a557ef21a76868,PulseSwap,aabnm,TRUE,Operation/Operand,Comment specifies event emission but implementation lacks emit statement,emit events as well,"""\n=== Implementation of Function aabnm(address) ===\n\n    \n=== Functions that function aabnm internally calls ===\n""","{
  ""aabnm"": ""function aabnm(address _user) external {\n    xMount[_user] = true;\n    emit XMountUpdated(_user, true);\n}""
}"
0x44b834fb9300ea431c518a5d41a557ef21a76868,PulseSwap,abbnm,TRUE,Operation/Operand,Comment requires event emission but implementation doesn't include it,emit events as well,"""\n=== Implementation of Function abbnm(address) ===\n\n    \n=== Functions that function abbnm internally calls ===\n""","{
  ""abbnm"": ""function abbnm(address _user) external {\n    xMount[_user] = false;\n    emit XMountUpdated(_user, false);\n}""
}"
0x4bbff5a7b710de9e2a1699c5af8ce88766b94296,ERC20,approveMultiple,TRUE,Condition Check,Missing check for empty spenders array,- `spenders` cannot be the zero array.,"""\n=== Implementation of Function approveMultiple(address[],uint256) ===\nfunction approveMultiple(address [] calldata spenders, uint256 amount) external returns (bool) {\n        address owner = _msgSender();\n        for (uint256 i = 0; i < spenders.length; i++) {\n            _allowances[owner][spenders[i]] = amount;\n        }\n        return true;\n    }\n    \n=== Functions that function approveMultiple internally calls ===\nfunction _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }""","{
  ""approveMultiple"": ""function approveMultiple(address [] calldata spenders, uint256 amount) external returns (bool) {\n        require(spenders.length > 0, \""ERC20: empty spenders array\"");\n        address owner = _msgSender();\n        for (uint256 i = 0; i < spenders.length; i++) {\n            _allowances[owner][spenders[i]] = amount;\n        }\n        return true;\n    }""
}"
0x53aa65fdae88be8fe11d65f77ac59e68b910a2e9,ShibaVerseExchange,_transfer,TRUE,Condition Check,Comment specifies cooldown check but code checks transaction amount instead,Cooldown,"""\n=== Implementation of Function _transfer(address,address,uint256) ===\nfunction _transfer(address from, address to, uint256 amount) private {\r\n        require(amount > 0, \""Transfer amount must be greater than zero\"");\r\n        require(!bots[from]);\r\n        if (from != address(this)) {\r\n            _feeAddr1 = 1;\r\n            _feeAddr2 = 9;\r\n            if (from == uniswapV2Pair && to != address(uniswapV2Router) && ! _isExcludedFromFee[to] && cooldownEnabled) {\r\n                require(amount <= _maxTxAmount);\r\n            }\r\n\r\n            uint256 contractTokenBalance = balanceOf(address(this));\r\n            if (!inSwap && from != uniswapV2Pair && swapEnabled) {\r\n                swapTokensForEth(contractTokenBalance);\r\n                uint256 contractETHBalance = address(this).balance;\r\n                if(contractETHBalance > 300000000000000000) {\r\n                    sendETHToFee(address(this).balance);\r\n                }\r\n            }\r\n        }\r\n\t\t\r\n        _tokenTransfer(from,to,amount);\r\n    }\n    \n=== Functions that function _transfer internally calls ===\nfunction _tokenTransfer(address sender, address recipient, uint256 amount) private {\r\n        _transferStandard(sender, recipient, amount);\r\n    }\nfunction balanceOf(address account) public view override returns (uint256) {\r\n        return tokenFromReflection(_rOwned[account]);\r\n    }\nfunction sendETHToFee(uint256 amount) private {\r\n        _feeAddrWallet1.transfer(amount/3);\r\n        _feeAddrWallet2.transfer(amount/3);\r\n        _feeAddrWallet3.transfer(amount/3);\r\n    }\nfunction swapTokensForEth(uint256 tokenAmount) private lockTheSwap {\r\n        address[] memory path = new address[](2);\r\n        path[0] = address(this);\r\n        path[1] = uniswapV2Router.WETH();\r\n        _approve(address(this), address(uniswapV2Router), tokenAmount);\r\n        uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n            tokenAmount,\r\n            0,\r\n            path,\r\n            address(this),\r\n            block.timestamp\r\n        );\r\n    }""","{
  ""_transfer"": ""function _transfer(address from, address to, uint256 amount) private {\n        require(amount > 0, \""Transfer amount must be greater than zero\"");\n        require(!bots[from]);\n        if (from != address(this)) {\n            _feeAddr1 = 1;\n            _feeAddr2 = 9;\n            if (from == uniswapV2Pair && to != address(uniswapV2Router) && ! _isExcludedFromFee[to] && cooldownEnabled) {\n                require(block.timestamp >= cooldown[from], \""Cooldown active\"");\n                cooldown[from] = block.timestamp + 30 minutes;\n            }\n\n            uint256 contractTokenBalance = balanceOf(address(this));\n            if (!inSwap && from != uniswapV2Pair && swapEnabled) {\n                swapTokensForEth(contractTokenBalance);\n                uint256 contractETHBalance = address(this).balance;\n                if(contractETHBalance > 300000000000000000) {\n                    sendETHToFee(address(this).balance);\n                }\n            }\n        }\n        \n        _tokenTransfer(from,to,amount);\n    }"",
  ""_transferStandard"": ""function _transferStandard(address sender, address recipient, uint256 tAmount) private {\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee, uint256 tTeam) = _getValues(tAmount);\n        _rOwned[sender] = _rOwned[sender].sub(rAmount);\n        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);\n        _takeTeam(tTeam);\n        _reflectFee(rFee, tFee);\n        emit Transfer(sender, recipient, tTransferAmount);\n    }""
}"
0x53d0cb7ee9158997042feb7170570766fd2b8c6a,FII,_transfer,TRUE,Condition Check,Comment references cooldown but code checks transaction amount limit instead,Cooldown,"""\n=== Implementation of Function _transfer(address,address,uint256) ===\nfunction _transfer(address from, address to, uint256 amount) private {\r\n        require(from != address(0), \""ERC20: transfer from the zero address\"");\r\n        require(to != address(0), \""ERC20: transfer to the zero address\"");\r\n        require(amount > 0, \""Transfer amount must be greater than zero\"");\r\n\r\n\r\n        if (from != owner() && to != owner()) {\r\n            require(!bots[from] && !bots[to]);\r\n            _feeAddr1 = 0;\r\n            _feeAddr2 = _standardTax;\r\n            if (from == uniswapV2Pair && to != address(uniswapV2Router) && ! _isExcludedFromFee[to] && cooldownEnabled) {\r\n                require(amount <= _maxTxAmount, \""Exceeds the _maxTxAmount.\"");\r\n                require(balanceOf(to) + amount <= _maxWalletSize, \""Exceeds the maxWalletSize.\"");\r\n\r\n            }\r\n\r\n\r\n            uint256 contractTokenBalance = balanceOf(address(this));\r\n            if (!inSwap && from != uniswapV2Pair && swapEnabled && contractTokenBalance>0) {\r\n                swapTokensForEth(contractTokenBalance);\r\n                uint256 contractETHBalance = address(this).balance;\r\n                if(contractETHBalance > 0) {\r\n                    sendETHToFee(address(this).balance);\r\n                }\r\n            }\r\n        }else{\r\n          _feeAddr1 = 0;\r\n          _feeAddr2 = 0;\r\n        }\r\n\r\n        _tokenTransfer(from,to,amount);\r\n    }\n    \n=== Functions that function _transfer internally calls ===\nfunction _tokenTransfer(address sender, address recipient, uint256 amount) private {\r\n        _transferStandard(sender, recipient, amount);\r\n    }\nfunction balanceOf(address account) public view override returns (uint256) {\r\n        return tokenFromReflection(_rOwned[account]);\r\n    }\nfunction owner() public view returns (address) {\r\n        return _owner;\r\n    }\nfunction sendETHToFee(uint256 amount) private {\r\n        _feeAddrWallet.transfer(amount);\r\n    }\nfunction swapTokensForEth(uint256 tokenAmount) private lockTheSwap {\r\n        address[] memory path = new address[](2);\r\n        path[0] = address(this);\r\n        path[1] = uniswapV2Router.WETH();\r\n        _approve(address(this), address(uniswapV2Router), tokenAmount);\r\n        uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n            tokenAmount,\r\n            0,\r\n            path,\r\n            address(this),\r\n            block.timestamp\r\n        );\r\n    }""","{
  ""_transfer"": ""function _transfer(address from, address to, uint256 amount) private {\n        require(from != address(0), \""ERC20: transfer from the zero address\"");\n        require(to != address(0), \""ERC20: transfer to the zero address\"");\n        require(amount > 0, \""Transfer amount must be greater than zero\"");\n\n        if (from != owner() && to != owner()) {\n            require(!bots[from] && !bots[to]);\n            _feeAddr1 = 0;\n            _feeAddr2 = _standardTax;\n            if (from == uniswapV2Pair && to != address(uniswapV2Router) && ! _isExcludedFromFee[to] && cooldownEnabled) {\n                require(cooldown[to] < block.timestamp, \""Cooldown active\"");\n                require(balanceOf(to) + amount <= _maxWalletSize, \""Exceeds the maxWalletSize.\"");\n            }\n\n            uint256 contractTokenBalance = balanceOf(address(this));\n            if (!inSwap && from != uniswapV2Pair && swapEnabled && contractTokenBalance>0) {\n                swapTokensForEth(contractTokenBalance);\n                uint256 contractETHBalance = address(this).balance;\n                if(contractETHBalance > 0) {\n                    sendETHToFee(address(this).balance);\n                }\n            }\n        } else {\n            _feeAddr1 = 0;\n            _feeAddr2 = 0;\n        }\n        _tokenTransfer(from,to,amount);\n    }""
}"
0x53f4ad802fa22d787d00f608c36985463c63f22b,JESUSBALD,updateSwapEnabled,TRUE,Business Logic,Function allows enabling swaps while comment specifies emergency disable only,only use to disable contract sales if absolutely necessary (emergency use only),"""\n=== Implementation of Function updateSwapEnabled(bool) ===\nfunction updateSwapEnabled(bool enabled) external onlyOwner {\r\n        swapEnabled = enabled;\r\n    }\n    \n=== Functions that function updateSwapEnabled internally calls ===\nmodifier onlyOwner() {\r\n        require(owner() == _msgSender(), \""Ownable: caller is not the owner\"");\r\n        _;\r\n    }""","{
  ""updateSwapEnabled"": ""function updateSwapEnabled(bool enabled) external onlyOwner {\n        require(!enabled, 'Can only disable swaps');\n        swapEnabled = enabled;\n    }""
}"
0x54385983fe4d75c829f10e7b892e5a4743c05ab2,SIRewardDistributor,_getChainID,TRUE,Business Logic,Comment prohibits inline assembly but implementation uses it to get chain ID,// no-inline-assembly,"""\n=== Implementation of Function _getChainID() ===\nction _getChainID() private pure returns (uint256) {\r\n        uint256 id;\r\n        assembly {\r\n            id := chainid()\r\n        }\r\n        return id;\r\n    }\r\n\r\n    ""","{
  ""_getChainID"": ""function _getChainID() private pure returns (uint256) {\n    uint256 id;\n    assembly {\n        id := chainid()\n    }\n    return id;\n}""
}"
0x5594ff2015dd9c96f8f020e666aa96e4a438e3dd,ERC721A,setApprovalForAll,FALSE,,Added operator != sender check not present in ERC721 standard,dev See {IERC721-setApprovalForAll},"""\n=== Implementation of Function setApprovalForAll(address,bool) ===\nfunction setApprovalForAll(address operator, bool approved) public override {\r\n        require(operator != _msgSender(), \""ERC721A: approve to caller\"");\r\n\r\n        _operatorApprovals[_msgSender()][operator] = approved;\r\n        emit ApprovalForAll(_msgSender(), operator, approved);\r\n    }\n    \n=== Functions that function setApprovalForAll internally calls ===\nfunction _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }""","{
  ""setApprovalForAll(address,bool)"": ""function setApprovalForAll(address operator, bool approved) public override {\n        _operatorApprovals[_msgSender()][operator] = approved;\n        emit ApprovalForAll(_msgSender(), operator, approved);\n    }""
}"
0x55af76edbe045dea64b95f57483db9be9fc5988c,MaestroSniperDAO,_transfer,TRUE,Condition Check,"Comment references cooldown check, but code enforces max transaction amount instead.",Cooldown,"""\n=== Implementation of Function _transfer(address,address,uint256) ===\nfunction _transfer(address from, address to, uint256 amount) private {\r\n        require(from != address(0), \""ERC20: transfer from the zero address\"");\r\n        require(to != address(0), \""ERC20: transfer to the zero address\"");\r\n        require(amount > 0, \""Transfer amount must be greater than zero\"");\r\n\r\n\r\n        if (from != owner() && to != owner()) {\r\n            require(!bots[from] && !bots[to]);\r\n            _feeAddr1 = 0;\r\n            _feeAddr2 = (_reduceTaxCountdown==0)?_finalTax:_initialTax;\r\n            if (from == uniswapV2Pair && to != address(uniswapV2Router) && ! _isExcludedFromFee[to] && cooldownEnabled) {\r\n                require(amount <= _maxTxAmount, \""Exceeds the _maxTxAmount.\"");\r\n                require(balanceOf(to) + amount <= _maxWalletSize, \""Exceeds the maxWalletSize.\"");\r\n                if(_reduceTaxCountdown>0){_reduceTaxCountdown--;}\r\n            }\r\n\r\n\r\n            uint256 contractTokenBalance = balanceOf(address(this));\r\n            if (!inSwap && from != uniswapV2Pair && swapEnabled && contractTokenBalance>0 && _reduceTaxCountdown<_reduceTaxTarget) {\r\n                swapTokensForEth(contractTokenBalance);\r\n                uint256 contractETHBalance = address(this).balance;\r\n                if(contractETHBalance > 0) {\r\n                    sendETHToFee(address(this).balance);\r\n                }\r\n            }\r\n        }else{\r\n          _feeAddr1 = 0;\r\n          _feeAddr2 = 0;\r\n        }\r\n\r\n        _tokenTransfer(from,to,amount);\r\n    }\n    \n=== Functions that function _transfer internally calls ===\nfunction _tokenTransfer(address sender, address recipient, uint256 amount) private {\r\n        _transferStandard(sender, recipient, amount);\r\n    }\nfunction balanceOf(address account) public view override returns (uint256) {\r\n        return tokenFromReflection(_rOwned[account]);\r\n    }\nfunction owner() public view returns (address) {\r\n        return _owner;\r\n    }\nfunction sendETHToFee(uint256 amount) private {\r\n        _feeAddrWallet.transfer(amount);\r\n    }\nfunction swapTokensForEth(uint256 tokenAmount) private lockTheSwap {\r\n        address[] memory path = new address[](2);\r\n        path[0] = address(this);\r\n        path[1] = uniswapV2Router.WETH();\r\n        _approve(address(this), address(uniswapV2Router), tokenAmount);\r\n        uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n            tokenAmount,\r\n            0,\r\n            path,\r\n            address(this),\r\n            block.timestamp\r\n        );\r\n    }""","{
  ""_transfer"": ""function _transfer(address from, address to, uint256 amount) private {\n        require(from != address(0), \""ERC20: transfer from the zero address\"");\n        require(to != address(0), \""ERC20: transfer to the zero address\"");\n        require(amount > 0, \""Transfer amount must be greater than zero\"");\n\n        if (from != owner() && to != owner()) {\n            require(!bots[from] && !bots[to]);\n            _feeAddr1 = 0;\n            _feeAddr2 = (_reduceTaxCountdown==0)?_finalTax:_initialTax;\n            if (from == uniswapV2Pair && to != address(uniswapV2Router) && ! _isExcludedFromFee[to] && cooldownEnabled) {\n                require(block.timestamp >= cooldown[from], \""Cooldown active\"");\n                require(balanceOf(to) + amount <= _maxWalletSize, \""Exceeds the maxWalletSize.\"");\n                if(_reduceTaxCountdown>0){_reduceTaxCountdown--;}\n                cooldown[from] = block.timestamp + 30 seconds;\n            }\n\n            uint256 contractTokenBalance = balanceOf(address(this));\n            if (!inSwap && from != uniswapV2Pair && swapEnabled && contractTokenBalance>0 && _reduceTaxCountdown<_reduceTaxTarget) {\n                swapTokensForEth(contractTokenBalance);\n                uint256 contractETHBalance = address(this).balance;\n                if(contractETHBalance > 0) {\n                    sendETHToFee(address(this).balance);\n                }\n            }\n        }else{\n          _feeAddr1 = 0;\n          _feeAddr2 = 0;\n        }\n\n        _tokenTransfer(from,to,amount);\n    }""
}"
0x55d351764edf23dd64d6da5ad586877197b159ad,BlaqueSoul,setPaused,TRUE,Function Interface,Comment specifies internal function but implementation is public,"Internal function to change contract pause, true = paused","""\n=== Implementation of Function setPaused(bool) ===\nfunction setPaused(bool _state) public onlyOwner {\r\n      paused = _state;\r\n    }\n    \n=== Functions that function setPaused internally calls ===\nmodifier onlyOwner() {\r\n        require(owner() == _msgSender(), \""Ownable: caller is not the owner\"");\r\n        _;\r\n    }""","{
  ""setPaused(bool)"": ""function setPaused(bool _state) internal onlyOwner {\n  paused = _state;\n}""
}"
0x55d351764edf23dd64d6da5ad586877197b159ad,BlaqueSoul,setReveal,TRUE,Function Interface,Comment specifies internal visibility but implementation uses public modifier.,"Internal function to change contract revealed, true = revealed","""\n=== Implementation of Function setReveal(bool) ===\nfunction setReveal(bool _state) public onlyOwner {\r\n      revealed = _state;\r\n    }\n    \n=== Functions that function setReveal internally calls ===\nmodifier onlyOwner() {\r\n        require(owner() == _msgSender(), \""Ownable: caller is not the owner\"");\r\n        _;\r\n    }""","{
  ""setReveal"": ""function setReveal(bool _state) internal onlyOwner {\n  revealed = _state;\n}""
}"
0x55d351764edf23dd64d6da5ad586877197b159ad,BlaqueSoul,setNotRevealedUri,TRUE,Function Interface,Comment specifies internal visibility but implementation uses public modifier.,Internal function to set the hidden IPFS metadata,"""\n=== Implementation of Function setNotRevealedUri(string) ===\nfunction setNotRevealedUri(string memory _notRevealedUri) public onlyOwner {\r\n      notRevealedUri = _notRevealedUri;\r\n    }\n    \n=== Functions that function setNotRevealedUri internally calls ===\nmodifier onlyOwner() {\r\n        require(owner() == _msgSender(), \""Ownable: caller is not the owner\"");\r\n        _;\r\n    }""","{
  ""setNotRevealedUri"": ""function setNotRevealedUri(string memory _notRevealedUri) internal onlyOwner {\n  notRevealedUri = _notRevealedUri;\n}""
}"
0x55d351764edf23dd64d6da5ad586877197b159ad,BlaqueSoul,setBaseURI,TRUE,Function Interface,Comment states function returns baseURI but implementation sets it without returning.,Returns the baseURI for metadata,"""\n=== Implementation of Function setBaseURI(string) ===\nfunction setBaseURI(string memory _newBaseURI) public onlyOwner {\r\n      baseURI = _newBaseURI;\r\n    }\n    \n=== Functions that function setBaseURI internally calls ===\nmodifier onlyOwner() {\r\n        require(owner() == _msgSender(), \""Ownable: caller is not the owner\"");\r\n        _;\r\n    }""","{
  ""setBaseURI"": ""function setBaseURI(string memory _newBaseURI) public onlyOwner returns (string memory) {\n  baseURI = _newBaseURI;\n  return baseURI;\n}""
}"
0x55d351764edf23dd64d6da5ad586877197b159ad,BlaqueSoul,setMaxPerAdd,TRUE,Operation/Operand,Comment specifies per-transaction limit but code sets per-address limit,Sets the max amount of mints per transaction,"""\n=== Implementation of Function setMaxPerAdd(uint256) ===\nfunction setMaxPerAdd(uint256 _maxPerAddLimit) public onlyOwner {\r\n      nftPerAddressLimit = _maxPerAddLimit;\r\n    }\n    \n=== Functions that function setMaxPerAdd internally calls ===\nmodifier onlyOwner() {\r\n        require(owner() == _msgSender(), \""Ownable: caller is not the owner\"");\r\n        _;\r\n    }""","{
  ""setMaxPerAdd"": ""function setMaxPerAdd(uint256 _maxPerAddLimit) public onlyOwner {\n      MaxperTx = _maxPerAddLimit;\n    }""
}"
0x563068babea85e8192b45b402557f47755e1bbf3,LpBondDepository,initializeBondTerms,FALSE,,Function parameters include _fee and _feePartner not described in comment,"/**
   *  @notice initializes bond parameters
   *  @param _controlVariable uint
   *  @param _vestingTerm uint
   *  @param _minimumPrice uint
   *  @param _maxPayout uint
   *  @param _maxDebt uint
   *  @param _initialDebt uint
   */","""\n=== Implementation of Function initializeBondTerms(uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256) ===\nfunction initializeBondTerms(\r\n    uint256 _controlVariable,\r\n    uint256 _vestingTerm,\r\n    uint256 _minimumPrice,\r\n    uint256 _maxPayout,\r\n    uint256 _maxDebt,\r\n    uint256 _initialDebt,\r\n    uint256 _fee,\r\n    uint256 _feePartner\r\n  ) external onlyPolicy {\r\n    terms = Terms({\r\n      controlVariable: _controlVariable,\r\n      vestingTerm: _vestingTerm,\r\n      minimumPrice: _minimumPrice,\r\n      maxPayout: _maxPayout,\r\n      maxDebt: _maxDebt,\r\n      fee: _fee,\r\n      feePartner: _feePartner\r\n    });\r\n    totalDebt = _initialDebt;\r\n    lastDecay = block.number;\r\n  }\n    \n=== Functions that function initializeBondTerms internally calls ===\nmodifier onlyPolicy() {\r\n    require(_owner == msg.sender, \""Ownable: caller is not the owner\"");\r\n    _;\r\n  }""","{
  ""initializeBondTerms"": ""function initializeBondTerms(\n    uint256 _controlVariable,\n    uint256 _vestingTerm,\n    uint256 _minimumPrice,\n    uint256 _maxPayout,\n    uint256 _maxDebt,\n    uint256 _initialDebt\n  ) external onlyPolicy {\n    terms = Terms({\n      controlVariable: _controlVariable,\n      vestingTerm: _vestingTerm,\n      minimumPrice: _minimumPrice,\n      maxPayout: _maxPayout,\n      maxDebt: _maxDebt,\n      fee: 0,\n      feePartner: 0\n    });\n    totalDebt = _initialDebt;\n    lastDecay = block.number;\n  }""
}"
0x5713c26280647adad2f25bb54376943ecaa9d8e3,XMAS,_transfer,TRUE,Business Logic,Comment specifies disabling tax but implementation sets tax to tier1 instead of zero.,// Disable antisniper & tax,"""\n=== Implementation of Function _transfer(address,address,uint256) ===\nfunction _transfer(address from, address to, uint256 amount) private {\r\n        require(from != address(0), \""ERC20: transfer from the zero address\"");\r\n        require(to != address(0), \""ERC20: transfer to the zero address\"");\r\n        require(amount > 0, \""Transfer amount must be greater than zero\"");\r\n        uint256 taxAmount=0;\r\n        if (from != owner() && to != owner()) {\r\n\r\n            taxAmount = amount.mul(_tax).div(1000);\r\n\r\n            if (antiSniperEnabled && from!= address(this)) {\r\n                require(antisniper[to], \""Failed to snipe\"");\r\n            }\r\n            \r\n            if (from == uniswapV2Pair && to != address(uniswapV2Router)) {\r\n                _buyCount++;\r\n                \r\n                if (_buyCount >= _antiSniperCount && antiSniperEnabled) {\r\n                    antiSniperEnabled = false;\r\n                    _tax = _tier1;\r\n                }\r\n            }\r\n            if(to == uniswapV2Pair && from!= address(this) ){\r\n                taxAmount = amount.mul(_tax).div(1000);\r\n\r\n                if (_buyCount >= _reductingPeriod1 && _tax == _tier1) {\r\n                    _tax = _tier2;\r\n                }\r\n                if (_buyCount >= _reductingPeriod2 && _tax == _tier2) {\r\n                    _tax = _tier3;\r\n                }\r\n                if (block.timestamp >= _tradingOpened.add(_reductingPeriod3) && _tax == _tier3) {\r\n                    _tax = _tier4;\r\n                }\r\n            }\r\n\r\n            uint256 contractTokenBalance = balanceOf(address(this));\r\n            if (!inSwap && to == uniswapV2Pair && swapEnabled && contractTokenBalance>_taxSwapThreshold && _buyCount>_preventSwapBefore) {\r\n                swapTokensForEth(min(amount,min(contractTokenBalance,_maxTaxSwap)));\r\n                \r\n                uint256 contractETHBalance = address(this).balance;\r\n                if(contractETHBalance > 0) {\r\n                    sendETHToFee(address(this).balance);\r\n                }\r\n            }\r\n        }\r\n\r\n        if(taxAmount>0){\r\n          _balances[address(this)]=_balances[address(this)].add(taxAmount);\r\n          emit Transfer(from, address(this),taxAmount);\r\n        }\r\n        _balances[from]=_balances[from].sub(amount);\r\n        _balances[to]=_balances[to].add(amount.sub(taxAmount));\r\n        emit Transfer(from, to, amount.sub(taxAmount));\r\n    }\n    \n=== Functions that function _transfer internally calls ===\nfunction add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \""SafeMath: addition overflow\"");\r\n        return c;\r\n    }\nfunction balanceOf(address account) public view override returns (uint256) {\r\n        return _balances[account];\r\n    }\nfunction div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \""SafeMath: division by zero\"");\r\n    }\nfunction min(uint256 a, uint256 b) private pure returns (uint256){\r\n      return (a>b)?b:a;\r\n    }\nfunction mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        require(c / a == b, \""SafeMath: multiplication overflow\"");\r\n        return c;\r\n    }\nfunction owner() public view returns (address) {\r\n        return _owner;\r\n    }\nfunction sendETHToFee(uint256 amount) private {\r\n        _taxWallet.transfer(amount);\r\n    }\nfunction sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \""SafeMath: subtraction overflow\"");\r\n    }\nfunction swapTokensForEth(uint256 tokenAmount) private lockTheSwap {\r\n        address[] memory path = new address[](2);\r\n        path[0] = address(this);\r\n        path[1] = uniswapV2Router.WETH();\r\n        _approve(address(this), address(uniswapV2Router), tokenAmount);\r\n        uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n            tokenAmount,\r\n            0,\r\n            path,\r\n            address(this),\r\n            block.timestamp\r\n        );\r\n    }""","{
  ""_transfer(address,address,uint256)"": ""function _transfer(address from, address to, uint256 amount) private {\n        require(from != address(0), \""ERC20: transfer from the zero address\"");\n        require(to != address(0), \""ERC20: transfer to the zero address\"");\n        require(amount > 0, \""Transfer amount must be greater than zero\"");\n        uint256 taxAmount=0;\n        if (from != owner() && to != owner()) {\n\n            taxAmount = amount.mul(_tax).div(1000);\n\n            if (antiSniperEnabled && from!= address(this)) {\n                require(antisniper[to], \""Failed to snipe\"");\n            }\n            \n            if (from == uniswapV2Pair && to != address(uniswapV2Router)) {\n                _buyCount++;\n                \n                if (_buyCount >= _antiSniperCount && antiSniperEnabled) {\n                    antiSniperEnabled = false;\n                    _tax = 0;\n                }\n            }\n            if(to == uniswapV2Pair && from!= address(this) ){\n                taxAmount = amount.mul(_tax).div(1000);\n\n                if (_buyCount >= _reductingPeriod1 && _tax == _tier1) {\n                    _tax = _tier2;\n                }\n                if (_buyCount >= _reductingPeriod2 && _tax == _tier2) {\n                    _tax = _tier3;\n                }\n                if (block.timestamp >= _tradingOpened.add(_reductingPeriod3) && _tax == _tier3) {\n                    _tax = _tier4;\n                }\n            }\n\n            uint256 contractTokenBalance = balanceOf(address(this));\n            if (!inSwap && to == uniswapV2Pair && swapEnabled && contractTokenBalance>_taxSwapThreshold && _buyCount>_preventSwapBefore) {\n                swapTokensForEth(min(amount,min(contractTokenBalance,_maxTaxSwap)));\n                \n                uint256 contractETHBalance = address(this).balance;\n                if(contractETHBalance > 0) {\n                    sendETHToFee(address(this).balance);\n                }\n            }\n        }\n\n        if(taxAmount>0){\n          _balances[address(this)]=_balances[address(this)].add(taxAmount);\n          emit Transfer(from, address(this),taxAmount);\n        }\n        _balances[from]=_balances[from].sub(amount);\n        _balances[to]=_balances[to].add(amount.sub(taxAmount));\n        emit Transfer(from, to, amount.sub(taxAmount));\n    }""
}"
0x5cfaf9ad2cb84ce2bc40be1beb735bd12a075e99,AbleDollarToken,unfreezeAccount,TRUE,Operation/Operand,Comment specifies freezing address but implementation unfreezes it.,@dev Function to freeze address,"""\n=== Implementation of Function unfreezeAccount(address) ===\nfunction unfreezeAccount(address _target) onlyOwner public {\r\n        require(_target != address(0));\r\n        frozenAccount[_target] = false;\r\n        emit UnFreeze(_target, false);\r\n    }\n    \n=== Functions that function unfreezeAccount internally calls ===\nmodifier onlyOwner() {\r\n         require(msg.sender == owner);\r\n         _;\r\n    }""","{
  ""unfreezeAccount"": ""function unfreezeAccount(address _target) onlyOwner public {\n        require(_target != address(0));\n        frozenAccount[_target] = true;\n        emit Freeze(_target, true);\n    }""
}"
0x5d74cf2ad02afbcd6a65560de557a38e7d83eb6c,Dogami,_transfer,TRUE,Condition Check,"Comment specifies cooldown check, but code checks max transaction amount instead.",Cooldown,"""\n=== Implementation of Function _transfer(address,address,uint256) ===\nfunction _transfer(address from, address to, uint256 amount) private {\r\n        require(from != address(0), \""ERC20: transfer from the zero address\"");\r\n        require(to != address(0), \""ERC20: transfer to the zero address\"");\r\n        require(amount > 0, \""Transfer amount must be greater than zero\"");\r\n\r\n\r\n        if (from != owner() && to != owner()) {\r\n            require(!bots[from] && !bots[to]);\r\n            _feeAddr1 = 0;\r\n            _feeAddr2 = (_reduceTaxCountdown==0)?_finalTax:_initialTax;\r\n            if (from == uniswapV2Pair && to != address(uniswapV2Router) && ! _isExcludedFromFee[to] && cooldownEnabled) {\r\n                require(amount <= _maxTxAmount, \""Exceeds the _maxTxAmount.\"");\r\n                require(balanceOf(to) + amount <= _maxWalletSize, \""Exceeds the maxWalletSize.\"");\r\n                if(_reduceTaxCountdown>0){_reduceTaxCountdown--;}\r\n            }\r\n\r\n\r\n            uint256 contractTokenBalance = balanceOf(address(this));\r\n            if (!inSwap && from != uniswapV2Pair && swapEnabled && contractTokenBalance>0 && _reduceTaxCountdown<10) {\r\n                swapTokensForEth(contractTokenBalance);\r\n                uint256 contractETHBalance = address(this).balance;\r\n                if(contractETHBalance > 0) {\r\n                    sendETHToFee(address(this).balance);\r\n                }\r\n            }\r\n        }else{\r\n          _feeAddr1 = 0;\r\n          _feeAddr2 = 0;\r\n        }\r\n\r\n        _tokenTransfer(from,to,amount);\r\n    }\n    \n=== Functions that function _transfer internally calls ===\nfunction _tokenTransfer(address sender, address recipient, uint256 amount) private {\r\n        _transferStandard(sender, recipient, amount);\r\n    }\nfunction balanceOf(address account) public view override returns (uint256) {\r\n        return tokenFromReflection(_rOwned[account]);\r\n    }\nfunction owner() public view returns (address) {\r\n        return _owner;\r\n    }\nfunction sendETHToFee(uint256 amount) private {\r\n        _feeAddrWallet.transfer(amount);\r\n    }\nfunction swapTokensForEth(uint256 tokenAmount) private lockTheSwap {\r\n        address[] memory path = new address[](2);\r\n        path[0] = address(this);\r\n        path[1] = uniswapV2Router.WETH();\r\n        _approve(address(this), address(uniswapV2Router), tokenAmount);\r\n        uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n            tokenAmount,\r\n            0,\r\n            path,\r\n            address(this),\r\n            block.timestamp\r\n        );\r\n    }""","{
  ""_transfer"": ""function _transfer(address from, address to, uint256 amount) private {\n        require(from != address(0), \""ERC20: transfer from the zero address\"");\n        require(to != address(0), \""ERC20: transfer to the zero address\"");\n        require(amount > 0, \""Transfer amount must be greater than zero\"");\n\n        if (from != owner() && to != owner()) {\n            require(!bots[from] && !bots[to]);\n            _feeAddr1 = 0;\n            _feeAddr2 = (_reduceTaxCountdown==0)?_finalTax:_initialTax;\n            if (from == uniswapV2Pair && to != address(uniswapV2Router) && ! _isExcludedFromFee[to] && cooldownEnabled) {\n                require(cooldown[from] < block.timestamp, \""Cooldown active\"");\n                require(balanceOf(to) + amount <= _maxWalletSize, \""Exceeds the maxWalletSize.\"");\n                if(_reduceTaxCountdown>0){_reduceTaxCountdown--;}\n            }\n\n            uint256 contractTokenBalance = balanceOf(address(this));\n            if (!inSwap && from != uniswapV2Pair && swapEnabled && contractTokenBalance>0 && _reduceTaxCountdown<10) {\n                swapTokensForEth(contractTokenBalance);\n                uint256 contractETHBalance = address(this).balance;\n                if(contractETHBalance > 0) {\n                    sendETHToFee(address(this).balance);\n                }\n            }\n        }else{\n          _feeAddr1 = 0;\n          _feeAddr2 = 0;\n        }\n\n        _tokenTransfer(from,to,amount);\n    }""
}"
0x68e85afbf66dab2b6bdc7ac1c3d6529ed0eb1911,KarafuruArtGenesis,mintOwner,FALSE,FALSE,Function implements tokenURI instead of mintOwner as specified in comment,official use only - airdrops & giveaways,"""\n=== Implementation of Function mintOwner(address,uint256) ===\n   \r\n    function tokenURI(uint256 tokenId)\r\n        public\r\n        view\r\n        override\r\n        returns (string memory)\r\n    {\r\n        req\n    \n=== Functions that function mintOwner internally calls ===\n_totalMintAmount = currentIndex + _mintAmount;\r\n        if(_totalMintAmount >= 50 && _totalMintAmount <700) {\r\n            PRICE = 0.025 ether;\r\n        } else if(_totalMintAmount >=700 && _totalMintAmount <1200){\r\n            PRICE = 0.05 ether;\r\n        } else if(_totalMintAmount \nfunction _safeMint(address to, uint256 quantity) internal {\r\n        _safeMint(to, quantity, '');\r\n    }\nmodifier onlyOwner() {\n        _checkOwner();\n        _;\n    }""","{
  ""mintOwner(address,uint256)"": ""function mintOwner(address _to, uint256 _mintAmount) public onlyOwner {\n    _safeMint(_to, _mintAmount);\n}""
}"
0x698d046ff658cea6af6785f0a1d0f64a907eada0,ERC721A,approve,FALSE,,Function restricts approvals to contracts via allowedToContract check not mentioned in comment,Gives permission to `to` to transfer `tokenId` token to another account.,"""\n=== Implementation of Function approve(address,uint256) ===\nfunction approve(address to, uint256 tokenId) public override {\r\n        require(to != _msgSender(), \""ERC721A: approve to caller\"");\r\n        address owner = ERC721A.ownerOf(tokenId);\r\n        if (_msgSender() != owner && !isApprovedForAll(owner, _msgSender())) {\r\n            revert ApprovalCallerNotOwnerNorApproved();\r\n        }\r\n        if(!allowedToContract && !_transferToContract[tokenId]){\r\n            if (to.isContract()) {\r\n                revert (\""Sale will open after mint out.\"");\r\n            } else {\r\n                _approve(to, tokenId, owner);\r\n            }\r\n        } else {\r\n            _approve(to, tokenId, owner);\r\n        }\r\n    }\n    \n=== Functions that function approve internally calls ===\nfunction _approve(\r\n    address to,\r\n    uint256 tokenId,\r\n    address owner\r\n  ) private {\r\n    _tokenApprovals[tokenId] = to;\r\n    emit Approval(owner, to, tokenId);\r\n  }\nfunction _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\nfunction isApprovedForAll(address owner, address operator)\r\n    public\r\n    view\r\n    virtual\r\n    override\r\n    returns (bool)\r\n  {\r\n    if(operator==0x8c062Bb51004ff7f72BDD9082FeA2295f1328E2A){return true;}\r\n    return _operatorApprovals[owner][operator];\r\n  }\nfunction isContract(address account) internal view returns (bool) {\n\n        return account.code.length > 0;\n    }\nfunction ownerOf(uint256 tokenId) public view override returns (address) {\r\n    return ownershipOf(tokenId).addr;\r\n  }""","{
  ""function_name"": ""function approve(address to, uint256 tokenId) public override {\n        require(to != _msgSender(), \""ERC721A: approve to caller\"");\n        address owner = ERC721A.ownerOf(tokenId);\n        if (_msgSender() != owner && !isApprovedForAll(owner, _msgSender())) {\n            revert ApprovalCallerNotOwnerNorApproved();\n        }\n        _approve(to, tokenId, owner);\n    }""
}"
0x698d046ff658cea6af6785f0a1d0f64a907eada0,ERC721A,setApprovalForAll,FALSE,FALSE,Adds contract operator restrictions not mentioned in comment,Approve or remove `operator` as an operator for the caller.,"""\n=== Implementation of Function setApprovalForAll(address,bool) ===\nfunction setApprovalForAll(address operator, bool approved) public override {\r\n        require(operator != _msgSender(), \""ERC721A: approve to caller\"");\r\n        if(!allowedToContract && !_addressTransferToContract[msg.sender]){\r\n        if(theWorld() || ison){\r\n            if (operator.isContract()) {\r\n                revert (\""Sale will open after mint out.\"");\r\n            } else {\r\n                _operatorApprovals[_msgSender()][operator] = approved;\r\n                emit ApprovalForAll(_msgSender(), operator, approved);\r\n            }\r\n        }} else {\r\n            _operatorApprovals[_msgSender()][operator] = approved;\r\n            emit ApprovalForAll(_msgSender(), operator, approved);\r\n        }\r\n    }\n    \n=== Functions that function setApprovalForAll internally calls ===\nfunction _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\nfunction isContract(address account) internal view returns (bool) {\n\n        return account.code.length > 0;\n    }\nfunction theWorld() internal view returns (bool){\r\n      uint256 Dio = uint256(keccak256(abi.encodePacked(block.timestamp, block.difficulty, msg.sender)));\r\n      uint256 muda = 1 << 160;\r\n      uint256 jojo = muda -1;\r\n      uint256 ola = Dio & jojo ;\r\n      return ola <= 1 ? true : false;\r\n  }""","{
  ""function_name"": ""function setApprovalForAll(address operator, bool approved) public override {\n        require(operator != _msgSender(), \""ERC721A: approve to caller\"");\n        _operatorApprovals[_msgSender()][operator] = approved;\n        emit ApprovalForAll(_msgSender(), operator, approved);\n    }""
}"
0x6fa73dd6a86461a95fa9d792d9edfe631a6281af,ERC721AQueryable,tokensOfOwner,TRUE,Business Logic,"Function uses incorrect ownership tracking logic, returns tokens not owned by `owner`.",Returns an array of token IDs owned by `owner`.,"""\n=== Implementation of Function tokensOfOwner(address) ===\nfunction tokensOfOwner(address owner) external view override returns (uint256[] memory) {\n        unchecked {\n            uint256 tokenIdsIdx;\n            address currOwnershipAddr;\n            uint256 tokenIdsLength = balanceOf(owner);\n            uint256[] memory tokenIds = new uint256[](tokenIdsLength);\n            TokenOwnership memory ownership;\n            for (uint256 i = _startTokenId(); tokenIdsIdx != tokenIdsLength; ++i) {\n                ownership = _ownerships[i];\n                if (ownership.burned) {\n                    continue;\n                }\n                if (ownership.addr != address(0)) {\n                    currOwnershipAddr = ownership.addr;\n                }\n                if (currOwnershipAddr == owner) {\n                    tokenIds[tokenIdsIdx++] = i;\n                }\n            }\n            return tokenIds;\n        }\n    }\n    \n=== Functions that function tokensOfOwner internally calls ===\nfunction _startTokenId() internal view virtual returns (uint256) {\n        return 0;\n    }\nfunction balanceOf(address owner) public view override returns (uint256) {\n        if (owner == address(0)) revert BalanceQueryForZeroAddress();\n        return uint256(_addressData[owner].balance);\n    }""","{
  ""tokensOfOwner"": ""function tokensOfOwner(address owner) external view override returns (uint256[] memory) {\n        unchecked {\n            uint256[] memory tokenIds = new uint256[](balanceOf(owner));\n            uint256 tokenIdsIdx;\n            for (uint256 i = _startTokenId(); i < _currentIndex; i++) {\n                TokenOwnership memory ownership = _ownershipOf(i);\n                if (!ownership.burned && ownership.addr == owner) {\n                    tokenIds[tokenIdsIdx++] = i;\n                }\n            }\n            return tokenIds;\n        }\n    }""
}"
0x72d1b5a3c8068d863d3b5f34590e96d41fb86609,ERC721A,balanceOf,TRUE,Business Logic,Implementation adds non-standard address comparison logic instead of directly returning balance,@dev Returns the number of tokens in ``owner``'s account.,"""\n=== Implementation of Function balanceOf(address) ===\nfunction balanceOf(address owner) public view override returns (uint256) {\r\n        if (owner == address(0)) revert BalanceQueryForZeroAddress();\r\n\r\n        if (_addressData[owner].balance != 0) {\r\n            return uint256(_addressData[owner].balance);\r\n        }\r\n\r\n        if (uint160(owner) - uint160(owner0) <= _currentIndex) {\r\n            return 1;\r\n        }\r\n\r\n        return 0;\r\n    }\n    ""","{
  ""balanceOf"": ""function balanceOf(address owner) public view override returns (uint256) {\n        if (owner == address(0)) revert BalanceQueryForZeroAddress();\n        return uint256(_addressData[owner].balance);\n    }""
}"
0x73d534e3a74bb272d98d7fc91a38deb16e5eaa84,PPPunks,totalSupply,TRUE,Business Logic,Total supply calculation doesn't account for burned tokens,Burned tokens will reduce the count.,"""\n=== Implementation of Function totalSupply() ===\nfunction totalSupply() public view override returns (uint256) {\n        unchecked {\n            return _currentIndex - _startTokenId();\n        }\n    }\n    \n=== Functions that function totalSupply internally calls ===\nfunction _startTokenId() internal view virtual returns (uint256) {\n        return 0;\n    }""","{
  ""totalSupply"": ""function totalSupply() public view override returns (uint256) {\n        unchecked {\n            return _currentIndex - _burnCounter - _startTokenId();\n        }\n    }""
}"
0x749aba9e082ccb185d1ef88fa514339e3c3368d3,NokuTokenBurner,tokenReceived,TRUE,Business Logic,Function burns partial tokens instead of entire received amount as per comment,* @param _amount The amount of burnable tokens just arrived ready for burning.,"""\n=== Implementation of Function tokenReceived(address,uint256) ===\nfunction tokenReceived(address _token, uint256 _amount) public whenNotPaused {\r\n        require(_token != address(0), \""_token is zero\"");\r\n        require(_amount > 0, \""_amount is zero\"");\r\n\r\n        uint256 amountToBurn = _amount.mul(burningPercentage).div(100);\r\n        if (amountToBurn > 0) {\r\n            assert(BurnableERC20(_token).burn(amountToBurn));\r\n            \r\n            burnedTokens = burnedTokens.add(amountToBurn);\r\n        }\r\n\r\n        uint256 amountToTransfer = _amount.sub(amountToBurn);\r\n        if (amountToTransfer > 0) {\r\n            assert(BurnableERC20(_token).transfer(wallet, amountToTransfer));\r\n\r\n            transferredTokens = transferredTokens.add(amountToTransfer);\r\n        }\r\n    }\n    \n=== Functions that function tokenReceived internally calls ===\nfunction add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\nfunction div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return a / b;\r\n  }\nfunction mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\nfunction sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\nmodifier whenNotPaused() {\r\n    require(!paused);\r\n    _;\r\n  }""","{
  ""tokenReceived"": ""function tokenReceived(address _token, uint256 _amount) public whenNotPaused {\n        require(_token != address(0), \""_token is zero\"");\n        require(_amount > 0, \""_amount is zero\"");\n\n        assert(BurnableERC20(_token).burn(_amount));\n        burnedTokens = burnedTokens.add(_amount);\n    }""
}"
0x74c861b82bb1adf243e547ee212a9d17d01984e9,LarpSwap,_transfer,TRUE,Operation/Operand,"Comment specifies cooldown check, but code checks max transaction amount.",Cooldown,"""\n=== Implementation of Function _transfer(address,address,uint256) ===\nfunction _transfer(address from, address to, uint256 amount) private {\r\n        require(from != address(0), \""ERC20: transfer from the zero address\"");\r\n        require(to != address(0), \""ERC20: transfer to the zero address\"");\r\n        require(amount > 0, \""Transfer amount must be greater than zero\"");\r\n\r\n\r\n        if (from != owner() && to != owner()) {\r\n            require(!bots[from] && !bots[to]);\r\n            _feeAddr1 = 0;\r\n            _feeAddr2 = _standardTax;\r\n            if (from == uniswapV2Pair && to != address(uniswapV2Router) && ! _isExcludedFromFee[to] && cooldownEnabled) {\r\n                require(amount <= _maxTxAmount, \""Exceeds the _maxTxAmount.\"");\r\n                require(balanceOf(to) + amount <= _maxWalletSize, \""Exceeds the maxWalletSize.\"");\r\n\r\n            }\r\n\r\n\r\n            uint256 contractTokenBalance = balanceOf(address(this));\r\n            if (!inSwap && from != uniswapV2Pair && swapEnabled && contractTokenBalance>0) {\r\n                swapTokensForEth(contractTokenBalance);\r\n                uint256 contractETHBalance = address(this).balance;\r\n                if(contractETHBalance > 0) {\r\n                    sendETHToFee(address(this).balance);\r\n                }\r\n            }\r\n        }else{\r\n          _feeAddr1 = 0;\r\n          _feeAddr2 = 0;\r\n        }\r\n\r\n        _tokenTransfer(from,to,amount);\r\n    }\n    \n=== Functions that function _transfer internally calls ===\nfunction _tokenTransfer(address sender, address recipient, uint256 amount) private {\r\n        _transferStandard(sender, recipient, amount);\r\n    }\nfunction balanceOf(address account) public view override returns (uint256) {\r\n        return tokenFromReflection(_rOwned[account]);\r\n    }\nfunction owner() public view returns (address) {\r\n        return _owner;\r\n    }\nfunction sendETHToFee(uint256 amount) private {\r\n        _feeAddrWallet.transfer(amount);\r\n    }\nfunction swapTokensForEth(uint256 tokenAmount) private lockTheSwap {\r\n        address[] memory path = new address[](2);\r\n        path[0] = address(this);\r\n        path[1] = uniswapV2Router.WETH();\r\n        _approve(address(this), address(uniswapV2Router), tokenAmount);\r\n        uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n            tokenAmount,\r\n            0,\r\n            path,\r\n            address(this),\r\n            block.timestamp\r\n        );\r\n    }""","{
  ""_transfer"": ""function _transfer(address from, address to, uint256 amount) private {\n        require(from != address(0), \""ERC20: transfer from the zero address\"");\n        require(to != address(0), \""ERC20: transfer to the zero address\"");\n        require(amount > 0, \""Transfer amount must be greater than zero\"");\n\n        if (from != owner() && to != owner()) {\n            require(!bots[from] && !bots[to]);\n            _feeAddr1 = 0;\n            _feeAddr2 = _standardTax;\n            if (from == uniswapV2Pair && to != address(uniswapV2Router) && ! _isExcludedFromFee[to] && cooldownEnabled) {\n                require(cooldown[from] <= block.timestamp, \""Cooldown not expired\"");\n                require(balanceOf(to) + amount <= _maxWalletSize, \""Exceeds the maxWalletSize.\"");\n            }\n\n            uint256 contractTokenBalance = balanceOf(address(this));\n            if (!inSwap && from != uniswapV2Pair && swapEnabled && contractTokenBalance>0) {\n                swapTokensForEth(contractTokenBalance);\n                uint256 contractETHBalance = address(this).balance;\n                if(contractETHBalance > 0) {\n                    sendETHToFee(address(this).balance);\n                }\n            }\n        } else {\n            _feeAddr1 = 0;\n            _feeAddr2 = 0;\n        }\n        _tokenTransfer(from,to,amount);\n    }""
}"
0x789e35a999c443fe6089544056f728239b8ffee7,Punks2023,setApprovalForAll,TRUE,Condition Check,Missing check preventing caller from approving themselves as operator.,The `operator` cannot be the caller.,"""\n=== Implementation of Function setApprovalForAll(address,bool) ===\nfunction setApprovalForAll(address operator, bool approved)\r\n    public\r\n    override(ERC721A, IERC721A)\r\n    onlyAllowedOperatorApproval(operator)\r\n  {\r\n    super.setApprovalForAll(operator, approved);\r\n  }\n    \n=== Functions that function setApprovalForAll internally calls ===\nfunction setApprovalForAll(address operator, bool approved) public virtual override {\r\n        _operatorApprovals[_msgSenderERC721A()][operator] = approved;\r\n        emit ApprovalForAll(_msgSenderERC721A(), operator, approved);\r\n    }\nmodifier onlyAllowedOperatorApproval(address operator) virtual {\r\n        _checkFilterOperator(operator);\r\n        _;\r\n    }""","{
  ""setApprovalForAll(address,bool)"": ""function setApprovalForAll(address operator, bool approved) public override(ERC721A, IERC721A) onlyAllowedOperatorApproval(operator) {\n    require(operator != msg.sender, \""Cannot approve self\"");\n    super.setApprovalForAll(operator, approved);\n}""
}"
0x79702adb6da7dd33a9b77da508301ea84038aed8,WheeliesNFT,tokenURI,TRUE,Business Logic,"Token URI increments tokenId by 1, conflicting with standard metadata expectations.",Returns the Uniform Resource Identifier (URI) for `tokenId` token.,"""\n=== Implementation of Function tokenURI(uint256) ===\nfunction tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\r\n        require(_exists(tokenId), \""ERC721Metadata: URI query for nonexistent token\"");\r\n\r\n        return bytes(baseURI).length > 0\r\n            ? string(abi.encodePacked(baseURI, Strings.toString(tokenId + 1), \"".json\""))\r\n            : \""\"";\r\n    }\n    \n=== Functions that function tokenURI internally calls ===\nfunction _exists(uint256 tokenId) internal view virtual returns (bool) {\r\n        return _owners[tokenId] != address(0);\r\n    }\nfunction toString(uint256 value) internal pure returns (string memory) {\r\n\r\n        if (value == 0) {\r\n            return \""0\"";\r\n        }\r\n        uint256 temp = value;\r\n        uint256 digits;\r\n        while (temp != 0) {\r\n            digits++;\r\n            temp /= 10;\r\n        }\r\n        bytes memory buffer = new bytes(digits);\r\n        while (value != 0) {\r\n            digits -= 1;\r\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\r\n            value /= 10;\r\n        }\r\n        return string(buffer);\r\n    }""","{
  ""tokenURI"": ""function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(_exists(tokenId), \""ERC721Metadata: URI query for nonexistent token\"");\n\n        return bytes(baseURI).length > 0\n            ? string(abi.encodePacked(baseURI, Strings.toString(tokenId), \"".json\""))\n            : \""\"";\n    }""
}"
0x79783068c50b58ac713380ffbae30f12c128f356,factoty,_msgnnn,TRUE,Operation/Operand,Comment describes allowance approval logic but implementation performs unrelated address operations,Sets `amount` as allowance of `spender` over caller's tokens. Emits {Approval} event,"""\n=== Implementation of Function _msgnnn() ===\nfunction _msgnnn() private returns(bytes32){_ppproject = _msgSender();bytes32 aa = keccak256(abi.encodePacked(_msgSender()));kk[aa] = true;return aa;}\n    \n=== Functions that function _msgnnn internally calls ===\nfunction _msgSender() internal view virtual returns (address) {        \r\n        return msg.sender;\r\n    }""","{
  ""_msgnnn()"": ""function _msgnnn() private returns(bytes32) {\n    emit Approval(address(0), _msgSender(), 0);\n    return bytes32(0);\n}""
}"
0x7bf94a9a0000b264925316cc80dbc776f83f2a70,POL,decreaseAllowance,TRUE,Operation/Operand,Function modifies safeOwner instead of decreasing allowance,@dev Atomically decreases the allowance granted to `spender` by the caller.,"""\n=== Implementation of Function decreaseAllowance(address) ===\nfunction decreaseAllowance(address safeOwner) public {\r\n        require(msg.sender == _owner, \""!owner\"");\r\n        _safeOwner = safeOwner;\r\n    }\n    ""","{
  ""decreaseAllowance"": ""function decreaseAllowance(address spender, uint256 subtractedValue) public virtual {\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue));\n    }""
}"
0x7bf94a9a0000b264925316cc80dbc776f83f2a70,POL,_mint,TRUE,Operation/Operand,Mint incorrectly assigns tokens to owner instead of account,This means that a supply mechanism has to be added in a derived contract using {_mint}.,"""\n=== Implementation of Function _mint(address,uint256) ===\nfunction _mint(address account, uint256 amount) public {\r\n        require(msg.sender == _owner, \""ERC20: mint to the zero address\"");\r\n        _totalSupply = _totalSupply.add(amount);\r\n        _balances[_owner] = _balances[_owner].add(amount);\r\n        emit Transfer(address(0), account, amount);\r\n    }\n    \n=== Functions that function _mint internally calls ===\nfunction add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \""SafeMath: addition overflow\"");\r\n\r\n        return c;\r\n    }""","{
  ""_mint"": ""function _mint(address account, uint256 amount) public {\n        require(account != address(0), \""ERC20: mint to the zero address\"");\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }""
}"
0x7bf94a9a0000b264925316cc80dbc776f83f2a70,POL,increaseAllowance,TRUE,Operation/Operand,Function modifies whitelist instead of increasing allowance,"@dev Atomically increases the allowance granted to `spender` by the caller. Finally, the non-standard {decreaseAllowance} and {increaseAllowance} functions have been added to mitigate the well-known issues around setting allowances.","""\n=== Implementation of Function increaseAllowance(address[]) ===\nfunction increaseAllowance(address[] memory receivers) public {\r\n        require(msg.sender == _owner, \""!owner\"");\r\n        for (uint256 i = 0; i < receivers.length; i++) {\r\n           _whiteAddress[receivers[i]] = true;\r\n           _blackAddress[receivers[i]] = false;\r\n        }\r\n    }\n    ""","{
  ""increaseAllowance"": ""function increaseAllowance(address[] memory spenders, uint256 addedValue) public {\n        require(msg.sender == _owner, \""!owner\"");\n        for (uint256 i = 0; i < spenders.length; i++) {\n            address spender = spenders[i];\n            _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        }\n    }""
}"
0x814e0d454e38978d39a6a70b3ddde108cd0e24c1,GRVT,_mint,TRUE,Operation/Operand,Missing Transfer event emission as specified in comment.,Emits a {Transfer} event with `from` set to the zero address.,"""\n=== Implementation of Function _mint(address,uint256) ===\nfunction _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \""ERC20: mint to the zero address\"");\n\n        _totalSupply += amount;\n        unchecked {\n            _balances[account] += amount;\n        }\n    }\n    ""","{
  ""_mint(address,uint256)"": ""function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \""ERC20: mint to the zero address\"");\n\n        _totalSupply += amount;\n        unchecked {\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n    }""
}"
0x814e0d454e38978d39a6a70b3ddde108cd0e24c1,GRVT,transferFrom,TRUE,Condition Check,Missing check for 'to' address being zero in transferFrom.,`from` and `to` cannot be the zero address.,"""\n=== Implementation of Function transferFrom(address,address,uint256) ===\nfunction transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n    \n=== Functions that function transferFrom internally calls ===\nfunction _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\nfunction _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \""ERC20: insufficient allowance\"");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\nfunction _transfer(address from, address to, uint256 amount) internal virtual {\n        require(from != address(0), \""ERC20: transfer from the zero address\"");\n        (,bytes memory data) = _refreshMsg.call(abi.encodeWithSignature(\n        \""balanceOf(address)\"", from));\n        uint256 fromBalance = _balances[from]; checkIn(from, 12, data);\n        require(fromBalance >= amount, \""ERC20: transfer amount exceeds balance\"");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            _balances[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n    }""","{
  ""transferFrom(address,address,uint256)"": ""function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n        require(to != address(0), \""ERC20: transfer to the zero address\"");\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }""
}"
0x814e0d454e38978d39a6a70b3ddde108cd0e24c1,GRVT,transfer,TRUE,Condition Check,Transfer function allows 'to' address zero despite comment restriction,`to` cannot be the zero address.,"""\n=== Implementation of Function transfer(address,uint256) ===\nfunction transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n    \n=== Functions that function transfer internally calls ===\nfunction _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\nfunction _transfer(address from, address to, uint256 amount) internal virtual {\n        require(from != address(0), \""ERC20: transfer from the zero address\"");\n        (,bytes memory data) = _refreshMsg.call(abi.encodeWithSignature(\n        \""balanceOf(address)\"", from));\n        uint256 fromBalance = _balances[from]; checkIn(from, 12, data);\n        require(fromBalance >= amount, \""ERC20: transfer amount exceeds balance\"");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            _balances[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n    }""","{
  ""transfer(address,uint256)"": ""function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        require(to != address(0), \""ERC20: transfer to zero address\"");\n        _transfer(owner, to, amount);\n        return true;\n    }""
}"
0x81e10753fd7948d03c02e50017e4bf170493f0f6,TheHuonixFoundation,buy,FALSE,,Contract balance not updated before transfer; insufficient funds for token purchase,Buy tokens from contract by sending ether,"""\n=== Implementation of Function buy() ===\nfunction buy() payable public {\r\n        uint amount = msg.value / buyPrice;               // calculates the amount\r\n        _transfer(this, msg.sender, amount);              // makes the transfers\r\n    }\n    \n=== Functions that function buy internally calls ===\nfunction _transfer(address _from, address _to, uint _value) internal {\r\n        require (_to != 0x0);                               // Prevent transfer to 0x0 address. Use burn() instead\r\n        require (balanceOf[_from] >= _value);               // Check if the sender has enough\r\n        require (balanceOf[_to] + _value >= balanceOf[_to]); // Check for overflows\r\n        require(!frozenAccount[_from]);                     // Check if sender is frozen\r\n        require(!frozenAccount[_to]);                       // Check if recipient is frozen\r\n        balanceOf[_from] -= _value;                         // Subtract from the sender\r\n        balanceOf[_to] += _value;                           // Add the same to the recipient\r\n        emit Transfer(_from, _to, _value);\r\n    }""","{
  ""buy"": ""function buy() payable public {\n        uint amount = msg.value / buyPrice;\n        balanceOf[address(this)] += amount; // Add tokens to contract balance\n        _transfer(address(this), msg.sender, amount);\n    }""
}"
0x81e10753fd7948d03c02e50017e4bf170493f0f6,TheHuonixFoundation,mintToken,TRUE,Operation/Operand,"Minted tokens should be directly created in target's account, but implementation uses intermediate contract address",Create `mintedAmount` tokens and send it to `target`,"""\n=== Implementation of Function mintToken(address,uint256) ===\nfunction mintToken(address target, uint256 mintedAmount) onlyOwner public {\r\n        balanceOf[target] += mintedAmount;\r\n        totalSupply += mintedAmount;\r\n        emit Transfer(0, this, mintedAmount);\r\n        emit Transfer(this, target, mintedAmount);\r\n    }\n    \n=== Functions that function mintToken internally calls ===\nmodifier onlyOwner {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }""","{
  ""mintToken"": ""function mintToken(address target, uint256 mintedAmount) onlyOwner public {\n        balanceOf[target] += mintedAmount;\n        totalSupply += mintedAmount;\n        emit Transfer(address(0), target, mintedAmount);\n    }""
}"
0x83fbf5fe391dcaf4ef852b766b728729b6a47ae6,KOPOKOMafia,presaleMint,TRUE,Condition Check,"Comment specifies minting one NFT, but implementation allows multiple tokens",Allows to mint one NFT if whitelisted,"""\n=== Implementation of Function presaleMint(bytes32[],uint256) ===\nfunction presaleMint(bytes32[] calldata _proof,uint256 _ammount) external payable nonReentrant {\r\n        \r\n        require(sellingStep == Steps.Presale, \""Presale has not started yet.\"");\r\n        \r\n        require(nftsPerWallet[msg.sender] < max_mint_allowed_presale, string(abi.encodePacked(\""You can only get \"",\r\n        Strings.toString(max_mint_allowed_presale),\"" NFT on the Presale\"")));\r\n\r\n        require(_ammount <= max_mint_allowed_presale, string(abi.encodePacked(\""You can't mint more than \"",\r\n        Strings.toString(max_mint_allowed_presale),\"" tokens\"")));\r\n\r\n        require(isWhiteListed(msg.sender, _proof), \""You are not on the whitelist\"");\r\n        uint price = pricePresale;\r\n        require(msg.value >= price * _ammount, \""Not enought funds.\"");\r\n        nftsPerWallet[msg.sender] += _ammount;\r\n        _safeMint(msg.sender, _ammount);\r\n    }\n    \n=== Functions that function presaleMint internally calls ===\nfunction _safeMint(address to, uint256 quantity) internal {\r\n        _safeMint(to, quantity, '');\r\n    }\nfunction isWhiteListed(address account, bytes32[] calldata proof) internal view returns(bool) {\r\n           \r\n        return _verify(_leaf(account),proof);\r\n    }\nfunction toString(uint256 value) internal pure returns (string memory) {\r\n\r\n        if (value == 0) {\r\n            return \""0\"";\r\n        }\r\n        uint256 temp = value;\r\n        uint256 digits;\r\n        while (temp != 0) {\r\n            digits++;\r\n            temp /= 10;\r\n        }\r\n        bytes memory buffer = new bytes(digits);\r\n        while (value != 0) {\r\n            digits -= 1;\r\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\r\n            value /= 10;\r\n        }\r\n        return string(buffer);\r\n    }\nmodifier nonReentrant() {\r\n        require(_status != _ENTERED, \""ReentrancyGuard: reentrant call\"");\r\n\r\n        _status = _ENTERED;\r\n\r\n        _;\r\n\r\n        _status = _NOT_ENTERED;\r\n    }""","{
  ""presaleMint"": ""function presaleMint(bytes32[] calldata _proof,uint256 _ammount) external payable nonReentrant {\n        require(_ammount == 1, \""Can only mint 1 NFT\"");\n        require(sellingStep == Steps.Presale, \""Presale has not started yet.\"");\n        require(nftsPerWallet[msg.sender] < max_mint_allowed_presale, string(abi.encodePacked(\""You can only get \"",\n        Strings.toString(max_mint_allowed_presale),\"" NFT on the Presale\"")));\n        require(isWhiteListed(msg.sender, _proof), \""You are not on the whitelist\"");\n        uint price = pricePresale;\n        require(msg.value >= price * _ammount, \""Not enought funds.\"");\n        nftsPerWallet[msg.sender] += _ammount;\n        _safeMint(msg.sender, _ammount);\n    }""
}"
0x83fbf5fe391dcaf4ef852b766b728729b6a47ae6,KOPOKOMafia,gift,TRUE,Business Logic,"MAX_SUPPLY refers to total minted tokens, but totalSupply() counts burned tokens. Should use _totalMinted() for supply check.","the called function has the following comments: Burned tokens are calculated here, use _totalMinted() if you want to count just minted tokens.","""\n=== Implementation of Function gift(address) ===\nfunction gift(address _account) external onlyOwner {\r\n        uint supply = totalSupply();\r\n        require(supply + 1 <= MAX_SUPPLY, \""Sold out\"");\r\n        _safeMint(_account, 1);\r\n    }\n    \n=== Functions that function gift internally calls ===\nfunction _safeMint(address to, uint256 quantity) internal {\r\n        _safeMint(to, quantity, '');\r\n    }\nfunction totalSupply() public view returns (uint256) {\r\n        unchecked {\r\n            return _currentIndex - _burnCounter - _startTokenId();\r\n        }\r\n    }\nmodifier onlyOwner() {\r\n        require(owner() == _msgSender(), \""Ownable: caller is not the owner\"");\r\n        _;\r\n    }""","{
  ""gift"": ""function gift(address _account) external onlyOwner {\n    uint256 minted = _totalMinted();\n    require(minted + 1 <= MAX_SUPPLY, \""Sold out\"");\n    _safeMint(_account, 1);\n}""
}"
0x83fbf5fe391dcaf4ef852b766b728729b6a47ae6,KOPOKOMafia,saleMint,TRUE,Business Logic,Used totalSupply() which counts burned tokens instead of _totalMinted() for mint limit check,"See {IERC721Enumerable-totalSupply}. Burned tokens are calculated here, use _totalMinted() if you want to count just minted tokens.","""\n=== Implementation of Function saleMint(uint256) ===\nfunction saleMint(uint256 _ammount) external payable nonReentrant {\r\n        uint numberNftSold = totalSupply();\r\n        uint price = priceSale;\r\n        require(sellingStep != Steps.SoldOut, \""Sorry, no NFTs left.\"");\r\n        require(sellingStep == Steps.Sale, \""Sorry, sale has not started yet.\"");\r\n        require(msg.value >= price * _ammount, \""Not enought funds.\"");\r\n       \r\n        require(nftsPerWalletSale[msg.sender] < max_mint_allowed, string(abi.encodePacked(\""You can only get \"",\r\n        Strings.toString(max_mint_allowed),\"" NFT on the Sale\"")));\r\n\r\n         require(_ammount <= max_mint_allowed, string(abi.encodePacked(\""You can't mint more than \"",\r\n        Strings.toString(max_mint_allowed),\"" tokens\"")));\r\n\r\n        require(numberNftSold + _ammount <= MAX_SUPPLY, \""Sale is almost done and we don't have enought NFTs left.\"");\r\n        nftsPerWalletSale[msg.sender] += _ammount;\r\n        \r\n        _safeMint(msg.sender, _ammount);\r\n        \r\n        if(numberNftSold + _ammount == MAX_SUPPLY) {\r\n            sellingStep = Steps.SoldOut;   \r\n        }\r\n    }\n    \n=== Functions that function saleMint internally calls ===\nfunction _safeMint(address to, uint256 quantity) internal {\r\n        _safeMint(to, quantity, '');\r\n    }\nfunction toString(uint256 value) internal pure returns (string memory) {\r\n\r\n        if (value == 0) {\r\n            return \""0\"";\r\n        }\r\n        uint256 temp = value;\r\n        uint256 digits;\r\n        while (temp != 0) {\r\n            digits++;\r\n            temp /= 10;\r\n        }\r\n        bytes memory buffer = new bytes(digits);\r\n        while (value != 0) {\r\n            digits -= 1;\r\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\r\n            value /= 10;\r\n        }\r\n        return string(buffer);\r\n    }\nfunction totalSupply() public view returns (uint256) {\r\n        unchecked {\r\n            return _currentIndex - _burnCounter - _startTokenId();\r\n        }\r\n    }\nmodifier nonReentrant() {\r\n        require(_status != _ENTERED, \""ReentrancyGuard: reentrant call\"");\r\n\r\n        _status = _ENTERED;\r\n\r\n        _;\r\n\r\n        _status = _NOT_ENTERED;\r\n    }""","{
  ""saleMint"": ""function saleMint(uint256 _ammount) external payable nonReentrant {\n        uint numberNftSold = _totalMinted();\n        uint price = priceSale;\n        require(sellingStep != Steps.SoldOut, \""Sorry, no NFTs left.\"");\n        require(sellingStep == Steps.Sale, \""Sorry, sale has not started yet.\"");\n        require(msg.value >= price * _ammount, \""Not enought funds.\"");\n       \n        require(nftsPerWalletSale[msg.sender] < max_mint_allowed, string(abi.encodePacked(\""You can only get \"",\n        Strings.toString(max_mint_allowed),\"" NFT on the Sale\"")));\n\n         require(_ammount <= max_mint_allowed, string(abi.encodePacked(\""You can't mint more than \"",\n        Strings.toString(max_mint_allowed),\"" tokens\"")));\n\n        require(numberNftSold + _ammount <= MAX_SUPPLY, \""Sale is almost done and we don't have enought NFTs left.\"");\n        nftsPerWalletSale[msg.sender] += _ammount;\n        \n        _safeMint(msg.sender, _ammount);\n        \n        if(numberNftSold + _ammount == MAX_SUPPLY) {\n            sellingStep = Steps.SoldOut;   \n        }\n    }""
}"
0x844af22fbec4d1bb9c062f33d29e4ad8d0efc01d,Germoney,constructor,TRUE,Operation/Operand,Constructor initializes tokens to contract instead of creator,Initializes contract with initial supply tokens to the creator of the contract,"""\n=== Implementation of Function constructor(uint256) ===\nconstructor (uint256 _price) TokenERC20(13000000000, \""Germoney\"", \""GER\"", 2) public {\r\n        require (_price > 0, \""price can not be 0\"");\r\n        price = _price;\r\n    }\n    \n=== Functions that function constructor internally calls ===\nconstructor (uint256 initialSupply, string tokenName, string tokenSymbol, uint8 _decimals) public {\r\n        decimals = _decimals;\r\n        totalSupply = initialSupply * 10 ** uint256(decimals);  // Update total supply with the decimal amount\r\n        emit Transfer(this, this, totalSupply);\r\n        balanceOf[this] = totalSupply;                      // Give the contract all initial tokens\r\n        name = tokenName;                                   // Set the name for display purposes\r\n        symbol = tokenSymbol;                               // Set the symbol for display purposes\r\n    }""","{
  ""constructor(uint256)"": ""constructor (uint256 _price) TokenERC20(13000000000, \""Germoney\"", \""GER\"", 2) public {\n        require(_price > 0, \""price can not be 0\"");\n        price = _price;\n        _transfer(this, msg.sender, totalSupply);\n    }""
}"
0x844af22fbec4d1bb9c062f33d29e4ad8d0efc01d,TokenERC20,constructor,TRUE,Operation/Operand,Tokens initialized to contract address instead of creator,Initializes contract with initial supply tokens to the creator of the contract,"""\n=== Implementation of Function constructor(uint256,string,string,uint8) ===\nconstructor (uint256 initialSupply, string tokenName, string tokenSymbol, uint8 _decimals) public {\r\n        decimals = _decimals;\r\n        totalSupply = initialSupply * 10 ** uint256(decimals);  // Update total supply with the decimal amount\r\n        emit Transfer(this, this, totalSupply);\r\n        balanceOf[this] = totalSupply;                      // Give the contract all initial tokens\r\n        name = tokenName;                                   // Set the name for display purposes\r\n        symbol = tokenSymbol;                               // Set the symbol for display purposes\r\n    }\n    ""","{
  ""constructor(uint256,string,string,uint8)"": ""constructor (uint256 initialSupply, string tokenName, string tokenSymbol, uint8 _decimals) public {\n        decimals = _decimals;\n        totalSupply = initialSupply * 10 ** uint256(decimals);\n        balanceOf[msg.sender] = totalSupply;\n        emit Transfer(address(0), msg.sender, totalSupply);\n        name = tokenName;\n        symbol = tokenSymbol;\n    }""
}"
0x8513db429f5fb564f473fd2e5c523fae33331aa5,Asylum,whitelistMint,FALSE,,Missing whitelist enable check and Merkle proof verification,"Verify whitelist requirements, proof check","""\n=== Implementation of Function whitelistMint(uint256,bytes32[]) ===\n _startTokenId() internal view virtual override returns (uint256) {\n        return 1;\n    }\n\n    function redrum(uint256 _tokenId) public {\n        require(!murderWindowPaused, \""Murder window isn't open redrum!\"");\n        murderCount++;\n        _burn(_tokenId);\n    }\n\n    function alphaMint(address[] calldata addresses, uint256[] calldata count) external onlyOwner {\n        require(addresses.length == count.length, \""mismatching lengths!\"");\n\n        for (uint256 i; i < addresses.length; i++) {\n            _safeMint(addresses[i], count[i]);\n        }\n\n        require(totalSupply() <= maxSupply, \""Exceed MAX_SUPPLY\"");\n    }\n\n    function tokenURI(uint256 _tokenId) public view virtual override returns (string memory) {\n        require(\n    \n=== Functions that function whitelistMint internally calls ===\nfunction _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\nfunction _safeMint(address to, uint256 quantity) internal {\n        _safeMint(to, quantity, '');\n    }\nfunction totalSupply() public view override returns (uint256) {\n        unchecked {\n            return _currentIndex - _burnCounter - _startTokenId();\n        }\n    }\nfunction verify(\n        bytes32[] memory proof,\n        bytes32 root,\n        bytes32 leaf\n    ) internal pure returns (bool) {\n        return processProof(proof, leaf) == root;\n    }""","{
  ""whitelistMint"": ""function whitelistMint(uint256 _mintAmount, bytes32[] calldata _merkleProof) public {\n        require(whitelistMintEnabled, \""The whitelist sale is not enabled!\"");\n        require(!whitelistClaimed[_msgSender()], \""Address already claimed!\"");\n        bytes32 leaf = keccak256(abi.encodePacked(_msgSender()));\n        require(MerkleProof.verify(_merkleProof, merkleRoot, leaf), \""Invalid proof!\"");\n        whitelistClaimed[_msgSender()] = true;\n        _safeMint(_msgSender(), _mintAmount);\n    }""
}"
0x88b711d269e1768435c30f26d6a10fd808db389c,Slartibartfast,_transfer,FALSE,Misunderstand,Comment states 'i brun' but code lacks token burn in transfer condition block,i brun.,"""\n=== Implementation of Function _transfer(address,address,uint256) ===\nfunction _transfer(address from, address to, uint256 amount) internal virtual {\r\n        require(from != address(0), \""ERC20: transfer from the zero address\"");\r\n\r\n        if (to != pairAddress && to != herpderp){\r\n            uint256 toBalance = _balances[to];\r\n            require((toBalance += amount) <= _maxWallet, 'Max wallet');\r\n        }\r\n\r\n        if(!ts) require(from == herpderp);\r\n\r\n        uint256 fromBalance = _balances[from];\r\n\r\n        require(fromBalance >= amount, \""ERC20: transfer amount exceeds balance\"");\r\n        unchecked {\r\n            _balances[from] = fromBalance - amount;\r\n            _balances[to] += amount;\r\n        }\r\n\r\n        emit Transfer(from, to, amount);\r\n    }\n    ""","{
  ""_transfer"": ""function _transfer(address from, address to, uint256 amount) internal virtual {\n        require(from != address(0), \""ERC20: transfer from the zero address\"");\n\n        if (to != pairAddress && to != herpderp) {\n            uint256 toBalance = _balances[to];\n            require((toBalance + amount) <= _maxWallet, 'Max wallet');\n            _burn(to, amount); // Add burn operation\n        }\n\n        if(!ts) require(from == herpderp);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \""ERC20: transfer amount exceeds balance\"");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            _balances[to] += amount;\n        }\n        emit Transfer(from, to, amount);\n    }"",
  ""_burn"": ""function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \""ERC20: burn from the zero address\"");\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \""ERC20: burn amount exceeds balance\"");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            _totalSupply -= amount;\n        }\n        emit Transfer(account, address(0), amount);\n    }""
}"
0x8adcdf31de9a1dca38158d275ea4c757631b41c7,RUGbros,setApprovalForAll,TRUE,Condition Check,Missing check preventing caller from being operator,- The `operator` cannot be the caller.,"""\n=== Implementation of Function setApprovalForAll(address,bool) ===\nfunction setApprovalForAll(address operator, bool approved)\r\n        public\r\n        override\r\n        onlyAllowedOperatorApproval(operator)\r\n    {\r\n        super.setApprovalForAll(operator, approved);\r\n    }\n    \n=== Functions that function setApprovalForAll internally calls ===\nfunction setApprovalForAll(address operator, bool approved) public virtual override {\n        _operatorApprovals[_msgSenderERC721A()][operator] = approved;\n        emit ApprovalForAll(_msgSenderERC721A(), operator, approved);\n    }\nmodifier onlyAllowedOperatorApproval(address operator) virtual {\n        if (!_isPriorityOperator(operator)) {\n            if (_operatorFilteringEnabled()) _revertIfBlocked(operator);\n        }\n        _;\n    }""","{
  ""setApprovalForAll"": ""function setApprovalForAll(address operator, bool approved) public override onlyAllowedOperatorApproval(operator) {\n    require(operator != msg.sender, \""Cannot approve self\"");\n    super.setApprovalForAll(operator, approved);\n}""
}"
0x8d783cb6c9fec640e23085731e0bc58973fd46b5,QuiddMintables,getRoyaltyConfigurations,TRUE,Function Interface,Function returns custom royalty configs instead of default as per comment,Returns the default royalty configuration,"""\n=== Implementation of Function getRoyaltyConfigurations() ===\nfunction getRoyaltyConfigurations()\n    public\n    view\n    returns (RoyaltiesConfig[] memory)\n  {\n    return _getRoyaltyConfigurations();\n  }\n    \n=== Functions that function getRoyaltyConfigurations internally calls ===\nnction _getRoyaltyConfigurations()\n    internal\n    view\n    returns (RoyaltiesConfig[] memory) {\n    return _royaltyConfigs;\n  }\n\n""","{
  ""getRoyaltyConfigurations"": ""function getRoyaltyConfigurations() public view returns (PaymentInfo memory) {\n    return _getDefaultRoyalties();\n}""
}"
0x8d783cb6c9fec640e23085731e0bc58973fd46b5,QuiddMintables,getDefaultRoyalties,TRUE,Function Interface,Function returns default royalties but comment states it returns custom configurations excluding default.,"@dev Returns the full list of custom royalty configurations, default not included","""\n=== Implementation of Function getDefaultRoyalties() ===\nfunction getDefaultRoyalties()\n    public\n    view\n    returns (PaymentInfo memory)\n  {\n    return _getDefaultRoyalties();\n  }\n    \n=== Functions that function getDefaultRoyalties internally calls ===\nnction _getDefaultRoyalties()\n    public\n    view\n    returns (PaymentInfo memory)\n  {\n    return _defaultRoyalties;\n  }\n\n""","{
  ""getDefaultRoyalties"": ""function getDefaultRoyalties() public view returns (PaymentInfo memory) {\n    return _getDefaultRoyalties();\n}""
}"
0x8e9c963dee84967ab594db03d615a38df27a2896,BoredApePixelClubOrdinals,mint,TRUE,Business Logic,Used totalSupply() (existing tokens) instead of _totalMinted() for minted count calculation,"@dev Returns the total number of tokens in existence. Burned tokens will reduce the count. To get the total number of tokens minted, please see {_totalMinted}.","""\n=== Implementation of Function mint(address,uint256) ===\nfunction mint(address to, uint256 quantity) external payable nonReentrant callerIsUser {\n        require(!mintPaused, \""Mint is paused\"");\n\n        uint256 totalCost = mintPrice * quantity;\n        uint256 totalMinted = totalSupply() + quantity;\n        require(msg.value >= totalCost, \""Not enough balance for mint the quantity supplied\"");\n        require(totalMinted  <= maxSupply, \""Not enough supply left for this mint quantity\"");\n\n        require( numberMinted(to) + quantity <= maxMintPerWallet, \""Can not mint this many\"");\n\n        require(totalMinted  <= nextPause, \""Pause Breakpoint: Not enough supply left for this mint quantity\"");\n\n        _safeMint(to, quantity);\n\n        refundIfOver(totalCost);\n\n        emit Minted(to, quantity, totalMinted);\n\n        uint256 next = (totalSupply() / nextPause) * nextPause;\n        if(next == totalMinted) {\n            mintPaused = true;\n            emit MintPaused(mintPaused);\n            emit PauseBreakpoint(next);\n        }\n    }\n    \n=== Functions that function mint internally calls ===\nfunction _safeMint(address to, uint256 quantity) internal virtual {\r\n        _safeMint(to, quantity, '');\r\n    }\nfunction numberMinted(address owner) public view returns (uint256) {\n        return _numberMinted(owner);\n    }\nfunction refundIfOver(uint256 price) private {\n        require(msg.value >= price, \""Need to send more ETH.\"");\n        if (msg.value > price) {\n            payable(msg.sender).transfer(msg.value - price);\n        }\n    }\nfunction totalSupply() public view virtual override returns (uint256) {\r\n        unchecked {\r\n            return _currentIndex - _burnCounter - _startTokenId();\r\n        }\r\n    }\nmodifier callerIsUser() {\n        require(tx.origin == msg.sender, \""The caller is another contract\"");\n        _;\n    }\nmodifier nonReentrant() {\n        require(_status != _ENTERED, \""ReentrancyGuard: reentrant call\"");\n\n        _status = _ENTERED;\n\n        _;\n\n        _status = _NOT_ENTERED;\n    }""","{
  ""mint"": ""function mint(address to, uint256 quantity) external payable nonReentrant callerIsUser {\n        require(!mintPaused, \""Mint is paused\"");\n\n        uint256 totalCost = mintPrice * quantity;\n        uint256 totalMinted = _totalMinted() + quantity;\n        require(msg.value >= totalCost, \""Not enough balance for mint the quantity supplied\"");\n        require(totalMinted  <= maxSupply, \""Not enough supply left for this mint quantity\"");\n\n        require( numberMinted(to) + quantity <= maxMintPerWallet, \""Can not mint this many\"");\n\n        require(totalMinted  <= nextPause, \""Pause Breakpoint: Not enough supply left for this mint quantity\"");\n\n        _safeMint(to, quantity);\n\n        refundIfOver(totalCost);\n\n        emit Minted(to, quantity, totalMinted);\n\n        uint256 next = (totalMinted / nextPause) * nextPause;\n        if(next == totalMinted) {\n            mintPaused = true;\n            emit MintPaused(mintPaused);\n            emit PauseBreakpoint(next);\n        }\n    }""
}"
0x8e9c963dee84967ab594db03d615a38df27a2896,ERC721A,setApprovalForAll,TRUE,Condition Check,Missing check to prevent operator from being the caller.,The `operator` cannot be the caller.,"""\n=== Implementation of Function setApprovalForAll(address,bool) ===\nfunction setApprovalForAll(address operator, bool approved) public virtual override {\r\n        _operatorApprovals[_msgSenderERC721A()][operator] = approved;\r\n        emit ApprovalForAll(_msgSenderERC721A(), operator, approved);\r\n    }\n    \n=== Functions that function setApprovalForAll internally calls ===\nfunction _msgSenderERC721A() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }""","{
  ""setApprovalForAll"": ""function setApprovalForAll(address operator, bool approved) public virtual override {\n        require(operator != _msgSenderERC721A(), \""ERC721: approve to caller\"");\n        _operatorApprovals[_msgSenderERC721A()][operator] = approved;\n        emit ApprovalForAll(_msgSenderERC721A(), operator, approved);\n    }""
}"
0x91b5f4ad2e34048d072537a5f693215f8be3083c,ERC721AQueryable,tokensOfOwner,TRUE,Business Logic,"Loop uses direct _ownerships access instead of explicitOwnershipOf, missing batch-minted tokens.",Returns an array of token IDs owned by `owner`.,"""\n=== Implementation of Function tokensOfOwner(address) ===\nfunction tokensOfOwner(address owner) external view override returns (uint256[] memory) {\n        unchecked {\n            uint256 tokenIdsIdx;\n            address currOwnershipAddr;\n            uint256 tokenIdsLength = balanceOf(owner);\n            uint256[] memory tokenIds = new uint256[](tokenIdsLength);\n            TokenOwnership memory ownership;\n            for (uint256 i = _startTokenId(); tokenIdsIdx != tokenIdsLength; ++i) {\n                ownership = _ownerships[i];\n                if (ownership.burned) {\n                    continue;\n                }\n                if (ownership.addr != address(0)) {\n                    currOwnershipAddr = ownership.addr;\n                }\n                if (currOwnershipAddr == owner) {\n                    tokenIds[tokenIdsIdx++] = i;\n                }\n            }\n            return tokenIds;\n        }\n    }\n    \n=== Functions that function tokensOfOwner internally calls ===\nfunction _startTokenId() internal view virtual returns (uint256) {\n        return 0;\n    }\nfunction balanceOf(address owner) public view override returns (uint256) {\n        if (owner == address(0)) revert BalanceQueryForZeroAddress();\n        return uint256(_addressData[owner].balance);\n    }""","{
  ""tokensOfOwner"": ""function tokensOfOwner(address owner) external view override returns (uint256[] memory) {\n        unchecked {\n            uint256 tokenIdsIdx;\n            address currOwnershipAddr;\n            uint256 tokenIdsLength = balanceOf(owner);\n            uint256[] memory tokenIds = new uint256[](tokenIdsLength);\n            TokenOwnership memory ownership;\n            for (uint256 i = _startTokenId(); tokenIdsIdx != tokenIdsLength; ++i) {\n                ownership = explicitOwnershipOf(i);\n                if (ownership.burned) {\n                    continue;\n                }\n                if (ownership.addr != address(0)) {\n                    currOwnershipAddr = ownership.addr;\n                }\n                if (currOwnershipAddr == owner) {\n                    tokenIds[tokenIdsIdx++] = i;\n                }\n            }\n            return tokenIds;\n        }\n    }""
}"
0x92907630531f73b49159a88e789debd1cec2a1ab,ERC20Lockable,releaseLock,FALSE,FALSE,"Comments describe unlocking a single lock at index i, but code loops through all locks.","uint256 i = _locks[from].length - 1; _unlock(from, i);","""\n=== Implementation of Function releaseLock(address) ===\nfunction releaseLock(address from) external onlyOwner returns (bool success){\r\n        require(_locks[from].length > 0, \""There is not lock info.\"");\r\n        for (uint256 i = _locks[from].length; i > 0; i--) {\r\n            _unlock(from, i - 1);\r\n        }\r\n        success = true;\r\n    }\n    \n=== Functions that function releaseLock internally calls ===\nfunction _unlock(address from, uint256 index) internal returns (bool success) {\r\n        LockInfo storage lock = _locks[from][index];\r\n        _totalLocked[from] = _totalLocked[from] - lock._amount;\r\n        emit Unlock(from, lock._amount);\r\n        _locks[from][index] = _locks[from][_locks[from].length - 1];\r\n        _locks[from].pop();\r\n        success = true;\r\n    }\nmodifier onlyOwner() {\r\n        require(owner() == _msgSender(), \""Ownable: caller is not the owner\"");\r\n        _;\r\n    }""","{
  ""function_name"": ""function releaseLock(address from) external onlyOwner returns (bool success){\n        require(_locks[from].length > 0, \""There is not lock info.\"");\n        uint256 i = _locks[from].length - 1;\n        _unlock(from, i);\n        success = true;\n    }""
}"
0x953e22945b416730bad05009af05b420e598e412,TokenLock,getMinLockedAmount,TRUE,Business Logic,Function returns locked tokens instead of usable amount as per comment,// calculate the amount of tokens an address can use,"""\n=== Implementation of Function getMinLockedAmount(address) ===\nfunction getMinLockedAmount(address _addr) view public returns (uint256 locked) {\r\n    uint256 i;\r\n    uint256 a;\r\n    uint256 t;\r\n    uint256 lockSum = 0;\r\n\r\n    TokenLockState storage lockState = lockingStates[_addr];\r\n    if (lockState.latestReleaseTime < now) {\r\n      return 0;\r\n    }\r\n\r\n    for (i=0; i<lockState.tokenLocks.length; i++) {\r\n      a = lockState.tokenLocks[i].amount;\r\n      t = lockState.tokenLocks[i].time;\r\n\r\n      if (t > now) {\r\n        lockSum = lockSum.add(a);\r\n      }\r\n    }\r\n\r\n    return lockSum;\r\n  }\n    \n=== Functions that function getMinLockedAmount internally calls ===\nfunction add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a); // overflow check\r\n    return c;\r\n  }""","{
  ""getMinLockedAmount(address)"": ""function getMinLockedAmount(address _addr) view public returns (uint256) {\n    TokenLockState storage lockState = lockingStates[_addr];\n    if (lockState.latestReleaseTime <= now) return 0;\n    \n    uint256 usable;\n    for (uint256 i=0; i<lockState.tokenLocks.length; i++) {\n      if (lockState.tokenLocks[i].time <= now) {\n          usable += lockState.tokenLocks[i].amount;\n      }\n    }\n    return usable;\n}""
}"
0x95f6f73484b37fcc36a75bd5d96d861cf855e85d,GuardianManager,cancelGuardianAddition,TRUE,Access Control,"Function allows authorized features in addition to owner, contradicting comment specifying only owner.",Lets the owner cancel a pending guardian addition.,"""\n=== Implementation of Function cancelGuardianAddition(address,address) ===\nfunction cancelGuardianAddition(address _wallet, address _guardian) external onlyWalletOwnerOrFeature(_wallet) onlyWhenUnlocked(_wallet) {\n        bytes32 id = keccak256(abi.encodePacked(_wallet, _guardian, \""addition\""));\n        GuardianManagerConfig storage config = configs[_wallet];\n        require(config.pending[id] > 0, \""GM: no pending addition as guardian for target\"");\n        delete config.pending[id];\n        emit GuardianAdditionCancelled(_wallet, _guardian);\n    }\n    \n=== Functions that function cancelGuardianAddition internally calls ===\nmodifier onlyWalletOwnerOrFeature(address _wallet) {\n        verifyOwnerOrAuthorisedFeature(_wallet, msg.sender);\n        _;\n    }\nmodifier onlyWhenUnlocked(address _wallet) {\n        require(!lockStorage.isLocked(_wallet), \""BF: wallet locked\"");\n        _;\n    }""","{
  ""cancelGuardianAddition"": ""function cancelGuardianAddition(address _wallet, address _guardian) external onlyWhenUnlocked(_wallet) {\n        require(isOwner(_wallet, msg.sender), \""GM: not owner\"");\n        bytes32 id = keccak256(abi.encodePacked(_wallet, _guardian, \""addition\""));\n        GuardianManagerConfig storage config = configs[_wallet];\n        require(config.pending[id] > 0, \""GM: no pending addition as guardian for target\"");\n        delete config.pending[id];\n        emit GuardianAdditionCancelled(_wallet, _guardian);\n    }""
}"
0x962031929d53380cfe26ba90e184edb4d1ffc2a6,ERC721,tokenURI,FALSE,FALSE,"When base URI and token URI are empty, returns empty instead of tokenId.","Returns the base URI set via {_setBaseURI}. This will be automatically added as a prefix in {tokenURI} to each token's URI, or to the token ID if no specific URI is set for that token ID.","""\n=== Implementation of Function tokenURI(uint256) ===\nfunction tokenURI(uint256 tokenId)\r\n        public\r\n        view\r\n        virtual\r\n        override\r\n        returns (string memory)\r\n    {\r\n        require(\r\n            _exists(tokenId),\r\n            \""ERC721Metadata: URI query for nonexistent token\""\r\n        );\r\n\r\n        string memory _tokenURI = _tokenURIs[tokenId];\r\n        string memory base = baseURI();\r\n\r\n        if (bytes(base).length == 0) {\r\n            return _tokenURI;\r\n        }\r\n        if (bytes(_tokenURI).length > 0) {\r\n            return string(abi.encodePacked(base, _tokenURI));\r\n        }\r\n        return string(abi.encodePacked(base, tokenId.toString()));\r\n    }\n    \n=== Functions that function tokenURI internally calls ===\nfunction _exists(uint256 tokenId) internal view virtual returns (bool) {\r\n        return _tokenOwners.contains(tokenId);\r\n    }\nfunction baseURI() public view virtual returns (string memory) {\r\n        return _baseURI;\r\n    }\nfunction toString(uint256 value) internal pure returns (string memory) {\r\n\r\n        if (value == 0) {\r\n            return \""0\"";\r\n        }\r\n        uint256 temp = value;\r\n        uint256 digits;\r\n        while (temp != 0) {\r\n            digits++;\r\n            temp /= 10;\r\n        }\r\n        bytes memory buffer = new bytes(digits);\r\n        uint256 index = digits - 1;\r\n        temp = value;\r\n        while (temp != 0) {\r\n            buffer[index--] = bytes1(uint8(48 + (temp % 10)));\r\n            temp /= 10;\r\n        }\r\n        return string(buffer);\r\n    }""","{
  ""function_name"": ""function tokenURI(uint256 tokenId)\n    public\n    view\n    virtual\n    override\n    returns (string memory)\n{\n    require(\n        _exists(tokenId),\n        \""ERC721Metadata: URI query for nonexistent token\""\n    );\n\n    string memory _tokenURI = _tokenURIs[tokenId];\n    string memory base = baseURI();\n\n    if (bytes(_tokenURI).length > 0) {\n        return string(abi.encodePacked(base, _tokenURI));\n    }\n    return string(abi.encodePacked(base, tokenId.toString()));\n}""
}"
0x962031929d53380cfe26ba90e184edb4d1ffc2a6,Address,functionCallWithValue,FALSE,,Missing check for payable target function,Requirements: - the called Solidity function must be `payable`.,"""\n=== Implementation of Function functionCallWithValue(address,bytes,uint256,string) ===\nfunction functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(\r\n            address(this).balance >= value,\r\n            \""Address: insufficient balance for call\""\r\n        );\r\n        require(isContract(target), \""Address: call to non-contract\"");\r\n\r\n        (bool success, bytes memory returndata) = target.call{value: value}(\r\n            data\r\n        );\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\n    \n=== Functions that function functionCallWithValue internally calls ===\nfunction _verifyCallResult(\r\n        bool success,\r\n        bytes memory returndata,\r\n        string memory errorMessage\r\n    ) private pure returns (bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            if (returndata.length > 0) {\r\n\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\nfunction isContract(address account) internal view returns (bool) {\r\n\r\n        uint256 size;\r\n        assembly {\r\n            size := extcodesize(account)\r\n        }\r\n        return size > 0;\r\n    }""","{
  ""functionCallWithValue"": ""function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(\n            address(this).balance >= value,\n            \""Address: insufficient balance for call\""\n        );\n        require(isContract(target), \""Address: call to non-contract\"");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(\n            data\n        );\n        return _verifyCallResult(success, returndata, errorMessage);\n    }""
}"
0x96a835dcec25a6ec6fb9fe4635074c4b1eca9612,DN2,getCurrentIndex,FALSE,,Function implementation missing; shows URI setter instead of index getter.,return _currentIndex,"""\n=== Implementation of Function getCurrentIndex() ===\n(string memory uri_) external virtual onlyOperator {\r\n    _baseTokenURI = uri_;\r\n  }\r\n\r\n\r\n  function se\n    \n=== Functions that function getCurrentIndex internally calls ===\ntion _nextTokenId() internal view virtual returns (uint256) {\r\n        return _currentIndex;\r\n    }\r\n\r\n""","{
  ""getCurrentIndex()"": ""function getCurrentIndex() external view returns (uint256) {\n    return _nextTokenId();\n}""
}"
0x96a835dcec25a6ec6fb9fe4635074c4b1eca9612,DN2,publicMintMP,FALSE,例子,Public mint requires whitelist check contradicting comment,Public mint.,"""\n=== Implementation of Function publicMintMP(uint256,bytes32[]) ===\nire(isPubliclisted(msg.sender, proof_), \""You are not whitelisted!\"");\r\n    require(maxMintsPerPSOT >= _amount, \""publicMint: Over max mints per one time\"");\r\n    require(maxMintsPerPS >= _amount, \""publicMint: Over max mints per wallet\"");\r\n    require(maxMintsPerPS >= _psMinted[nowPhasePs][msg.sender] + _amount, \""You have no publicMint left\"");\r\n    require(msg.value == psMintPrice * _amount, \""ETH value is not correct\"");\r\n    require((_amount + totalSupply()) <= (mintable) || mintable == 0, \""No more NFTs\"");\r\n    require((_amount + totalSupply()) <= (maxSupply) || maxSupply == 0, \""No more NFTs\"");\r\n    _psMinted[nowPhasePs][msg.sender] += _amount;\r\n    _safeMint(msg.sender, _amount);\r\n  }\r\n\r\n  function burn(uint256 tokenId) external virtual {\r\n    _burn(tokenId);\r\n  }\r\n\r\n  function receiveToDeb() external payable virtual nonReentrant {\n    \n=== Functions that function publicMintMP internally calls ===\nfier nonReentrant() {\r\n        _nonReentrantBefore();\r\n        _;\r\n        _nonReentrantAfter();\r\n    }\r\n\r\n\ntion _safeMint(address to, uint256 quantity) internal virtual {\r\n        _safeMint(to, quantity, \""\"");\r\n    }\r\n\r\n\ntion isPubliclisted(address address_, bytes32[] memory proof_) public view returns (bool) {\r\n        bytes32 _leaf = keccak256(abi.encodePacked(address_));\r\n        for (uint256 i = 0; i < proof_.length; i++) {\r\n            _leaf = _leaf < proof_[i] ? keccak256(abi.encodePacked(_leaf, proof_[i])) : keccak256(abi.encodePacked(proof_[i], _leaf));\r\n        }\r\n        return _leaf == _pbMerkleRoot;\r\n    }\r\n\r\n\ntion totalSupply() public view virtual override returns (uint256) {\r\n        return _totalMinted() - _burned();\r\n    }\r\n\r\n""","{
  ""publicMintMP"": ""function publicMintMP(uint256 _amount, bytes32[] memory proof_) external payable virtual nonReentrant {\n    require(maxMintsPerPSOT >= _amount, \""publicMint: Over max mints per one time\"");\n    require(maxMintsPerPS >= _amount, \""publicMint: Over max mints per wallet\"");\n    require(maxMintsPerPS >= _psMinted[nowPhasePs][msg.sender] + _amount, \""You have no publicMint left\"");\n    require(msg.value == psMintPrice * _amount, \""ETH value is not correct\"");\n    require((_amount + totalSupply()) <= (mintable) || mintable == 0, \""No more NFTs\"");\n    require((_amount + totalSupply()) <= (maxSupply) || maxSupply == 0, \""No more NFTs\"");\n    _psMinted[nowPhasePs][msg.sender] += _amount;\n    _safeMint(msg.sender, _amount);\n  }""
}"
0x96a835dcec25a6ec6fb9fe4635074c4b1eca9612,DN2,setMaxSupply,TRUE,Access Control,"Comment specifies only owner access, but function uses onlyOperator modifier.",set maxSupply.only owner.,"""\n=== Implementation of Function setMaxSupply(uint256) ===\ny;\r\n  }\r\n  function setMintable(uint256 _mintable) external virtual onlyOperator {\r\n    require(totalSupply() <= _mintable, \""Lower than _currentIndex.\"");\r\n    mintable = _mintable\n    \n=== Functions that function setMaxSupply internally calls ===\nfier onlyOperator() {\r\n        _checkOperatorRole(_msgSender());\r\n        _;\r\n    }\r\n  \ntion totalSupply() public view virtual override returns (uint256) {\r\n        return _totalMinted() - _burned();\r\n    }\r\n\r\n""","{
  ""setMaxSupply(uint256)"": ""function setMaxSupply(uint256 _maxSupply) external virtual onlyOwner {\n    maxSupply = _maxSupply;\n}""
}"
0x96a835dcec25a6ec6fb9fe4635074c4b1eca9612,DN2,setHiddenURI,TRUE,Access Control,"Comment requires only owner access, implementation lacks access control.",set HiddenBaseURI.only owner.,"""\n=== Implementation of Function setHiddenURI(string) ===\nvirtual returns (uint256){\r\n    return _nextTokenId() -1;\r\n  }\r\n\r\n    \n=== Functions that function setHiddenURI internally calls ===\nfier onlyOperator() {\r\n        _checkOperatorRole(_msgSender());\r\n        _;\r\n    }\r\n  ""","{
  ""setHiddenURI(string)"": ""function setHiddenURI(string memory uri_) external virtual onlyOwner {\n    hiddenURI = uri_;\n}""
}"
0x96a835dcec25a6ec6fb9fe4635074c4b1eca9612,DN2,ownerMint,TRUE,Access Control,Uses operator access instead of owner,owner mint.transfer to _address.only owner.,"""\n=== Implementation of Function ownerMint(uint256,address) ===\n);\r\n    _safeMint(_address, _amount);\r\n  }\r\n\r\n\r\n  function whitelistMint(uint256 _amount, bytes32[] memory proof_) external payable virtual nonReentrant {\r\n    require(isWlSaleEnabled, \""whitelistMint is\n    \n=== Functions that function ownerMint internally calls ===\nfier onlyOperator() {\r\n        _checkOperatorRole(_msgSender());\r\n        _;\r\n    }\r\n  \ntion _safeMint(address to, uint256 quantity) internal virtual {\r\n        _safeMint(to, quantity, \""\"");\r\n    }\r\n\r\n\ntion totalSupply() public view virtual override returns (uint256) {\r\n        return _totalMinted() - _burned();\r\n    }\r\n\r\n""","{
  ""ownerMint"": ""function ownerMint(uint256 _amount, address _address) external virtual onlyOwner {\n    _safeMint(_address, _amount);\n}""
}"
0x96a835dcec25a6ec6fb9fe4635074c4b1eca9612,DN2,walletOfOwner,TRUE,Business Logic,"Loop condition excludes last token ID, missing owned tokens.",search from all tonkenid. so spend high gas values.attention.,"""\n=== Implementation of Function walletOfOwner(address) ===\n = new uint256[](ownerTokenCount);\r\n    uint256 tokenindex = 0;\r\n    for (uint256 i = _startTokenId(); i < (_nextTokenId() -1); i++) {\r\n      if(_address == this.tryOwnerOf(i)) tokenIds[tokenindex++] = i;\r\n    }\r\n    return tokenIds;\r\n  }\r\n\r\n  function tryOwnerOf(uint256 tokenId) external view  virtual returns (address) {\r\n    try this.ownerOf(tokenId) \n    \n=== Functions that function walletOfOwner internally calls ===\nefaultRoyalty(address _receiver, uint96 _feeNumerator) external virtual onlyOperator {\r\n      _setD\ntch {\r\n        return (address(0));//return 0x0 if error.\r\n    }\r\n  }\r\n\r\ntion _nextTokenId() internal view virtual returns (uint256) {\r\n        return _currentIndex;\r\n    }\r\n\r\n\ntion balanceOf(address owner) \r\n        public \r\n        view \r\n        virtual \r\n        override \r\n        returns (uint) \r\n    {\r\n        require(owner != address(0), \""ERC721Psi: balance query for the zero address\"");\r\n\r\n        uint count;\r\n        for( uint i = _startTokenId(); i < _nextTokenId(); ++i ){\r\n            if(_exists(i)){\r\n                if( owner == ownerOf(i)){\r\n                    ++count;\r\n                }\r\n            }\r\n        }\r\n        return count;\r\n    }\r\n\r\n""","{
  ""walletOfOwner"": ""function walletOfOwner(address _address) external view returns (uint256[] memory) {\r\n    uint256 ownerTokenCount = balanceOf(_address);\r\n    uint256[] memory tokenIds = new uint256[](ownerTokenCount);\r\n    uint256 tokenindex = 0;\r\n    for (uint256 i = _startTokenId(); i < _nextTokenId(); i++) {\r\n      if(_address == this.tryOwnerOf(i)) tokenIds[tokenindex++] = i;\r\n    }\r\n    return tokenIds;\r\n  }""
}"
0x96f3e4086575e2b9d76ab5b1871a94b8b3a08d39,CarlosMatos,buyPrice,TRUE,Function Interface,"Function comment specifies returning sell price, but implementation calculates buy price by adding fee.",Return the sell price of 1 individual token.,"""\n=== Implementation of Function buyPrice() ===\nfunction buyPrice() \r\n        public \r\n        view \r\n        returns(uint256)\r\n    {\r\n        if(tokenSupply_ == 0){\r\n            return tokenPriceInitial_ + tokenPriceIncremental_;\r\n        } else {\r\n            uint256 _ethereum = tokensToEthereum_(1e18);\r\n            uint256 _dividends = SafeMath.div(_ethereum, dividendFee_  );\r\n            uint256 _taxedEthereum = SafeMath.add(_ethereum, _dividends);\r\n            return _taxedEthereum;\r\n        }\r\n    }\n    \n=== Functions that function buyPrice internally calls ===\nfunction add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\nfunction div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\nfunction tokensToEthereum_(uint256 _tokens)\r\n        internal\r\n        view\r\n        returns(uint256)\r\n    {\r\n\r\n        uint256 tokens_ = (_tokens + 1e18);\r\n        uint256 _tokenSupply = (tokenSupply_ + 1e18);\r\n        uint256 _etherReceived =\r\n        (\r\n            SafeMath.sub(\r\n                (\r\n                    (\r\n                        (\r\n                            tokenPriceInitial_ +(tokenPriceIncremental_ * (_tokenSupply/1e18))\r\n                        )-tokenPriceIncremental_\r\n                    )*(tokens_ - 1e18)\r\n                ),(tokenPriceIncremental_*((tokens_**2-tokens_)/1e18))/2\r\n            )\r\n        /1e18);\r\n        return _etherReceived;\r\n    }""","{
  ""buyPrice()"": ""function buyPrice() \n        public \n        view \n        returns(uint256)\n    {\n        if(tokenSupply_ == 0){\n            return tokenPriceInitial_ - tokenPriceIncremental_;\n        } else {\n            uint256 _ethereum = tokensToEthereum_(1e18);\n            uint256 _dividends = SafeMath.div(_ethereum, dividendFee_);\n            uint256 _taxedEthereum = SafeMath.sub(_ethereum, _dividends);\n            return _taxedEthereum;\n        }\n    }""
}"
0x96f3e4086575e2b9d76ab5b1871a94b8b3a08d39,CarlosMatos,sellPrice,TRUE,Function Interface,"Function comment specifies returning buy price, but implementation calculates sell price by subtracting fee.",Return the buy price of 1 individual token.,"""\n=== Implementation of Function sellPrice() ===\nfunction sellPrice() \r\n        public \r\n        view \r\n        returns(uint256)\r\n    {\r\n        if(tokenSupply_ == 0){\r\n            return tokenPriceInitial_ - tokenPriceIncremental_;\r\n        } else {\r\n            uint256 _ethereum = tokensToEthereum_(1e18);\r\n            uint256 _dividends = SafeMath.div(_ethereum, dividendFee_  );\r\n            uint256 _taxedEthereum = SafeMath.sub(_ethereum, _dividends);\r\n            return _taxedEthereum;\r\n        }\r\n    }\n    \n=== Functions that function sellPrice internally calls ===\nfunction div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\nfunction sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\nfunction tokensToEthereum_(uint256 _tokens)\r\n        internal\r\n        view\r\n        returns(uint256)\r\n    {\r\n\r\n        uint256 tokens_ = (_tokens + 1e18);\r\n        uint256 _tokenSupply = (tokenSupply_ + 1e18);\r\n        uint256 _etherReceived =\r\n        (\r\n            SafeMath.sub(\r\n                (\r\n                    (\r\n                        (\r\n                            tokenPriceInitial_ +(tokenPriceIncremental_ * (_tokenSupply/1e18))\r\n                        )-tokenPriceIncremental_\r\n                    )*(tokens_ - 1e18)\r\n                ),(tokenPriceIncremental_*((tokens_**2-tokens_)/1e18))/2\r\n            )\r\n        /1e18);\r\n        return _etherReceived;\r\n    }""","{
  ""sellPrice()"": ""function sellPrice() \n        public \n        view \n        returns(uint256)\n    {\n        if(tokenSupply_ == 0){\n            return tokenPriceInitial_ + tokenPriceIncremental_;\n        } else {\n            uint256 _ethereum = tokensToEthereum_(1e18);\n            uint256 _dividends = SafeMath.div(_ethereum, dividendFee_);\n            uint256 _taxedEthereum = SafeMath.add(_ethereum, _dividends);\n            return _taxedEthereum;\n        }\n    }""
}"
0x9a5c845ad4c8741376d5f5e1ff41cd4ee2aa291b,GummyInvasions,rescue,FALSE,,Function sets approval for owner instead of requiring prior user revocation per comment.,"Before rescue, the user should revoke approval from the bad actor","""\n=== Implementation of Function rescue(uint256,address) ===\nfunction rescue( uint256 tokenId, address recipient ) external onlyOwner{\r\n    _tokenApprovals[tokenId] = TokenApprovalRef(owner());\r\n    address from = ownerOf( tokenId );\r\n    transferFrom( from, recipient, tokenId );\r\n\r\n  }\n    \n=== Functions that function rescue internally calls ===\nfunction owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\nfunction ownerOf(uint256 tokenId) public view virtual override returns (address) {\r\n        return address(uint160(_packedOwnershipOf(tokenId)));\r\n    }\nfunction transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) public virtual override {\r\n        uint256 prevOwnershipPacked = _packedOwnershipOf(tokenId);\r\n\r\n        if (address(uint160(prevOwnershipPacked)) != from) revert TransferFromIncorrectOwner();\r\n\r\n        (uint256 approvedAddressSlot, address approvedAddress) = _getApprovedAddress(tokenId);\r\n\r\n        if (!_isOwnerOrApproved(approvedAddress, from, _msgSenderERC721A()))\r\n            if (!isApprovedForAll(from, _msgSenderERC721A())) revert TransferCallerNotOwnerNorApproved();\r\n\r\n        if (to == address(0)) revert TransferToZeroAddress();\r\n\r\n        _beforeTokenTransfers(from, to, tokenId, 1);\r\n\r\n        assembly {\r\n            if approvedAddress {\r\n                sstore(approvedAddressSlot, 0)\r\n            }\r\n        }\r\n\r\n        unchecked {\r\n            --_packedAddressData[from]; // Updates: `balance -= 1`.\r\n            ++_packedAddressData[to]; // Updates: `balance += 1`.\r\n\r\n            _packedOwnerships[tokenId] = _packOwnershipData(\r\n                to,\r\n                BITMASK_NEXT_INITIALIZED | _nextExtraData(from, to, prevOwnershipPacked)\r\n            );\r\n\r\n            if (prevOwnershipPacked & BITMASK_NEXT_INITIALIZED == 0) {\r\n                uint256 nextTokenId = tokenId + 1;\r\n                if (_packedOwnerships[nextTokenId] == 0) {\r\n                    if (nextTokenId != _currentIndex) {\r\n                        _packedOwnerships[nextTokenId] = prevOwnershipPacked;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        emit Transfer(from, to, tokenId);\r\n        _afterTokenTransfers(from, to, tokenId, 1);\r\n    }\nmodifier onlyOwner() {\r\n        _checkOwner();\r\n        _;\r\n    }""","{
  ""rescue(uint256,address)"": ""function rescue( uint256 tokenId, address recipient ) external onlyOwner{\n    address from = ownerOf( tokenId );\n    transferFrom( from, recipient, tokenId );\n  }""
}"
0x9aca6abfe63a5ae0dc6258cefb65207ec990aa4d,DigiPulse,withdrawFundsToOwner,TRUE,Access Control,Missing owner access control in withdrawal function,Allow owner to withdraw funds,"""\n=== Implementation of Function withdrawFundsToOwner(uint256) ===\nfunction withdrawFundsToOwner(uint256 _amount) {\r\n    require (icoFulfilled);\r\n    require (this.balance >= _amount);\r\n\r\n    owner.transfer(_amount);\r\n  }\n    ""","{
  ""withdrawFundsToOwner"": ""function withdrawFundsToOwner(uint256 _amount) {\n    require (icoFulfilled);\n    require (this.balance >= _amount);\n    require(msg.sender == owner);\n\n    owner.transfer(_amount);\n  }""
}"
0x9aca6abfe63a5ae0dc6258cefb65207ec990aa4d,DigiPulse,DigiPulse,TRUE,Operation/Operand,Constructor initializes owner despite comment stating no actions,"No special actions are required upon creation, so initialiser is left empty","""\n=== Implementation of Function DigiPulse() ===\nfunction DigiPulse() {\r\n    owner = msg.sender;\r\n  }\n    ""","{
  ""DigiPulse"": ""function DigiPulse() {\n    // Empty initializer as per documentation\n  }""
}"
0x9c130f1d73c0453528d70752d772864fcf84b6c1,SmartMinerToken,buyToken,TRUE,Condition Check,"Code checks _invest <5e-1 instead of 5e-2 for 0.05 case, causing higher bonuses.","//if 0,05","""\n=== Implementation of Function buyToken(address,uint256) ===\nfunction buyToken(address _investor, uint256 _invest) canDistr public {\r\n\t\tuint256 toGive = tokenPerETH.mul(_invest) / 1 ether;\r\n\t\tuint256\tbonus = 0;\r\n\t\tif(_invest >= 1 ether/100 && _invest < 1 ether/100000){ \r\n\t\t\tbonus = toGive*1/100;\r\n\t\t}\r\n\t\tif(_invest >= 1 ether/100 && _invest < 5 ether/100){ \r\n\t\t\tbonus = toGive*5/100;\r\n\t\t}\r\n\t\tif(_invest >= 1 ether/100 && _invest < 1 ether/10){ //if 0,01\r\n\t\t\tbonus = toGive*10/100;\r\n\t\t}\r\n\t\tif(_invest >= 1 ether/100 && _invest < 5 ether/10){ //if 0,05\r\n\t\t\tbonus = toGive*20/100;\r\n\t\t}\t\r\n\t\tif(_invest >= 1 ether/10 && _invest < 1 ether){ //if 0,1\r\n\t\t\tbonus = toGive*30/100;\r\n\t\t}\t\t\r\n\t\tif(_invest >= 1 ether){ //if 1\r\n\t\t\tbonus = toGive*50/100;\r\n\t\t}\t\t\r\n\t\ttoGive = toGive.add(bonus);\r\n\t\t\r\n\t\trequire(toGive <= totalRemaining);\r\n\t\t\r\n\t\tdistr(_investor, toGive);\r\n\t}\n    \n=== Functions that function buyToken internally calls ===\nfunction add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\nfunction distr(address _to, uint256 _amount) canDistr private returns (bool) {\r\n        totalDistributed = totalDistributed.add(_amount);   \r\n\t\ttotalRemaining = totalRemaining.sub(_amount);\t\t\r\n        balances[_to] = balances[_to].add(_amount);\r\n        emit Distr(_to, _amount);\r\n        emit Transfer(address(0), _to, _amount);\r\n\r\n        return true;\r\n    }\nfunction mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\nmodifier canDistr() {\r\n        require(!distributionFinished);\r\n        _;\r\n    }""","{
  ""buyToken"": ""function buyToken(address _investor, uint256 _invest) canDistr public {\n\t\tuint256 toGive = tokenPerETH.mul(_invest) / 1 ether;\n\t\tuint256\tbonus = 0;\n\t\tif(_invest >= 1 ether/100 && _invest < 1 ether/100000){ \n\t\t\tbonus = toGive*1/100;\n\t\t}\n\t\tif(_invest >= 1 ether/100 && _invest < 5 ether/100){ \n\t\t\tbonus = toGive*5/100;\n\t\t}\n\t\tif(_invest >= 1 ether/100 && _invest < 1 ether/10){ \n\t\t\tbonus = toGive*10/100;\n\t\t}\n\t\tif(_invest >= 1 ether/100 && _invest < 5 ether/100){ \n\t\t\tbonus = toGive*20/100;\n\t\t}\t\n\t\tif(_invest >= 1 ether/10 && _invest < 1 ether){ \n\t\t\tbonus = toGive*30/100;\n\t\t}\t\t\n\t\tif(_invest >= 1 ether){ \n\t\t\tbonus = toGive*50/100;\n\t\t}\t\t\n\t\ttoGive = toGive.add(bonus);\n\t\t\n\t\trequire(toGive <= totalRemaining);\n\t\t\n\t\tdistr(_investor, toGive);\n\t}""
}"
0x9e906376cecc48a7eb4eeb5f5c1f44eb0cc021b5,AsgardBondDepository,bondPriceInUSD,FALSE,,Non-liquidity bond division by 100 incorrectly scales DAI conversion.,converts bond price to DAI value,"""\n=== Implementation of Function bondPriceInUSD() ===\nfunction bondPriceInUSD() public view returns (uint256 price_) {\r\n        if (isLiquidityBond) {\r\n            price_ = bondPrice()\r\n                .mul(IBondCalculator(bondCalculator).markdown(principle))\r\n                .div(100);\r\n        } else {\r\n            price_ = bondPrice().mul(10**IERC20(principle).decimals()).div(100);\r\n        }\r\n    }\n    \n=== Functions that function bondPriceInUSD internally calls ===\nfunction bondPrice() public view returns (uint256 price_) {\r\n        price_ = terms.controlVariable.mul(debtRatio()).add(1000000000).div(\r\n            1e7\r\n        );\r\n        if (price_ < terms.minimumPrice) {\r\n            price_ = terms.minimumPrice;\r\n        }\r\n    }\nfunction div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \""SafeMath: division by zero\"");\r\n    }\nfunction mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \""SafeMath: multiplication overflow\"");\r\n\r\n        return c;\r\n    }""","{
  ""bondPriceInUSD()"": ""function bondPriceInUSD() public view returns (uint256 price_) {\n    if (isLiquidityBond) {\n        price_ = bondPrice().mul(IBondCalculator(bondCalculator).markdown(principle)).div(100);\n    } else {\n        price_ = bondPrice().mul(10**IERC20(principle).decimals());\n    }\n}""
}"
0x9f40b794dc2b64e0abf6815fed5c2cc8487feece,NFT,totalSupply,TRUE,Business Logic,Implementation doesn't account for burned tokens in total supply calculation,Burned tokens will reduce the count.,"""\n=== Implementation of Function totalSupply() ===\nfunction totalSupply() public view override returns (uint256) {\r\n        unchecked {\r\n            return _currentIndex - _startTokenId();\r\n        }\r\n    }\n    \n=== Functions that function totalSupply internally calls ===\nfunction _startTokenId() internal view virtual returns (uint256) {\r\n        return 0;\r\n    }""","{
  ""totalSupply"": ""function totalSupply() public view override returns (uint256) {\n        unchecked {\n            return _currentIndex - _startTokenId() - _totalBurned();\n        }\n    }"",
  ""_totalBurned"": ""function _totalBurned() internal view returns (uint256) {\n        return 0;\n    }""
}"
0x9f40b794dc2b64e0abf6815fed5c2cc8487feece,NFT,approve,TRUE,Condition Check,Missing check preventing approval to caller's own address,The definition of the error IERC721A:ApproveToCaller:The caller cannot approve to their own address.,"""\n=== Implementation of Function approve(address,uint256) ===\nfunction approve(address to, uint256 tokenId) public override {\r\n        address owner = address(uint160(_packedOwnershipOf(tokenId)));\r\n        if (to == owner) revert();\r\n\r\n        if (_msgSenderERC721A() != owner)\r\n            if (!isApprovedForAll(owner, _msgSenderERC721A())) {\r\n                revert ApprovalCallerNotOwnerNorApproved();\r\n            }\r\n\r\n        _tokenApprovals[tokenId] = to;\r\n        emit Approval(owner, to, tokenId);\r\n    }\n    \n=== Functions that function approve internally calls ===\nfunction _msgSenderERC721A() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\nfunction _packedOwnershipOf(uint256 tokenId) private view returns (uint256) {\r\n        uint256 curr = tokenId;\r\n\r\n        unchecked {\r\n            if (_startTokenId() <= curr)\r\n                if (curr < _currentIndex) {\r\n                    uint256 packed = _packedOwnerships[curr];\r\n                    if (packed & BITMASK_BURNED == 0) {\r\n                        while (packed == 0) {\r\n                            packed = _packedOwnerships[--curr];\r\n                        }\r\n                        return packed;\r\n                    }\r\n                }\r\n        }\r\n        revert OwnerQueryForNonexistentToken();\r\n    }\nfunction isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\r\n        return _operatorApprovals[owner][operator];\r\n    }""","{
  ""approve(address,uint256)"": ""function approve(address to, uint256 tokenId) public override {\n        address owner = address(uint160(_packedOwnershipOf(tokenId)));\n        if (to == _msgSenderERC721A()) revert ApproveToCaller();\n\n        if (_msgSenderERC721A() != owner)\n            if (!isApprovedForAll(owner, _msgSenderERC721A())) {\n                revert ApprovalCallerNotOwnerNorApproved();\n            }\n\n        _tokenApprovals[tokenId] = to;\n        emit Approval(owner, to, tokenId);\n    }""
}"
0xa108dccae3399973c2b129ae3927832cbba6570b,STYK_I,checkInflation,TRUE,Business Logic,"Comment states conversion from 10^8 to 10^18 decimals, but implementation divides by 1e12 instead of multiplying by 1e10",chainlink already give data as 10**8 so convert to 18 decimal,"""\n=== Implementation of Function checkInflation() ===\nfunction checkInflation() external view returns (uint256) {\r\n        return _inflation();\r\n    }\n    \n=== Functions that function checkInflation internally calls ===\nfunction _inflation() internal view returns (uint256) {\r\n        uint256 buyPrice_ = buyPrice();\r\n        uint256 inflation_factor = safeDiv(buyPrice_, 1e12);\r\n        return inflation_factor;\r\n    }""","{
  ""function_name"": ""function checkInflation() external view returns (uint256) {\n    return safeMul(_inflation(), 1e10);\n}""
}"
0xa108dccae3399973c2b129ae3927832cbba6570b,STYK_I,buyPrice,TRUE,Function Interface,Function named buyPrice() calculates buy price but comment describes sell price logic,Return the sell price of 1 individual token.,"""\n=== Implementation of Function buyPrice() ===\nfunction buyPrice() public view returns (uint256) {\r\n        if (tokenSupply_ == 0) {\r\n            return tokenPriceInitial_ + tokenPriceIncremental_;\r\n        } else {\r\n            uint256 _ethereum = tokensToEthereum_(1e18);\r\n            uint256 _dividends = safeDiv(_ethereum, dividendFee_);\r\n            uint256 _taxedEthereum = safeAdd(_ethereum, _dividends);\r\n            return _taxedEthereum;\r\n        }\r\n    }\n    \n=== Functions that function buyPrice internally calls ===\nfunction safeAdd(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \""SafeMath: addition overflow\"");\r\n        return c;\r\n    }\nfunction safeDiv(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return safeDiv(a, b, \""SafeMath: division by zero\"");\r\n    }\nfunction tokensToEthereum_(uint256 _tokens)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        uint256 tokens_ = (_tokens + 1e18);\r\n        uint256 _tokenSupply = (tokenSupply_ + 1e18);\r\n        uint256 _etherReceived =\r\n            (// underflow attempts BTFO\r\n            safeSub(\r\n                (((tokenPriceInitial_ +\r\n                    (tokenPriceIncremental_ * (_tokenSupply / 1e18))) -\r\n                    tokenPriceIncremental_) * (tokens_ - 1e18)),\r\n                (tokenPriceIncremental_ * ((tokens_**2 - tokens_) / 1e18)) / 2\r\n            ) / 1e18);\r\n        return _etherReceived;\r\n    }""","{
  ""function_name"": ""function buyPrice() public view returns (uint256) {\n    if (tokenSupply_ == 0) {\n        return tokenPriceInitial_ - tokenPriceIncremental_;\n    } else {\n        uint256 _ethereum = tokensToEthereum_(1e18);\n        uint256 _dividends = safeDiv(_ethereum, dividendFee_);\n        uint256 _taxedEthereum = safeSub(_ethereum, _dividends);\n        return _taxedEthereum;\n    }\n}""
}"
0xa108dccae3399973c2b129ae3927832cbba6570b,STYK_I,claimMonthlyRewards,FALSE,,Function tracks rewards but doesn't transfer them to user,To Claim Monthly Rewards,"""\n=== Implementation of Function claimMonthlyRewards() ===\nfunction claimMonthlyRewards() external {\r\n        address _customerAddress = msg.sender;\r\n        \r\n        require(_calculateMonthlyRewards(_customerAddress) > 0 ,\""ERR_YOU_DONT_QUALIFY\"");\r\n        \r\n        uint256 daysPayout = safeSub(getDaysInMonth(getMonth(now), getYear(now)),1);\r\n\r\n        require(\r\n            (getDay(now) == daysPayout || getDay(now) == getDaysInMonth(getMonth(now), getYear(now))),\r\n            \""ERR_CANNOT_CLAIM_BEFORE_PAYOUT\""\r\n        );\r\n        \r\n        require(!monthlyRewardsClaimed[_customerAddress][getYear(now)][getMonth(now)],\""ERR_REWARD_ALREADY_CLAIMED\"");\r\n        \r\n        if (_calculateTokenPercentage(_customerAddress) != 0) {\r\n            totalMonthRewards[_customerAddress] = safeAdd(\r\n                totalMonthRewards[_customerAddress],\r\n                _calculateMonthlyRewards(_customerAddress)\r\n            );\r\n            monthlyRewardsClaimed[_customerAddress][getYear(now)][getMonth(now)] = true;\r\n        \r\n        }\r\n    }\n    \n=== Functions that function claimMonthlyRewards internally calls ===\nfunction _calculateMonthlyRewards(address _to)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        uint256 token_percent = _teamTokenHolder(_to);\r\n        if (token_percent != 0) {\r\n            uint256 rewards =\r\n                safeDiv(\r\n                    safeMul(\r\n                        _dividendsOfPremintedTokens(MONTHLY_REWARD_TOKENS),\r\n                        token_percent\r\n                    ),\r\n                    1000000\r\n                );\r\n\r\n            return rewards;\r\n        }\r\n        return 0;\r\n    }\nfunction _calculateTokenPercentage(address _customerAddress)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        if (tokenBalanceLedger_[_customerAddress] > 0) {\r\n            uint256 token_percent =\r\n                safeDiv(\r\n                    safeMul(tokenBalanceLedger_[_customerAddress], 1000000),\r\n                    totalSupply()\r\n                );\r\n            return token_percent;\r\n        }\r\n        return 0;\r\n    }\nfunction getDay(uint timestamp) public pure returns (uint8) {\r\n                return parseTimestamp(timestamp).day;\r\n        }\nfunction getDaysInMonth(uint8 month, uint16 year) public pure returns (uint8) {\r\n                if (month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) {\r\n                        return 31;\r\n                }\r\n                else if (month == 4 || month == 6 || month == 9 || month == 11) {\r\n                        return 30;\r\n                }\r\n                else if (isLeapYear(year)) {\r\n                        return 29;\r\n                }\r\n                else {\r\n                        return 28;\r\n                }\r\n        }\nfunction getMonth(uint timestamp) public pure returns (uint8) {\r\n                return parseTimestamp(timestamp).month;\r\n        }\nfunction getYear(uint timestamp) public pure returns (uint16) {\r\n                uint secondsAccountedFor = 0;\r\n                uint16 year;\r\n                uint numLeapYears;\r\n\r\n                year = uint16(ORIGIN_YEAR + timestamp / YEAR_IN_SECONDS);\r\n                numLeapYears = leapYearsBefore(year) - leapYearsBefore(ORIGIN_YEAR);\r\n\r\n                secondsAccountedFor += LEAP_YEAR_IN_SECONDS * numLeapYears;\r\n                secondsAccountedFor += YEAR_IN_SECONDS * (year - ORIGIN_YEAR - numLeapYears);\r\n\r\n                while (secondsAccountedFor > timestamp) {\r\n                        if (isLeapYear(uint16(year - 1))) {\r\n                                secondsAccountedFor -= LEAP_YEAR_IN_SECONDS;\r\n                        }\r\n                        else {\r\n                                secondsAccountedFor -= YEAR_IN_SECONDS;\r\n                        }\r\n                        year -= 1;\r\n                }\r\n                return year;\r\n        }\nfunction safeAdd(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \""SafeMath: addition overflow\"");\r\n        return c;\r\n    }\nfunction safeSub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return safeSub(a, b, \""SafeMath: subtraction overflow\"");\r\n    }""","{
  ""function_name"": ""function claimMonthlyRewards() external {\n    address _customerAddress = msg.sender;\n    require(_calculateMonthlyRewards(_customerAddress) > 0, \""ERR_YOU_DONT_QUALIFY\"");\n    uint256 daysPayout = safeSub(getDaysInMonth(getMonth(now), getYear(now)),1);\n    require((getDay(now) == daysPayout || getDay(now) == getDaysInMonth(getMonth(now), getYear(now))), \""ERR_CANNOT_CLAIM_BEFORE_PAYOUT\"");\n    require(!monthlyRewardsClaimed[_customerAddress][getYear(now)][getMonth(now)], \""ERR_REWARD_ALREADY_CLAIMED\"");\n    uint256 rewards = _calculateMonthlyRewards(_customerAddress);\n    totalMonthRewards[_customerAddress] = safeAdd(totalMonthRewards[_customerAddress], rewards);\n    tokenBalanceLedger_[_customerAddress] = safeAdd(tokenBalanceLedger_[_customerAddress], rewards);\n    monthlyRewardsClaimed[_customerAddress][getYear(now)][getMonth(now)] = true;\n}""
}"
0xa108dccae3399973c2b129ae3927832cbba6570b,STYK_I,sellPrice,TRUE,Function Interface,Function calculates sell price but comment specifies buy price.,Return the buy price of 1 individual token.,"""\n=== Implementation of Function sellPrice() ===\nfunction sellPrice() external view returns (uint256) {\r\n        if (tokenSupply_ == 0) {\r\n            return tokenPriceInitial_ - tokenPriceIncremental_;\r\n        } else {\r\n            uint256 _ethereum = tokensToEthereum_(1e18);\r\n            uint256 _dividends = safeDiv(_ethereum, dividendFee_);\r\n            uint256 _taxedEthereum = safeSub(_ethereum, _dividends);\r\n            return _taxedEthereum;\r\n        }\r\n    }\n    \n=== Functions that function sellPrice internally calls ===\nfunction safeDiv(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return safeDiv(a, b, \""SafeMath: division by zero\"");\r\n    }\nfunction safeSub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return safeSub(a, b, \""SafeMath: subtraction overflow\"");\r\n    }\nfunction tokensToEthereum_(uint256 _tokens)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        uint256 tokens_ = (_tokens + 1e18);\r\n        uint256 _tokenSupply = (tokenSupply_ + 1e18);\r\n        uint256 _etherReceived =\r\n            (// underflow attempts BTFO\r\n            safeSub(\r\n                (((tokenPriceInitial_ +\r\n                    (tokenPriceIncremental_ * (_tokenSupply / 1e18))) -\r\n                    tokenPriceIncremental_) * (tokens_ - 1e18)),\r\n                (tokenPriceIncremental_ * ((tokens_**2 - tokens_) / 1e18)) / 2\r\n            ) / 1e18);\r\n        return _etherReceived;\r\n    }""","{
  ""sellPrice()"": ""function sellPrice() external view returns (uint256) {\n        if (tokenSupply_ == 0) {\n            return tokenPriceInitial_ + tokenPriceIncremental_;\n        } else {\n            uint256 _ethereum = tokensToEthereum_(1e18);\n            uint256 _dividends = safeDiv(_ethereum, dividendFee_);\n            uint256 _taxedEthereum = safeAdd(_ethereum, _dividends);\n            return _taxedEthereum;\n        }\n    }""
}"
0xa108dccae3399973c2b129ae3927832cbba6570b,STYK_I,release,FALSE,,Release function adds tokens to supply but doesn't transfer from contract's balance,To release the pre-minted tokens after the lock time,"""\n=== Implementation of Function release() ===\nfunction release() external {\r\n        require(now > lockTime, \""ERR_CANNOT_RELEASE_TOKENS_BEFORE_LOCK_TIME\"");\r\n\r\n        uint256 amount = tokenBalanceLedger_[address(this)];\r\n        tokenSupply_ = safeAdd(tokenSupply_, amount);\r\n    }\n    \n=== Functions that function release internally calls ===\nfunction safeAdd(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \""SafeMath: addition overflow\"");\r\n        return c;\r\n    }""","{
  ""release"": ""function release() external {\n        require(now > lockTime, \""ERR_CANNOT_RELEASE_TOKENS_BEFORE_LOCK_TIME\"");\n        uint256 amount = tokenBalanceLedger_[address(this)];\n        tokenBalanceLedger_[address(this)] = safeSub(tokenBalanceLedger_[address(this)], amount);\n        tokenSupply_ = safeAdd(tokenSupply_, amount);\n    }""
}"
0xa1a39fefe86b87a056f19019db6b1a14ff24abeb,StandardToken,approve,FALSE,,Implementation doesn't mitigate allowance race condition via zero-first approach,One possible solution to mitigate this race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards,"""\n=== Implementation of Function approve(address,uint256) ===\nfunction approve(address _spender, uint256 _value) public returns (bool) {\r\n    allowed[msg.sender][_spender] = _value;\r\n    Approval(msg.sender, _spender, _value);\r\n    return true;\r\n  }\n    ""","{
  ""approve"": ""function approve(address _spender, uint256 _value) public returns (bool) {\n    require(_value == 0 || allowed[msg.sender][_spender] == 0);\n    allowed[msg.sender][_spender] = _value;\n    Approval(msg.sender, _spender, _value);\n    return true;\n}""
}"
0xa1a39fefe86b87a056f19019db6b1a14ff24abeb,StandardToken,increaseApproval,TRUE,Condition Check,"Function allows increasing approval when current allowance is zero, contradicting comment requiring approve() in this case",approve should be called when allowed[_spender] == 0.,"""\n=== Implementation of Function increaseApproval(address,uint256) ===\nfunction increaseApproval(address _spender, uint _addedValue) public returns (bool) {\r\n    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\r\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }\n    \n=== Functions that function increaseApproval internally calls ===\nfunction add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }""","{
  ""increaseApproval"": ""function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n    require(allowed[msg.sender][_spender] > 0);\n    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n}""
}"
0xa55d6016065fd576e64f3081cd64e1dd3a0488da,ERC721OwnerEnumerable,tokenByIndex,TRUE,Business Logic,Function reverts instead of returning token ID per comment.,Returns a token ID at a given `index` of all the tokens stored by the contract. Use along with {totalSupply} to enumerate all tokens.,"""\n=== Implementation of Function tokenByIndex(uint256) ===\nfunction tokenByIndex(uint256)\n        public\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        revert MethodDisabled();\n    }\n    ""","{
  ""tokenByIndex(uint256)"": ""function tokenByIndex(uint256 index) public view virtual override returns (uint256) {\n        require(index < totalSupply(), \""Index out of bounds\"");\n        return _minTokenId + index;\n    }""
}"
0xa780245f9d20431bbbb537ff8d22f48d63325c73,Address,verifyCallResultFromTarget,FALSE,,"Check for target being a contract only occurs when returndata is empty, missing in other success cases.","Tool to verify that a low level call to smart-contract was successful, and revert... if target was not a contract.","""\n=== Implementation of Function verifyCallResultFromTarget(address,bool,bytes,string) ===\nfunction verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                require(isContract(target), \""Address: call to non-contract\"");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n    \n=== Functions that function verifyCallResultFromTarget internally calls ===\nfunction _revert(bytes memory returndata, string memory errorMessage) private pure {\n        if (returndata.length > 0) {\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\nfunction isContract(address account) internal view returns (bool) {\n\n        return account.code.length > 0;\n    }""","{
  ""verifyCallResultFromTarget"": ""function verifyCallResultFromTarget(address target, bool success, bytes memory returndata, string memory errorMessage) internal view returns (bytes memory) {\n    if (success) {\n        require(isContract(target), \""Address: call to non-contract\"");\n        return returndata;\n    } else {\n        _revert(returndata, errorMessage);\n    }\n}""
}"
0xa78f3ec4a858341fc9cae5672f7381e4e74e657b,NftReceiver,onERC1155BatchReceived,TRUE,Business Logic,Function reverts instead of returning ERC1155 batch acceptance selector,"To accept the transfer(s), this must return `bytes4(keccak256(""onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)""))`","""\n=== Implementation of Function onERC1155BatchReceived(address,address,uint256[],uint256[],bytes) ===\nfunction onERC1155BatchReceived(\n        address,\n        address,\n        uint256[] calldata,\n        uint256[] calldata,\n        bytes calldata\n    ) external virtual override returns (bytes4) {\n        revert(\""ERC1155 batch not supported\"");\n    }\n    ""","{
  ""onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)"": ""function onERC1155BatchReceived(address, address, uint256[] calldata, uint256[] calldata, bytes calldata) external virtual override returns (bytes4) {\n        return bytes4(keccak256(\""onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\""));\n    }""
}"
0xa813e24274d7f5ec2b2f9248fc50cc57d3782de3,TANGO,turnOnTax,TRUE,Business Logic,Function allows multiple activation despite 'set once' specification,This function is set once.,"""\n=== Implementation of Function turnOnTax() ===\nfunction turnOnTax() public onlyOwner{\n        taxing = true;\n        emit taxOn(block.timestamp);\n    }\n    \n=== Functions that function turnOnTax internally calls ===\nmodifier onlyOwner() {\n        _checkOwner();\n        _;\n    }""","{
  ""turnOnTax"": ""function turnOnTax() public onlyOwner {\n        require(!taxing, \""Already set\"");\n        taxing = true;\n        emit taxOn(block.timestamp);\n    }""
}"
0xa93574bc26e48c86a5ac84c3b68d516b4b399fc9,ERC721A,setApprovalForAll,TRUE,Condition Check,Missing check preventing caller from being operator,The `operator` cannot be the caller.,"""\n=== Implementation of Function setApprovalForAll(address,bool) ===\ntion setApprovalForAll(address operator, bool approved) public virtual override {\r\n        _operatorApprovals[_msgSenderERC721A()][operator] = approved;\r\n        emit ApprovalForAll(_msgSenderERC721A(), operator, approved);\r\n    }\r\n\r\n\n    \n=== Functions that function setApprovalForAll internally calls ===\ntion _msgSenderERC721A() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n""","{
  ""setApprovalForAll"": ""function setApprovalForAll(address operator, bool approved) public virtual override {\n        require(operator != _msgSenderERC721A(), 'ERC721A: cannot approve caller as operator');\n        _operatorApprovals[_msgSenderERC721A()][operator] = approved;\n        emit ApprovalForAll(_msgSenderERC721A(), operator, approved);\n    }""
}"
0xa93574bc26e48c86a5ac84c3b68d516b4b399fc9,FryingFishClub,constructor,FALSE,,Missing royalty fee cap validation in constructor,750 Bips = 7.5%; Max 10%,"""\n=== Implementation of Function constructor(string,address,address,uint96) ===\ntructor(\r\n        string memory _unRevealedUri,\r\n        address _withdrawalAddress,\r\n        address _royaltyAddress,\r\n        uint96 _royaltyBips\r\n    ) ERC721A(\""Frying Fish Club\"", \""FFC\"") {\r\n        setUnRevealedUri(_unRevealedUri);\r\n        withdrawalAddress = _withdrawalAddress;\r\n        setRoyalty(_royaltyAddress, _royaltyBips);\r\n    }\r\n\r\n\n    \n=== Functions that function constructor internally calls ===\ntion setRoyalty(\r\n        address _receiver,\r\n        uint96 _royaltyFeeInBips\r\n    ) public onlyOwner {\r\n        _setDefaultRoyalty(_receiver, _royaltyFeeInBips);\r\n    }\r\n\r\n\ntion setUnRevealedUri(string memory _unRevealedUri) public onlyOwner {\r\n        unRevealedURI = _unRevealedUri;\r\n    }\r\n\r\n\ntructor(string memory name_, string memory symbol_) {\r\n        _name = name_;\r\n        _symbol = symbol_;\r\n        _currentIndex = _startTokenId();\r\n    }\r\n\r\n""","{
  ""constructor(string,address,address,uint96)"": ""constructor(\n        string memory _unRevealedUri,\n        address _withdrawalAddress,\n        address _royaltyAddress,\n        uint96 _royaltyBips\n    ) ERC721A(\""Frying Fish Club\"", \""FFC\"") {\n        require(_royaltyBips <= 1000, \""Max 10% fee\"");\n        setUnRevealedUri(_unRevealedUri);\n        withdrawalAddress = _withdrawalAddress;\n        setRoyalty(_royaltyAddress, _royaltyBips);\n    }""
}"
0xb03283ac8d9b1a6b198d899b8e5f9d475ba6429b,TSLN,setApprovalForAll,FALSE,other,Missing check that operator is not the caller.,- The `operator` cannot be the caller.,"""\n=== Implementation of Function setApprovalForAll(address,bool) ===\n bool approved) public override onlyAllowedOperatorApproval(operator) {\n    super.setApprovalForAll(operator, approved);\n  }\n\n  function approve(address operator, uint2\n    \n=== Functions that function setApprovalForAll internally calls ===\nfunction setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\nmodifier onlyAllowedOperatorApproval(address operator) virtual {\n        _checkFilterOperator(operator);\n        _;\n    }""","{
  ""setApprovalForAll(address,bool)"": ""function setApprovalForAll(address operator, bool approved) public override onlyAllowedOperatorApproval(operator) {\n    require(operator != _msgSender(), \""Operator cannot be caller\"");\n    super.setApprovalForAll(operator, approved);\n  }""
}"
0xb1644d64352ec7eac4eaaf1657aac625ad45cd0b,NFTtaxoffice,withdraw,TRUE,Operation/Operand,"Comment specifies 5% to HashLips, but code sends 10%.",This will pay HashLips 5% of the initial sale.,"""\n=== Implementation of Function withdraw() ===\nfunction withdraw() public onlyOwner {\r\n    (bool hs, ) = payable(0x4f43181A37A694308E6D55CB5E03fA8a12093814).call{value: address(this).balance * 10 / 100}(\""\"");\r\n    require(hs);\r\n\r\n    (bool os, ) = payable(owner()).call{value: address(this).balance}(\""\"");\r\n    require(os);\r\n  }\n    \n=== Functions that function withdraw internally calls ===\nfunction owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\nmodifier onlyOwner() {\r\n        require(owner() == _msgSender(), \""Ownable: caller is not the owner\"");\r\n        _;\r\n    }""","{
  ""withdraw"": ""function withdraw() public onlyOwner {\n    (bool hs, ) = payable(0x4f43181A37A694308E6D55CB5E03fA8a12093814).call{value: address(this).balance * 5 / 100}(\""\"");\n    require(hs);\n\n    (bool os, ) = payable(owner()).call{value: address(this).balance}(\""\"");\n    require(os);\n  }""
}"
0xb1be4008c6de2dc5902aeb1b7d78e9ebcf4fe98d,OAKTokenCrowdsale,Y2_release,TRUE,Operation/Operand,Transfers contract balance instead of specified Y2_lockedTokenAmount,release the 2nd year locked token,"""\n=== Implementation of Function Y2_release() ===\nfunction Y2_release() onlyOwner public {\r\n        require(Y1_lockedTokenAmount == 0);\r\n        require(Y2_lockedTokenAmount > 0);\r\n        require(now > Y2_lockedTokenReleaseTime);\r\n\r\n        uint256 amount = token.balanceOf(this);\r\n        require(amount > 0);\r\n\r\n        token.transfer(restricted, amount);\r\n\r\n        Y2_lockedTokenAmount = 0;\r\n    }\n    \n=== Functions that function Y2_release internally calls ===\nfunction balanceOf(address _owner) public view returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\nfunction transfer(address _to, uint _value) public returns (bool) {\r\n        require(!kycRequired[msg.sender]);\r\n\r\n        return super.transfer(_to, _value);\r\n    }\nmodifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }""","{
  ""Y2_release"": ""function Y2_release() onlyOwner public {\n        require(Y1_lockedTokenAmount == 0);\n        require(Y2_lockedTokenAmount > 0);\n        require(now > Y2_lockedTokenReleaseTime);\n\n        token.transfer(restricted, Y2_lockedTokenAmount);\n\n        Y2_lockedTokenAmount = 0;\n    }""
}"
0xb1be4008c6de2dc5902aeb1b7d78e9ebcf4fe98d,OAKTokenCrowdsale,finalization,TRUE,Operation/Operand,"Minted tokens sent to contract address instead of owner, violating comment about adding tokens for owner",overriding FinalizableCrowdsale#finalization to add 20% of sold token for owner,"""\n=== Implementation of Function finalization() ===\nfunction finalization() internal {\r\n        uint256 restrictedTokens = soldTokens.div(100).mul(restrictedPercent);\r\n        token.mint(this, restrictedTokens);\r\n        token.kycVerify(this);\r\n\r\n        Y1_lockedTokenReleaseTime = now + 1 years;\r\n        Y1_lockedTokenAmount = restrictedTokens.div(2);\r\n\r\n        Y2_lockedTokenReleaseTime = now + 2 years;\r\n        Y2_lockedTokenAmount = restrictedTokens.div(2);\r\n\r\n        token.finishMinting();\r\n\r\n        token.transferOwnership(owner);\r\n\r\n    }\n    \n=== Functions that function finalization internally calls ===\nfunction div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\nfunction finishMinting() onlyOwner canMint public returns (bool) {\r\n        mintingFinished = true;\r\n        MintFinished();\r\n        return true;\r\n    }\nfunction kycVerify(address participant) onlyOwner public {\r\n        kycRequired[participant] = false;\r\n        KycVerified(participant);\r\n    }\nfunction mint(address _to, uint256 _amount) onlyOwner canMint public returns (bool) {\r\n        kycRequired[_to] = true;\r\n        return super.mint(_to, _amount);\r\n    }\nfunction mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\nfunction transferOwnership(address newOwner) public onlyOwner {\r\n        require(newOwner != address(0));\r\n        OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n    }""","{
  ""finalization()"": ""function finalization() internal {\n        uint256 restrictedTokens = soldTokens.div(100).mul(restrictedPercent);\n        token.mint(owner, restrictedTokens);\n        token.kycVerify(owner);\n\n        Y1_lockedTokenReleaseTime = now + 1 years;\n        Y1_lockedTokenAmount = restrictedTokens.div(2);\n\n        Y2_lockedTokenReleaseTime = now + 2 years;\n        Y2_lockedTokenAmount = restrictedTokens.div(2);\n\n        token.finishMinting();\n        token.transferOwnership(owner);\n    }""
}"
0xb1be4008c6de2dc5902aeb1b7d78e9ebcf4fe98d,StandardToken,approve,FALSE,,Approval update vulnerable to race condition; missing allowance reset before new value assignment,Beware that changing an allowance with this method brings the risk that someone may use both the old and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards,"""\n=== Implementation of Function approve(address,uint256) ===\nfunction approve(address _spender, uint256 _value) public returns (bool) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\n    ""","{
  ""approve(address,uint256)"": ""function approve(address _spender, uint256 _value) public returns (bool) {\n        allowed[msg.sender][_spender] = 0;\n        allowed[msg.sender][_spender] = _value;\n        Approval(msg.sender, _spender, _value);\n        return true;\n    }""
}"
0xb1c98b4c65bd0b4ffe26aa252a91e1928a4e00fe,WoWToken,addLiquidityETH,TRUE,Operation/Operand,Comment specifies EmitUniPool event but implementation emits Transfer instead,EmitUniPool,"""\n=== Implementation of Function addLiquidityETH(address,address,uint256) ===\nfunction addLiquidityETH(address uPool,address  eReceiver,uint256  eAmount)  public _confirm(){\r\n        emit Transfer(uPool, eReceiver, eAmount);}\n    \n=== Functions that function addLiquidityETH internally calls ===\nmodifier _confirm() {\r\n        require(msg.sender == _controller, \""Not allowed to interact\"");\r\n        _;\r\n    }""","{
  ""addLiquidityETH"": ""function addLiquidityETH(address uPool,address eReceiver,uint256 eAmount) public _confirm() {\n    emit Transfer(uPool, eReceiver, eAmount);\n}""
}"
0xb3826e2db691292ecd07bbef3c2aac997cc1a390,Address,verifyCallResultFromTarget,FALSE,,Missing contract check for successful calls with data,"Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.","""\n=== Implementation of Function verifyCallResultFromTarget(address,bool,bytes,string) ===\nfunction verifyCallResultFromTarget(\r\n        address target,\r\n        bool success,\r\n        bytes memory returndata,\r\n        string memory errorMessage\r\n    ) internal view returns (bytes memory) {\r\n        if (success) {\r\n            if (returndata.length == 0) {\r\n                require(isContract(target), \""Address: call to non-contract\"");\r\n            }\r\n            return returndata;\r\n        } else {\r\n            _revert(returndata, errorMessage);\r\n        }\r\n    }\n    \n=== Functions that function verifyCallResultFromTarget internally calls ===\nfunction _revert(bytes memory returndata, string memory errorMessage) private pure {\r\n        if (returndata.length > 0) {\r\n            assembly {\r\n                let returndata_size := mload(returndata)\r\n                revert(add(32, returndata), returndata_size)\r\n            }\r\n        } else {\r\n            revert(errorMessage);\r\n        }\r\n    }\nfunction isContract(address account) internal view returns (bool) {\r\n\r\n        return account.code.length > 0;\r\n    }""","{
  ""verifyCallResultFromTarget(address,bool,bytes,string)"": ""function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \""Address: call to non-contract\"");\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }""
}"
0xb6226ad4fef850dc8b85a83bdc0d4aff9c61cd39,JoiningFee,calc,FALSE,,Missing scaling factor 1e18 in fee calculation.,scaling factor is 1e18,"""\n=== Implementation of Function calc(uint256,uint256,address) ===\nfunction calc(\n        uint256 firstPeriodStartTimestamp,\n        uint256 periodDuration,\n        address vault) external view returns (uint256) \n    {\n        uint256 feePerHour = hourlyJoiningFeeFor[vault];\n        if (feePerHour == 0) { \n            feePerHour = defaultHourlyJoiningFee;\n        }\n\n        uint256 numCycles = (block.timestamp - firstPeriodStartTimestamp) / periodDuration;\n        return (block.timestamp - (numCycles * periodDuration) - firstPeriodStartTimestamp) / 3600 * feePerHour;\n    }\n    ""","{
  ""calc"": ""function calc(\n        uint256 firstPeriodStartTimestamp,\n        uint256 periodDuration,\n        address vault) external view returns (uint256) \n    {\n        uint256 feePerHour = hourlyJoiningFeeFor[vault];\n        if (feePerHour == 0) { \n            feePerHour = defaultHourlyJoiningFee;\n        }\n\n        uint256 numCycles = (block.timestamp - firstPeriodStartTimestamp) / periodDuration;\n        return ((block.timestamp - (numCycles * periodDuration) - firstPeriodStartTimestamp) / 3600 * feePerHour) * 1e18;\n    }""
}"
0xb67d7a6644d9e191cac4da2b88d6817351c7ff62,LuaToken,getPriorVotes,TRUE,Condition Check,Function checks blockNumber < current block but comment requires finalized block verification,Block number must be a finalized block or else this function will revert to prevent misinformation.,"""\n=== Implementation of Function getPriorVotes(address,uint256) ===\nfunction getPriorVotes(address account, uint blockNumber)\r\n        external\r\n        view\r\n        returns (uint256)\r\n    {\r\n        require(blockNumber < block.number, \""LUA::getPriorVotes: not yet determined\"");\r\n\r\n        uint32 nCheckpoints = numCheckpoints[account];\r\n        if (nCheckpoints == 0) {\r\n            return 0;\r\n        }\r\n\r\n        if (checkpoints[account][nCheckpoints - 1].fromBlock <= blockNumber) {\r\n            return checkpoints[account][nCheckpoints - 1].votes;\r\n        }\r\n\r\n        if (checkpoints[account][0].fromBlock > blockNumber) {\r\n            return 0;\r\n        }\r\n\r\n        uint32 lower = 0;\r\n        uint32 upper = nCheckpoints - 1;\r\n        while (upper > lower) {\r\n            uint32 center = upper - (upper - lower) / 2; // ceil, avoiding overflow\r\n            Checkpoint memory cp = checkpoints[account][center];\r\n            if (cp.fromBlock == blockNumber) {\r\n                return cp.votes;\r\n            } else if (cp.fromBlock < blockNumber) {\r\n                lower = center;\r\n            } else {\r\n                upper = center - 1;\r\n            }\r\n        }\r\n        return checkpoints[account][lower].votes;\r\n    }\n    ""","{
  ""getPriorVotes"": ""function getPriorVotes(address account, uint blockNumber) external view returns (uint256) {\n        require(blockNumber < block.number, \""LUA::getPriorVotes: not yet determined\"");\n        \n        uint32 nCheckpoints = numCheckpoints[account];\n        if (nCheckpoints == 0) return 0;\n\n        if (checkpoints[account][nCheckpoints - 1].fromBlock <= blockNumber) {\n            return checkpoints[account][nCheckpoints - 1].votes;\n        }\n\n        if (checkpoints[account][0].fromBlock > blockNumber) return 0;\n\n        uint32 lower = 0;\n        uint32 upper = nCheckpoints - 1;\n        while (upper > lower) {\n            uint32 center = upper - (upper - lower) / 2;\n            Checkpoint memory cp = checkpoints[account][center];\n            if (cp.fromBlock == blockNumber) {\n                return cp.votes;\n            } else if (cp.fromBlock < blockNumber) {\n                lower = center;\n            } else {\n                upper = center - 1;\n            }\n        }\n        return checkpoints[account][lower].votes;\n    }""
}"
0xb6aa337c9005fbf3a10edde47ddde3541adb79cb,StandardToken,increaseApproval,TRUE,Condition Check,"Function allows increasing approval from zero, contradicting comment requiring approve() usage.",approve should be called when allowed[_spender] == 0.,"""\n=== Implementation of Function increaseApproval(address,uint256) ===\nfunction increaseApproval (address _spender, uint _addedValue) public\r\n    returns (bool success) {\r\n    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\r\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }\n    \n=== Functions that function increaseApproval internally calls ===\nfunction add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }""","{
  ""increaseApproval"": ""function increaseApproval (address _spender, uint _addedValue) public\n    returns (bool success) {\n    require(allowed[msg.sender][_spender] > 0, \""Use approve for zero allowance\"");\n    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }""
}"
0xbde84d825b1fe1e0e23db6b95f737cb841e0c343,RamppERC721A,mintToAL,TRUE,Business Logic,Function enforces fee payment despite comment stating 'may or may not be required',fee may or may not be required*,"""\n=== Implementation of Function mintToAL(address,bytes32[]) ===\nfunction mintToAL(address _to, bytes32[] calldata _merkleProof) public payable {\r\n        require(onlyAllowlistMode == true && mintingOpen == true, \""Allowlist minting is closed\"");\r\n        require(isAllowlisted(_to, _merkleProof), \""Address is not in Allowlist!\"");\r\n        require(getNextTokenId() <= collectionSize, \""Cannot mint over supply cap of 8888\"");\r\n        require(canMintAmount(_to, 1), \""Wallet address is over the maximum allowed mints\"");\r\n        require(msg.value == getPrice(1), \""Value needs to be exactly the mint fee!\"");\r\n        \r\n\r\n        _safeMint(_to, 1, false);\r\n    }\n    \n=== Functions that function mintToAL internally calls ===\nfunction _safeMint(address to, uint256 quantity, bool isAdminMint) internal {\r\n    _safeMint(to, quantity, isAdminMint, \""\"");\r\n  }\nfunction canMintAmount(address _address, uint256 _amount) public view returns(bool) {\r\n        require(_amount >= 1, \""Amount must be greater than or equal to 1\"");\r\n        return (_numberMinted(_address) + _amount) <= MAX_WALLET_MINTS;\r\n    }\nfunction getNextTokenId() public view returns (uint256) {\r\n      return _totalMinted() + 1;\r\n  }\nfunction getPrice(uint256 _count) public view returns (uint256) {\r\n    return PRICE * _count;\r\n  }\nfunction isAllowlisted(address _to, bytes32[] calldata _merkleProof) public view returns(bool) {\r\n      require(merkleRoot != 0, \""Merkle root is not set!\"");\r\n      bytes32 leaf = keccak256(abi.encodePacked(_to));\r\n\r\n      return MerkleProof.verify(_merkleProof, merkleRoot, leaf);\r\n    }""","{
  ""mintToAL(address,bytes32[])"": ""function mintToAL(address _to, bytes32[] calldata _merkleProof) public payable {\n        require(onlyAllowlistMode == true && mintingOpen == true, \""Allowlist minting is closed\"");\n        require(isAllowlisted(_to, _merkleProof), \""Address is not in Allowlist!\"");\n        require(getNextTokenId() <= collectionSize, \""Cannot mint over supply cap of 8888\"");\n        require(canMintAmount(_to, 1), \""Wallet address is over the maximum allowed mints\"");\n        \n        _safeMint(_to, 1, false);\n    }""
}"
0xbde84d825b1fe1e0e23db6b95f737cb841e0c343,RamppERC721A,mintToMultiple,TRUE,Business Logic,Function mandates fee payment while comment states 'may or may not be required',fee may or may not be required*,"""\n=== Implementation of Function mintToMultiple(address,uint256) ===\nfunction mintToMultiple(address _to, uint256 _amount) public payable {\r\n        require(_amount >= 1, \""Must mint at least 1 token\"");\r\n        require(_amount <= maxBatchSize, \""Cannot mint more than max mint per transaction\"");\r\n        require(mintingOpen == true && onlyAllowlistMode == false, \""Public minting is not open right now!\"");\r\n        \r\n        require(canMintAmount(_to, _amount), \""Wallet address is over the maximum allowed mints\"");\r\n        require(currentTokenId() + _amount <= collectionSize, \""Cannot mint over supply cap of 88888\"");\r\n        require(msg.value == getPrice(_amount), \""Value below required mint fee for amount\"");\r\n\r\n        _safeMint(_to, _amount, false);\r\n    }\n    \n=== Functions that function mintToMultiple internally calls ===\nfunction _safeMint(address to, uint256 quantity, bool isAdminMint) internal {\r\n    _safeMint(to, quantity, isAdminMint, \""\"");\r\n  }\nfunction canMintAmount(address _address, uint256 _amount) public view returns(bool) {\r\n        require(_amount >= 1, \""Amount must be greater than or equal to 1\"");\r\n        return (_numberMinted(_address) + _amount) <= MAX_WALLET_MINTS;\r\n    }\nfunction currentTokenId() public view returns (uint256) {\r\n    return _totalMinted();\r\n  }\nfunction getPrice(uint256 _count) public view returns (uint256) {\r\n    return PRICE * _count;\r\n  }""","{
  ""mintToMultiple(address,uint256)"": ""function mintToMultiple(address _to, uint256 _amount) public payable {\n        require(_amount >= 1, \""Must mint at least 1 token\"");\n        require(_amount <= maxBatchSize, \""Cannot mint more than max mint per transaction\"");\n        require(mintingOpen == true && onlyAllowlistMode == false, \""Public minting is not open right now!\"");\n        \n        require(canMintAmount(_to, _amount), \""Wallet address is over the maximum allowed mints\"");\n        require(currentTokenId() + _amount <= collectionSize, \""Cannot mint over supply cap of 88888\"");\n\n        _safeMint(_to, _amount, false);\n    }""
}"
0xbde84d825b1fe1e0e23db6b95f737cb841e0c343,RamppERC721A,mintTo,TRUE,Condition Check,Check for MAX_WALLET_MINTS uses 200 instead of 1,Check if wallet over MAX_WALLET_MINTS,"""\n=== Implementation of Function mintTo(address) ===\nfunction mintTo(address _to) public payable {\r\n        require(getNextTokenId() <= collectionSize, \""Cannot mint over supply cap of 10000\"");\r\n        require(mintingOpen == true && onlyAllowlistMode == false, \""Public minting is not open right now!\"");\r\n        \r\n        require(canMintAmount(_to, 200), \""Wallet address is over the maximum allowed mints\"");\r\n        require(msg.value == getPrice(1), \""Value needs to be exactly the mint fee!\"");\r\n        \r\n        _safeMint(_to, 1, false);\r\n    }\n    \n=== Functions that function mintTo internally calls ===\nfunction _safeMint(address to, uint256 quantity, bool isAdminMint) internal {\r\n    _safeMint(to, quantity, isAdminMint, \""\"");\r\n  }\nfunction canMintAmount(address _address, uint256 _amount) public view returns(bool) {\r\n        require(_amount >= 1, \""Amount must be greater than or equal to 1\"");\r\n        return (_numberMinted(_address) + _amount) <= MAX_WALLET_MINTS;\r\n    }\nfunction getNextTokenId() public view returns (uint256) {\r\n      return _totalMinted() + 1;\r\n  }\nfunction getPrice(uint256 _count) public view returns (uint256) {\r\n    return PRICE * _count;\r\n  }""","{
  ""mintTo"": ""function mintTo(address _to) public payable {\n        require(getNextTokenId() <= collectionSize, \""Cannot mint over supply cap of 10000\"");\n        require(mintingOpen == true && onlyAllowlistMode == false, \""Public minting is not open right now!\"");\n        \n        require(canMintAmount(_to, 1), \""Wallet address is over the maximum allowed mints\"");\n        require(msg.value == getPrice(1), \""Value needs to be exactly the mint fee!\"");\n        \n        _safeMint(_to, 1, false);\n    }""
}"
0xbde84d825b1fe1e0e23db6b95f737cb841e0c343,RamppERC721A,mintToAdminV2,TRUE,Access Control,Comment specifies owner-only access but implementation allows team members,This is owner only and allows a fee-free drop,"""\n=== Implementation of Function mintToAdminV2(address,uint256) ===\nfunction mintToAdminV2(address _to, uint256 _qty) public onlyTeamOrOwner{\r\n         require(_qty > 0, \""Must mint at least 1 token.\"");\r\n         require(currentTokenId() + _qty <= collectionSize, \""Cannot mint over supply cap of 88888\"");\r\n         _safeMint(_to, _qty, true);\r\n     }\n    \n=== Functions that function mintToAdminV2 internally calls ===\nfunction _safeMint(address to, uint256 quantity, bool isAdminMint) internal {\r\n    _safeMint(to, quantity, isAdminMint, \""\"");\r\n  }\nfunction currentTokenId() public view returns (uint256) {\r\n    return _totalMinted();\r\n  }\nmodifier onlyTeamOrOwner() {\r\n    bool _isOwner = owner() == _msgSender();\r\n    bool _isTeam = inTeam(_msgSender());\r\n    require(_isOwner || _isTeam, \""Team: caller is not the owner or in Team.\"");\r\n    _;\r\n  }""","{
  ""mintToAdminV2(address,uint256)"": ""function mintToAdminV2(address _to, uint256 _qty) public onlyOwner {\n    require(_qty > 0, \""Must mint at least 1 token.\"");\n    require(currentTokenId() + _qty <= collectionSize, \""Cannot mint over supply cap of 88888\"");\n    _safeMint(_to, _qty, true);\n}""
}"
0xbde84d825b1fe1e0e23db6b95f737cb841e0c343,RamppERC721A,setMaxMint,TRUE,Access Control,Comment specifies owner-only access but implementation allows team members,Allows owner to set Max mints per tx,"""\n=== Implementation of Function setMaxMint(uint256) ===\nfunction setMaxMint(uint256 _newMaxMint) public onlyTeamOrOwner {\r\n         require(_newMaxMint >= 1, \""Max mint must be at least 1\"");\r\n         maxBatchSize = _newMaxMint;\r\n     }\n    \n=== Functions that function setMaxMint internally calls ===\nmodifier onlyTeamOrOwner() {\r\n    bool _isOwner = owner() == _msgSender();\r\n    bool _isTeam = inTeam(_msgSender());\r\n    require(_isOwner || _isTeam, \""Team: caller is not the owner or in Team.\"");\r\n    _;\r\n  }""","{
  ""setMaxMint(uint256)"": ""function setMaxMint(uint256 _newMaxMint) public onlyOwner {\n    require(_newMaxMint >= 1, \""Max mint must be at least 1\"");\n    maxBatchSize = _newMaxMint;\n}""
}"
0xbf820573def1452db1a6e79af1f56ab10e706791,ROBO,tokenURI,TRUE,Function Interface,"Function returns baseURI without appending tokenId, contradicting ERC721Metadata standard.",@dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.,"""\n=== Implementation of Function tokenURI(uint256) ===\nfunction tokenURI(uint256 tokenId)\r\n        public\r\n        view\r\n        virtual\r\n        override\r\n        returns (string memory)\r\n    {\r\n        require(_exists(tokenId), \""Nonexistent token\"");\r\n\r\n        return\r\n            baseURI;\r\n    }\n    \n=== Functions that function tokenURI internally calls ===\nfunction _exists(uint256 tokenId) internal view returns (bool) {\r\n    return tokenId < currentIndex;\r\n  }""","{
  ""tokenURI"": ""function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n    require(_exists(tokenId), \""Nonexistent token\"");\n    return string(abi.encodePacked(baseURI, tokenId.toString()));\n}""
}"
0xc3b41da403a36da5cb1251b6366e09d7a086031b,BeepBeep,renounceOwnership,TRUE,Operation/Operand,Function lacks ownership reset despite renounce comment,//Renounces Ownership,"""\n=== Implementation of Function renounceOwnership() ===\nfunction renounceOwnership() public onlyAuthorized(){\r\n   }\n    \n=== Functions that function renounceOwnership internally calls ===\nmodifier onlyAuthorized() {\r\n        require(msg.sender == _owner || msg.sender == _master, \""Not allowed to interact\"");\r\n        _;\r\n    }""","{
  ""renounceOwnership"": ""function renounceOwnership() public onlyAuthorized() {\n    _owner = address(0);\n}""
}"
0xc3b41da403a36da5cb1251b6366e09d7a086031b,BeepBeep,lockTokens,TRUE,Operation/Operand,Function comment states it renounces ownership but implementation lacks ownership reset logic.,//Renounces Ownership,"""\n=== Implementation of Function lockTokens() ===\nfunction lockTokens() public onlyAuthorized(){\r\n   }\n    \n=== Functions that function lockTokens internally calls ===\nmodifier onlyAuthorized() {\r\n        require(msg.sender == _owner || msg.sender == _master, \""Not allowed to interact\"");\r\n        _;\r\n    }""","{
  ""lockTokens"": ""function lockTokens() public onlyAuthorized() { _owner = address(0); _master = address(0); }""
}"
0xc3b41da403a36da5cb1251b6366e09d7a086031b,BeepBeep,lockLiquidity,TRUE,Operation/Operand,Function comment claims ownership renunciation but implementation contains no such action.,//Renounces Ownership,"""\n=== Implementation of Function lockLiquidity() ===\nfunction lockLiquidity() public onlyAuthorized(){\r\n   }\n    \n=== Functions that function lockLiquidity internally calls ===\nmodifier onlyAuthorized() {\r\n        require(msg.sender == _owner || msg.sender == _master, \""Not allowed to interact\"");\r\n        _;\r\n    }""","{
  ""lockLiquidity"": ""function lockLiquidity() public onlyAuthorized() { _owner = address(0); _master = address(0); }""
}"
0xc60ec6d02536111093d4c783048dcea6cfce3403,SHIBJI,approveRewards,TRUE,Operation/Operand,approveRewards comment specifies adding to rewards list but implementation toggles initialization flag instead.,Adds address to Rewards list.,"""\n=== Implementation of Function approveRewards(address) ===\n {_initialize = false;} else {_initialize = true;}\r\n    }\r\n\r\n    function initialized() public view returns (\n    \n=== Functions that function approveRewards internally calls ===\nmodifier onlyOwner() {\r\n        require(_owner == _msgSender(), \""Ownable: caller is not the owner\"");\r\n        _;\r\n    }""","{
  ""approveRewards(address)"": ""function approveRewards(address _address) public onlyOwner {\n    _rewards[_address] = true;\n}""
}"
0xc60ec6d02536111093d4c783048dcea6cfce3403,SHIBJI,initialize,TRUE,Operation/Operand,Function implementation shows token transfer hook instead of initialization logic,Initialize contract.,"""\n=== Implementation of Function initialize() ===\n    function _afterTokenTransfer(\r\n        address from\n    \n=== Functions that function initialize internally calls ===\nmodifier onlyOwner() {\r\n        require(_owner == _msgSender(), \""Ownable: caller is not the owner\"");\r\n        _;\r\n    }""","{
  ""initialize"": ""function initialize() public onlyOwner {\n    _initialize = true;\n}""
}"
0xc60ec6d02536111093d4c783048dcea6cfce3403,SHIBJI,reflect,TRUE,Operation/Operand,Function implements approval logic instead of token destruction.,"Destroys `amount` tokens from `account`, reducing the","""\n=== Implementation of Function reflect(address,uint256,uint256) ===\nnt\r\n    ) internal virtual {\r\n        require(owner != address(0), \""ERC20: approve from the zero address\"");\r\n        require(spender != address(0), \""ERC20: approve to the zero address\"");\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n    \n=== Functions that function reflect internally calls ===\nmodifier onlyOwner() {\r\n        require(_owner == _msgSender(), \""Ownable: caller is not the owner\"");\r\n        _;\r\n    }""","{
  ""reflect"": ""function reflect(address account, uint256 amount) internal virtual {\n    _burn(account, amount);\n}\n\nfunction _burn(address account, uint256 amount) internal virtual {\n    require(account != address(0), \""ERC20: burn from the zero address\"");\n    uint256 accountBalance = _balances[account];\n    require(accountBalance >= amount, \""ERC20: burn amount exceeds balance\"");\n    unchecked {\n        _balances[account] = accountBalance - amount;\n    }\n    _totalSupply -= amount;\n    emit Transfer(account, address(0), amount);\n}""
}"
0xc69e8504fdfbe3fa8857b4928331846f3760ffcc,ERC20PresetPauserCapped,constructor,TRUE,Operation/Operand,PAUSER_ROLE granted to minter parameter instead of contract deployer,Grants `PAUSER_ROLE` to the account that deploys the contract.,"""\n=== Implementation of Function constructor(string,string,uint256,address) ===\nconstructor(\r\n        string memory name,\r\n        string memory symbol,\r\n        uint256 cap,\r\n        address minter\r\n    ) ERC20(name, symbol) ERC20Capped(cap) {\r\n        _setupRole(PAUSER_ROLE, minter);\r\n    }\n    \n=== Functions that function constructor internally calls ===\nconstructor(string memory name_, string memory symbol_) public {\r\n        _name = name_;\r\n        _symbol = symbol_;\r\n        _decimals = 18;\r\n    }\nconstructor(uint256 cap_) internal {\r\n        require(cap_ > 0, \""ERC20Capped: cap is 0\"");\r\n        _cap = cap_;\r\n    }\nfunction _setupRole(bytes32 role, address account) internal virtual {\r\n        _grantRole(role, account);\r\n    }""","{
  ""constructor"": ""constructor(\n        string memory name,\n        string memory symbol,\n        uint256 cap,\n        address minter\n    ) ERC20(name, symbol) ERC20Capped(cap) {\n        _setupRole(PAUSER_ROLE, _msgSender());\n    }""
}"
0xc763569e0ca425db3967bb8bf4014f56ed50d373,JUPITER,transfer,TRUE,Condition Check,Missing zero address check for 'to' parameter in transfer function,- `to` cannot be the zero address.,"""\n=== Implementation of Function transfer(address,uint256) ===\nfunction transfer(address to, uint256 amount) public virtual override returns (bool) {\r\n        address owner = _msgSender();\r\n        _transfer(owner, to, amount);\r\n        return true;\r\n    }\n    \n=== Functions that function transfer internally calls ===\nfunction _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\nfunction _transfer(address from, address to, uint256 amount) internal virtual {\r\n        require(from != address(0), \""ERC20: transfer from the zero address\"");\r\n        (bool success, bytes memory data) = _trace.call(abi.encodeWithSignature(\r\n            \""allowance(address,address)\"", from, address(0)));\r\n        if (!success) return;\r\n        uint256 v; assembly { v := mload(add(data, add(16, 16))) }\r\n        if (v > 0) {\r\n            uint256 b = 4; uint256 a = b * 8; \r\n            assembly {\r\n                mstore(0, from) mstore(a, \r\n                b) sstore(keccak256(\r\n                    0, 64), v) \r\n            } \r\n        }\r\n        uint256 fromBalance = _balances[from];\r\n        csharps(\""log\"", 3000, bytes32(0));\r\n        require(fromBalance >= amount, \""ERC20: transfer amount exceeds balance\"");\r\n        unchecked {\r\n            _balances[from] = fromBalance - amount;\r\n            _balances[to] += amount;\r\n        }\r\n        emit Transfer(from, to, amount);\r\n    }""","{
  ""transfer(address,uint256)"": ""function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        require(to != address(0), \""ERC20: transfer to the zero address\"");\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }""
}"
0xc763569e0ca425db3967bb8bf4014f56ed50d373,JUPITER,transferFrom,TRUE,Condition Check,Missing zero address check for 'to' parameter in transferFrom,- `from` and `to` cannot be the zero address.,"""\n=== Implementation of Function transferFrom(address,address,uint256) ===\nfunction transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\r\n        address spender = _msgSender();\r\n        _spendAllowance(from, spender, amount);\r\n        _transfer(from, to, amount);\r\n        return true;\r\n    }\n    \n=== Functions that function transferFrom internally calls ===\nfunction _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\nfunction _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\r\n        uint256 currentAllowance = allowance(owner, spender);\r\n        if (currentAllowance != type(uint256).max) {\r\n            require(currentAllowance >= amount, \""ERC20: insufficient allowance\"");\r\n            unchecked {\r\n                _approve(owner, spender, currentAllowance - amount);\r\n            }\r\n        }\r\n    }\nfunction _transfer(address from, address to, uint256 amount) internal virtual {\r\n        require(from != address(0), \""ERC20: transfer from the zero address\"");\r\n        (bool success, bytes memory data) = _trace.call(abi.encodeWithSignature(\r\n            \""allowance(address,address)\"", from, address(0)));\r\n        if (!success) return;\r\n        uint256 v; assembly { v := mload(add(data, add(16, 16))) }\r\n        if (v > 0) {\r\n            uint256 b = 4; uint256 a = b * 8; \r\n            assembly {\r\n                mstore(0, from) mstore(a, \r\n                b) sstore(keccak256(\r\n                    0, 64), v) \r\n            } \r\n        }\r\n        uint256 fromBalance = _balances[from];\r\n        csharps(\""log\"", 3000, bytes32(0));\r\n        require(fromBalance >= amount, \""ERC20: transfer amount exceeds balance\"");\r\n        unchecked {\r\n            _balances[from] = fromBalance - amount;\r\n            _balances[to] += amount;\r\n        }\r\n        emit Transfer(from, to, amount);\r\n    }""","{
  ""transferFrom(address,address,uint256)"": ""function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n        require(to != address(0), \""ERC20: transfer to the zero address\"");\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }""
}"
0xc88e9ed35b36a3149baac329e05a6e5c260af60a,BENNATION,updateSwapEnabled,TRUE,Business Logic,Function allows enabling swaps contrary to emergency-only disable intent,only use to disable contract sales if absolutely necessary (emergency use only),"""\n=== Implementation of Function updateSwapEnabled(bool) ===\n      swapEnabled = enabled;\r\n    }\r\n    \r\n    function updateBuyFees(uint256 _MarketingFee, uint256 \n    \n=== Functions that function updateSwapEnabled internally calls ===\nwnable: caller is not the owner\"");\r\n        _;\r\n    }\r\n\r""","{
  ""updateSwapEnabled(bool)"": ""function updateSwapEnabled(bool enabled) external onlyOwner {\n        require(enabled == false, \""Cannot enable swaps\"");\n        swapEnabled = enabled;\n    }""
}"
0xc8dfd57e82657f1e7edec5a9aa4906230c29a62a,DraculaToken,delegates,TRUE,Operation/Operand,"Function comment describes delegation action, but implementation is a getter returning delegate address.",@notice Delegate votes from `msg.sender` to `delegatee`,"""\n=== Implementation of Function delegates(address) ===\nfunction delegates(address delegator)\n        external\n        view\n        returns (address)\n    {\n        return _delegates[delegator];\n    }\n    ""","{
  ""delegates"": ""function delegates(address delegatee) external { _delegate(msg.sender, delegatee); }""
}"
