[
  {
    "contract": "Saturn",
    "function": "updateFinishTime",
    "explanation": "Max time calculation uses current time instead of initial finishTime + 24h cap.",
    "contract_code": "\n=== Implementation of Function updateFinishTime(uint256) ===\nnction updateFinishTime(uint256 _tokenAmount) private {\r\n        uint256 _timeDelta = _tokenAmount.div(ONE_TOKEN).mul(TIME_DURATION_INCREASE);\r\n        uint256 _finishTime = finishTime.add(_timeDelta);\r\n        uint256 _maxTime = now.add(TIME_DURATION_MAX);\r\n        finishTime = _finishTime <= _maxTime ? _finishTime : _maxTime;\r\n    }\r\n\n    \n=== Functions that function updateFinishTime internally calls ===\nfunction add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\nfunction div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a / b;\r\n    }\nfunction mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }",
    "rewritten_code": {
      "updateFinishTime": "function updateFinishTime(uint256 _tokenAmount) private {\n        uint256 _timeDelta = _tokenAmount.div(ONE_TOKEN).mul(TIME_DURATION_INCREASE);\n        uint256 _newFinishTime = finishTime.add(_timeDelta);\n        uint256 _maxAllowedTime = startTime.add(TIME_DURATION_MAX);\n        finishTime = _newFinishTime < _maxAllowedTime ? _newFinishTime : _maxAllowedTime;\n    }"
    }
  },
  {
    "contract": "Saturn",
    "function": "transfer",
    "explanation": "Forces 0.08 token transfer post-game completion instead of allowing any amount",
    "contract_code": "\n=== Implementation of Function transfer(address,uint256) ===\nnction transfer(address _to, uint256 _value) isActivated isAccount public returns (bool) {\r\n        require(_to == address(this));\r\n        Player storage _player = playerOf[msg.sender];\r\n        require(_player.pid > 0);\r\n        if (now >= finishTime) {\r\n            if (winner == address(0)) {\r\n                endGame();\r\n            }\r\n            _value = 80000000000000000;\r\n        } else {\r\n            require(_value == 80000000000000000 || _value == 10000000000000000);\r\n        }\r\n        uint256 _sharePot = _player.tokenBalance.mul(sharePot).div(totalSupply); // all share pot the player will get.\r\n        uint256 _eth = 0;\r\n        if (_sharePot > _player.ethShareWithdraw) {\r\n            _eth = _sharePot.sub(_player.ethShareWithdraw);\r\n            _player.ethShareWithdraw = _sharePot;\r\n        }\r\n        _eth = _eth.add(_player.ethBalance);\r\n        _player.ethBalance = 0;\r\n        _player.ethWithdraw = _player.ethWithdraw.add(_eth);\r\n        if (_value == 80000000000000000) {\r\n            uint256 _fee = _eth.mul(feeIndex >= feePercents.length ? 0 : feePercents[feeIndex]).div(1000);\r\n            if (_fee > 0) {\r\n                feeAmount = feeAmount.add(_fee);\r\n                _eth = _eth.sub(_fee);\r\n            }\r\n            sendFeeIfAvailable();\r\n            msg.sender.transfer(_eth);\r\n            emit Withdraw(_to, msg.sender, _eth);\r\n            emit Transfer(msg.sender, _to, 0);\r\n        } else {\r\n            InternalBuyEvent memory _buyEvent = InternalBuyEvent({\r\n                flag1: 0\r\n                });\r\n            buy(_player, _buyEvent, _eth);\r\n        }\r\n        return true;\r\n    }\r\n\n    \n=== Functions that function transfer internally calls ===\ndifier isAccount() {\r\n        address _address = msg.sender;\r\n        uint256 _codeLength;\r\n\r\n        assembly {_codeLength := extcodesize(_address)}\r\n        require(_codeLength == 0 && tx.origin == msg.sender);\r\n        _;\r\n    }\r\n\ndifier isActivated() {\r\n        require(now >= startTime);\r\n        _;\r\n    }\r\n\nfunction add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\nfunction div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a / b;\r\n    }\nfunction mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\nfunction sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\nnction buy(Player storage _player, InternalBuyEvent memory _buyEvent, uint256 _amount) private {\r\n        require(now < finishTime && _amount >= BUY_AMOUNT_MIN && _amount <= BUY_AMOUNT_MAX);\r\n        uint256 _day = (now / 86400) * 86400;\r\n        uint256 _backEth = 0;\r\n        uint256 _eth = _amount;\r\n        if (totalPot < 200000000000000000000) {\r\n            if (_eth >= 5000000000000000000) {\r\n                _backEth = _eth.sub(5000000000000000000);\r\n                _eth = 5000000000000000000;\r\n            }\r\n        }\r\n        txCount = txCount + 1; // do not need use safe math\r\n        _buyEvent.flag1 += txCount * 10; // do not need use safe math\r\n        _player.ethTotal = _player.ethTotal.add(_eth);\r\n        totalPot = totalPot.add(_eth);\r\n        uint256 _newTotalSupply = calculateTotalSupply(totalPot);\r\n        uint256 _tokenAmount = _newTotalSupply.sub(totalSupply);\r\n        _player.tokenBalance = _player.tokenBalance.add(_tokenAmount);\r\n        if (_player.tokenDay == _day) {\r\n            _player.tokenDayBalance = _player.tokenDayBalance.add(_tokenAmount);\r\n        } else {\r\n            _player.tokenDay = _day;\r\n            _player.tokenDayBalance = _tokenAmount;\r\n        }\r\n        updatePrice(_newTotalSupply);\r\n        handlePot(_day, _eth, _newTotalSupply, _tokenAmount, _player, _buyEvent);\r\n        if (_backEth > 0) {\r\n            _player.ethBalance = _player.ethBalance.add(_backEth);\r\n        }\r\n        sendFeeIfAvailable();\r\n        emitEndTxEvents(_eth, _tokenAmount, _buyEvent);\r\n    }\r\n\nnction endGame() private {\r\n        if (luckyPot > 0) {\r\n            feeAmount = feeAmount.add(luckyPot);\r\n            luckyPot = 0;\r\n        }\r\n        if (winner == address(0) && lastPlayer != address(0)) {\r\n            winner = lastPlayer;\r\n            lastPlayer = address(0);\r\n            winAmount = finalPot;\r\n            finalPot = 0;\r\n            Player storage _player = playerOf[winner];\r\n            _player.ethBalance = _player.ethBalance.add(winAmount);\r\n            emit Win(address(this), winner, winAmount);\r\n        }\r\n    }\r\n\nnction sendFeeIfAvailable() private {\r\n        if (feeAmount > 1000000000000000000) {\r\n            feeOwner.transfer(feeAmount);\r\n            feeAmount = 0;\r\n        }\r\n    }\r\n",
    "rewritten_code": {
      "transfer": "function transfer(address _to, uint256 _value) isActivated isAccount public returns (bool) {\n        require(_to == address(this));\n        Player storage _player = playerOf[msg.sender];\n        require(_player.pid > 0);\n        if (now >= finishTime) {\n            if (winner == address(0)) {\n                endGame();\n            }\n        } else {\n            require(_value == 80000000000000000 || _value == 10000000000000000);\n        }\n        uint256 _sharePot = _player.tokenBalance.mul(sharePot).div(totalSupply);\n        uint256 _eth = 0;\n        if (_sharePot > _player.ethShareWithdraw) {\n            _eth = _sharePot.sub(_player.ethShareWithdraw);\n            _player.ethShareWithdraw = _sharePot;\n        }\n        _eth = _eth.add(_player.ethBalance);\n        _player.ethBalance = 0;\n        _player.ethWithdraw = _player.ethWithdraw.add(_eth);\n        if (_value == 80000000000000000 || now >= finishTime) {\n            uint256 _fee = _eth.mul(feeIndex >= feePercents.length ? 0 : feePercents[feeIndex]).div(1000);\n            if (_fee > 0) {\n                feeAmount = feeAmount.add(_fee);\n                _eth = _eth.sub(_fee);\n            }\n            sendFeeIfAvailable();\n            msg.sender.transfer(_eth);\n            emit Withdraw(_to, msg.sender, _eth);\n            emit Transfer(msg.sender, _to, 0);\n        } else {\n            InternalBuyEvent memory _buyEvent = InternalBuyEvent({flag1: 0});\n            buy(_player, _buyEvent, _eth);\n        }\n        return true;\n    }"
    }
  },
  {
    "contract": "Saturn",
    "function": "withdrawFee",
    "explanation": "Missing check to ensure withdrawal amount does not exceed feeAmount",
    "contract_code": "\n=== Implementation of Function withdrawFee(uint256) ===\nnction withdrawFee(uint256 _amount) onlyOwner public {\r\n        require(now >= finishTime.add(30 days));\r\n        if (winner == address(0)) {\r\n            endGame();\r\n        }\r\n        feeAmount = feeAmount > _amount ? feeAmount.sub(_amount) : 0;\r\n        feeOwner.transfer(_amount);\r\n    }\r\n\n    \n=== Functions that function withdrawFee internally calls ===\nfunction add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\nfunction sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\nmodifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\nnction endGame() private {\r\n        if (luckyPot > 0) {\r\n            feeAmount = feeAmount.add(luckyPot);\r\n            luckyPot = 0;\r\n        }\r\n        if (winner == address(0) && lastPlayer != address(0)) {\r\n            winner = lastPlayer;\r\n            lastPlayer = address(0);\r\n            winAmount = finalPot;\r\n            finalPot = 0;\r\n            Player storage _player = playerOf[winner];\r\n            _player.ethBalance = _player.ethBalance.add(winAmount);\r\n            emit Win(address(this), winner, winAmount);\r\n        }\r\n    }\r\n",
    "rewritten_code": {
      "withdrawFee(uint256)": "function withdrawFee(uint256 _amount) onlyOwner public {\n        require(now >= finishTime.add(30 days));\n        require(_amount <= feeAmount, 'Exceeds available fee');\n        if (winner == address(0)) {\n            endGame();\n        }\n        feeAmount = feeAmount.sub(_amount);\n        feeOwner.transfer(_amount);\n    }"
    }
  }
]