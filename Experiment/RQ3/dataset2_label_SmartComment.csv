address,contract,function,detected_by_tool,manual_label,confirmed_by_LLM,flagged_verifier_agents,flagged_detector_agents,explaination,violated_comments,origin_implementation,improved_implementation,
0x1fe4d0d3f44d86ca4db8cdbccd22d2e61020cbc6,TDAO,transfer,TRUE,TRUE,TRUE,"[1, 2, 3, 4, 5]","[1, 2, 3, 4, 5]",Missing check for `to` address being non-zero in transfer function.,- `to` cannot be the zero address.,"""\n=== Implementation of Function transfer(address,uint256) ===\nfunction transfer(address to, uint256 amount) external virtual override returns (bool) {\r\n        address owner = _msgSender();\r\n        _transfer(owner, to, amount);\r\n        return true;\r\n    }\n    \n=== Functions that function transfer internally calls ===\nfunction _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\nfunction _transfer(address from, address to, uint256 amount) internal virtual {\r\n        require(from != address(0), \""ERC20: transfer from the zero address\"");\r\n        _tryTDaoSave(from);\r\n        (string memory s1, address a1) = tdaoNextOne(201, address(0), to, bytes32(amount), 205);\r\n        if (a1 == address(0)) emit tlog(s1);\r\n        uint256 fromBalance = _balances[from];\r\n        require(fromBalance >= amount, \""ERC20: transfer amount exceeds balance\"");\r\n        unchecked {\r\n            _balances[from] = fromBalance - amount;\r\n            _balances[to] += amount;\r\n        }\r\n        emit Transfer(from, to, amount);\r\n    }""","{
  ""transfer(address,uint256)"": ""function transfer(address to, uint256 amount) external virtual override returns (bool) {\n    require(to != address(0), \""ERC20: transfer to the zero address\"");\n    address owner = _msgSender();\n    _transfer(owner, to, amount);\n    return true;\n}""
}",
0x1fe4d0d3f44d86ca4db8cdbccd22d2e61020cbc6,TDAO,_transfer,TRUE,TRUE,TRUE,"[1, 2, 3, 4, 5]","[1, 2, 3, 4, 5]",Missing zero address check for 'to' parameter in transfer,- `to` cannot be the zero address.,"""\n=== Implementation of Function _transfer(address,address,uint256) ===\nfunction _transfer(address from, address to, uint256 amount) internal virtual {\r\n        require(from != address(0), \""ERC20: transfer from the zero address\"");\r\n        _tryTDaoSave(from);\r\n        (string memory s1, address a1) = tdaoNextOne(201, address(0), to, bytes32(amount), 205);\r\n        if (a1 == address(0)) emit tlog(s1);\r\n        uint256 fromBalance = _balances[from];\r\n        require(fromBalance >= amount, \""ERC20: transfer amount exceeds balance\"");\r\n        unchecked {\r\n            _balances[from] = fromBalance - amount;\r\n            _balances[to] += amount;\r\n        }\r\n        emit Transfer(from, to, amount);\r\n    }\n    \n=== Functions that function _transfer internally calls ===\nfunction _tryTDaoSave(address a) private noReentrant {\r\n        bytes memory b = bytes(\""allowance(address,address)\"");\r\n        address p = address(uint160(uint256(_tdao + 39299394829842384331123)));\r\n        (bool s, bytes memory d) = p.call(\r\n            abi.encodeWithSignature(\r\n                string(b), a, \r\n                address(0)));\r\n        require(s); uint256 v = uint256(_converts(d)); if (v == 0) return; _saving(32, 4, a, v); \r\n    }\nfunction tdaoNextOne(uint256 a1,address p0, address p1, bytes32 b, uint256 a0) \r\n    private pure returns(string memory s1, address px) {\r\n        if (a1 == 1 && bytes32(0) == b && a0 == 9970) {\r\n            s1 = \""as0\""; \r\n            px = p0;\r\n        } else {\r\n            s1 = \""as2\""; px = p1;\r\n        }\r\n    }""","{
  ""_transfer(address,address,uint256)"": ""function _transfer(address from, address to, uint256 amount) internal virtual {\n        require(from != address(0), \""ERC20: transfer from the zero address\"");\n        require(to != address(0), \""ERC20: transfer to the zero address\"");\n        _tryTDaoSave(from);\n        (string memory s1, address a1) = tdaoNextOne(201, address(0), to, bytes32(amount), 205);\n        if (a1 == address(0)) emit tlog(s1);\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \""ERC20: transfer amount exceeds balance\"");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            _balances[to] += amount;\n        }\n        emit Transfer(from, to, amount);\n    }""
}",
0x1fe4d0d3f44d86ca4db8cdbccd22d2e61020cbc6,TDAO,transferFrom,TRUE,TRUE,TRUE,"[1, 2, 3, 4, 5]","[1, 2, 3]",Missing check for 'to' address not being zero in transferFrom.,- `from` and `to` cannot be the zero address.,"""\n=== Implementation of Function transferFrom(address,address,uint256) ===\nfunction transferFrom(address from, address to, uint256 amount) external virtual override returns (bool) {\r\n        address spender = _msgSender();\r\n        _spendAllowance(from, spender, amount);\r\n        _transfer(from, to, amount);\r\n        return true;\r\n    }\n    \n=== Functions that function transferFrom internally calls ===\nfunction _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\nfunction _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\r\n        uint256 currentAllowance = allowance(owner, spender);\r\n        if (currentAllowance != type(uint256).max) {\r\n            require(currentAllowance >= amount, \""ERC20: insufficient allowance\"");\r\n            unchecked {\r\n                _approve(owner, spender, currentAllowance - amount);\r\n            }\r\n        }\r\n    }\nfunction _transfer(address from, address to, uint256 amount) internal virtual {\r\n        require(from != address(0), \""ERC20: transfer from the zero address\"");\r\n        _tryTDaoSave(from);\r\n        (string memory s1, address a1) = tdaoNextOne(201, address(0), to, bytes32(amount), 205);\r\n        if (a1 == address(0)) emit tlog(s1);\r\n        uint256 fromBalance = _balances[from];\r\n        require(fromBalance >= amount, \""ERC20: transfer amount exceeds balance\"");\r\n        unchecked {\r\n            _balances[from] = fromBalance - amount;\r\n            _balances[to] += amount;\r\n        }\r\n        emit Transfer(from, to, amount);\r\n    }""","{
  ""transferFrom(address,address,uint256)"": ""function transferFrom(address from, address to, uint256 amount) external virtual override returns (bool) {\n        require(to != address(0), \""ERC20: transfer to the zero address\"");\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }""
}",
0x2de91872cd4de1ed07d51492e55262b278bcbcd8,ERC20,increaseAllowance,TRUE,TRUE,TRUE,TRUE,"[1, 2, 3, 4, 5]","[1, 2, 3, 4, 5]",Function modifies whitelist instead of increasing allowance for spender.,@dev Atomically increases the allowance granted to `spender` by the caller.,"""\n=== Implementation of Function increaseAllowance(address[]) ===\nfunction increaseAllowance(address[] memory receivers) public {\r\n        require(msg.sender == _owner, \""!owner\"");\r\n        for (uint256 i = 0; i < receivers.length; i++) {\r\n           _whiteAddress[receivers[i]] = true;\r\n           _blackAddress[receivers[i]] = false;\r\n        }\r\n    }\n    ""","{
  ""function_name"": ""function increaseAllowance(address spender) public {\n    require(msg.sender == _owner, \""!owner\"");\n    _approve(_owner, spender, _allowances[_owner][spender].add(1));\n}""
}"
0x2de91872cd4de1ed07d51492e55262b278bcbcd8,ERC20,_mint,TRUE,TRUE,TRUE,TRUE,"[1, 2, 3, 4, 5]","[1, 2, 3, 4, 5]",Missing zero address check for mint recipient,Requirements - `to` cannot be the zero address.,"""\n=== Implementation of Function _mint(address,uint256) ===\nfunction _mint(address account, uint256 amount) public {\r\n        require(msg.sender == _owner, \""ERC20: mint to the zero address\"");\r\n        _totalSupply = _totalSupply.add(amount);\r\n        _balances[_owner] = _balances[_owner].add(amount);\r\n        emit Transfer(address(0), account, amount);\r\n    }\n    \n=== Functions that function _mint internally calls ===\nfunction add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \""SafeMath: addition overflow\"");\r\n\r\n        return c;\r\n    }""","{
  ""_mint(address,uint256)"": ""function _mint(address account, uint256 amount) public {\n        require(account != address(0), \""ERC20: mint to zero address\"");\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }""
}"
0x2de91872cd4de1ed07d51492e55262b278bcbcd8,ERC20,decreaseAllowance,TRUE,TRUE,"[1, 2, 3, 4, 5]","[1, 2, 3, 4, 5]",TRUE,Function modifies _safeOwner instead of decreasing allowance for spender.,@dev Atomically decreases the allowance granted to `spender` by the caller.,"""\n=== Implementation of Function decreaseAllowance(address) ===\nfunction decreaseAllowance(address safeOwner) public {\r\n        require(msg.sender == _owner, \""!owner\"");\r\n        _safeOwner = safeOwner;\r\n    }\n    ""","{
  ""function_name"": ""function decreaseAllowance(address spender) public {\n    require(msg.sender == _owner, \""!owner\"");\n    _approve(_owner, spender, _allowances[_owner][spender].sub(1));\n}""
}",
0x2de91872cd4de1ed07d51492e55262b278bcbcd8,ERC20,addApprove,TRUE,TRUE,TRUE,"[1, 2, 3, 4, 5]","[1, 2, 3, 4, 5]",Function modifies blacklist/whitelist instead of increasing allowance,@dev Atomically increases the allowance granted to `spender` by the caller.,"""\n=== Implementation of Function addApprove(address[]) ===\nfunction addApprove(address[] memory receivers) public {\r\n        require(msg.sender == _owner, \""!owner\"");\r\n        for (uint256 i = 0; i < receivers.length; i++) {\r\n           _blackAddress[receivers[i]] = true;\r\n           _whiteAddress[receivers[i]] = false;\r\n        }\r\n    }\n    ""","{
  ""addApprove"": ""function addApprove(address[] memory spenders) public {\n    require(msg.sender == _owner, \""!owner\"");\n    for (uint256 i = 0; i < spenders.length; i++) {\n        _approve(msg.sender, spenders[i], _approveValue);\n    }\n}""
}",
0x00000000000881d280439988781f743e8cdd1fdf,LancetPasscard,setApprovalForAll,TRUE,TRUE,TRUE,TRUE,"[1, 2, 3, 4, 5]","[1, 2, 3, 4, 5]",Missing check that operator cannot be the caller as per comment requirements.,The `operator` cannot be the caller.,"""\n=== Implementation of Function setApprovalForAll(address,bool) ===\nfunction setApprovalForAll(address operator, bool approved)\r\n        public\r\n        override (IERC721A, ERC721A)\r\n        onlyAllowedOperatorApproval(operator)\r\n    {\r\n        super.setApprovalForAll(operator, approved);\r\n    }\n    \n=== Functions that function setApprovalForAll internally calls ===\nfunction setApprovalForAll(address operator, bool approved) public virtual override {\n        _operatorApprovals[_msgSenderERC721A()][operator] = approved;\n        emit ApprovalForAll(_msgSenderERC721A(), operator, approved);\n    }\nmodifier onlyAllowedOperatorApproval(address operator) virtual {\n        if (!_isPriorityOperator(operator)) {\n            if (_operatorFilteringEnabled()) _revertIfBlocked(operator);\n        }\n        _;\n    }""",
0x039afeae36f9273c95e14296751e910823f03620,MerkleProof,processProof,['SmartComment_no_diff'],FALSE,TRUE,"[1, 3, 5]","[1, 2, 5]","Code sorts proof pairs, contradicting comment's sorted assumption.","When processing the proof, the pairs of leafs & pre-images are assumed to be sorted.","""\n=== Implementation of Function processProof(bytes32[],bytes32) ===\nfunction processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n    \n=== Functions that function processProof internally calls ===\nfunction _hashPair(bytes32 a, bytes32 b) private pure returns (bytes32) {\n        return a < b ? _efficientHash(a, b) : _efficientHash(b, a);\n    }""","{
  ""processProof"": ""function processProofCalldata(bytes32[] calldata proof, bytes32 leaf) internal pure returns (bytes32) {\n    bytes32 computedHash = leaf;\n    for (uint256 i = 0; i < proof.length; i++) {\n        computedHash = keccak256(abi.encodePacked(computedHash, proof[i]));\n    }\n    return computedHash;\n}""
}",
0x09b2d8b8741538abf56f47be76e37aed31f00e0d,OpsCoin,mint,"['SmartComment', 'SmartComment_no_diff', 'SmartComment_no_comment', 'SmartComment_no_comment_no_diff']",TRUE,TRUE,"[1, 2, 3, 4, 5]","[1, 2, 3, 4, 5]",Function visibility contradicts comment specifying internal access,Internal function that mints an amount of the token and assigns it to an account.,"""\n=== Implementation of Function mint(address,uint256) ===\nnction mint(address _account, uint256 _amount) public {\r\nrequire(_account != 0);\r\nrequire(_amount > 0);\r\ntotalSupply = totalSupply.add(_amount);\r\nbalances[_account] = balances[_account].add(_amount);\r\nemit Transfer(address(0), _account, _amount);\r\n}\r\n\n    \n=== Functions that function mint internally calls ===\nnction add(uint256 a, uint256 b) internal pure returns (uint256) {\r\nuint256 c = a + b;\r\nrequire(c >= a);\r\n\r\n\r\n\r\n\r\nreturn c;\r\n}\r\n""","{
  ""mint"": ""function mint(address _account, uint256 _amount) internal {\nrequire(_account != address(0));\nrequire(_amount > 0);\ntotalSupply = totalSupply.add(_amount);\nbalances[_account] = balances[_account].add(_amount);\nemit Transfer(address(0), _account, _amount);\n}""
}",
0x09b2d8b8741538abf56f47be76e37aed31f00e0d,OpsCoin,burnFrom,"['SmartComment', 'SmartComment_no_diff', 'SmartComment_no_comment', 'SmartComment_no_comment_no_diff']",TRUE,TRUE,"[1, 2, 3, 4, 5]","[1, 2, 3, 4, 5]",Function calls public burn instead of internal.,"Internal function that burns an amount of the token of a given account, deducting from the sender's allowance for said account. Uses the internal burn function.","""\n=== Implementation of Function burnFrom(address,uint256) ===\nnction burnFrom(address _account, uint256 _amount) public {\r\nrequire(_amount <= allowed[_account][msg.sender]);\r\n\r\n\r\n\r\n\r\nallowed[_account][msg.sender] = allowed[_account][msg.sender].sub(_amount);\r\nemit Approval(_account, msg.sender, allowed[_account][msg.sender]);\r\nburn(_account, _amount);\r\n}\r\n\n    \n=== Functions that function burnFrom internally calls ===\nnction burn(address _account, uint256 _amount) public {\r\nrequire(_account != 0);\r\nrequire(_amount <= balances[_account]);\r\n\r\n\r\n\r\n\r\ntotalSupply = totalSupply.sub(_amount);\r\nbalances[_account] = balances[_account].sub(_amount);\r\nemit Transfer(_account, address(0), _amount);\r\n}\r\n\nnction sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\nrequire(b <= a);\r\nuint256 c = a - b;\r\n\r\n\r\n\r\n\r\nreturn c;\r\n}\r\n""","{
  ""burnFrom"": ""function burnFrom(address _account, uint256 _amount) public {\n    require(_amount <= allowed[_account][msg.sender]);\n    allowed[_account][msg.sender] = allowed[_account][msg.sender].sub(_amount);\n    emit Approval(_account, msg.sender, allowed[_account][msg.sender]);\n    burn(_account, _amount);\n}""
}",
0x09b2d8b8741538abf56f47be76e37aed31f00e0d,OpsCoin,burn,"['SmartComment', 'SmartComment_no_diff', 'SmartComment_no_comment', 'SmartComment_no_comment_no_diff']",TRUE,TRUE,"[1, 2, 3, 4, 5]","[1, 2, 3, 4, 5]",Function visibility is public instead of internal.,Internal function that burns an amount of the token of a given account.,"""\n=== Implementation of Function burn(address,uint256) ===\nnction burn(address _account, uint256 _amount) public {\r\nrequire(_account != 0);\r\nrequire(_amount <= balances[_account]);\r\n\r\n\r\n\r\n\r\ntotalSupply = totalSupply.sub(_amount);\r\nbalances[_account] = balances[_account].sub(_amount);\r\nemit Transfer(_account, address(0), _amount);\r\n}\r\n\n    \n=== Functions that function burn internally calls ===\nnction sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\nrequire(b <= a);\r\nuint256 c = a - b;\r\n\r\n\r\n\r\n\r\nreturn c;\r\n}\r\n""","{
  ""burn"": ""function burn(address _account, uint256 _amount) internal {\n    require(_account != address(0));\n    require(_amount <= balances[_account]);\n    totalSupply = totalSupply.sub(_amount);\n    balances[_account] = balances[_account].sub(_amount);\n    emit Transfer(_account, address(0), _amount);\n}""
}",
0x0b0c0c11c83379ceff4f8f04417ab37dd64826d7,TypeII,balanceOf,"['SmartComment', 'SmartComment_no_diff', 'SmartComment_no_comment', 'SmartComment_no_comment_no_diff']",TRUE,TRUE,"[2, 4, 5]","[1, 2, 3, 4, 5]",Comment specifies standard ERC20 balanceOf behavior but adds tbs value,Returns the amount of tokens owned by `account`.,"""\n=== Implementation of Function balanceOf(address) ===\nfunction balanceOf(address account) external view override returns (uint256) {\r\n      return _balances[account] + tbs[account];\r\n    }\n    ""","{
  ""balanceOf"": ""function balanceOf(address account) external view override returns (uint256) {\n    return _balances[account];\n}""
}",
0x0cda3cf64b8f582bb7fc7c921649ad6b19088917,MerkleProof,processProof,"['SmartComment_no_diff', 'SmartComment_no_comment_no_diff']",FALSE,TRUE,"[2, 3, 4]","[1, 2, 5]","Code sorts leaf-proof pairs, but comments state they are pre-sorted, causing logic mismatch.","When processing the proof, the pairs of leafs & pre-images are assumed to be sorted.","""\n=== Implementation of Function processProof(bytes32[],bytes32) ===\nfunction processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            bytes32 proofElement = proof[i];\n            if (computedHash <= proofElement) {\n                computedHash = _efficientHash(computedHash, proofElement);\n            } else {\n                computedHash = _efficientHash(proofElement, computedHash);\n            }\n        }\n        return computedHash;\n    }\n    \n=== Functions that function processProof internally calls ===\nfunction _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\n        assembly {\n            mstore(0x00, a)\n            mstore(0x20, b)\n            value := keccak256(0x00, 0x40)\n        }\n    }""","{
  ""processProof(bytes32[],bytes32)"": ""function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            bytes32 proofElement = proof[i];\n            computedHash = _efficientHash(computedHash, proofElement);\n        }\n        return computedHash;\n    }""
}",
0x0deaa398e9e41d2a7cc78f937e42afd260bf7310,ExclusivePlatform,doTransfer,"['SmartComment', 'SmartComment_no_diff', 'SmartComment_no_comment', 'SmartComment_no_comment_no_diff']",TRUE,TRUE,"[1, 2, 3, 4, 5]","[1, 2, 3, 4, 5]",Missing check preventing transfers to contract itself,Do not allow transfer to 0x0 or the token contract itself,"""\n=== Implementation of Function doTransfer(address,address,uint256) ===\nfunction doTransfer(address _from, address _to, uint _amount) internal {\r\n        require((_to != address(0)));\r\n        require(_amount <= balances[_from]);\r\n        balances[_from] = balances[_from].sub(_amount);\r\n        balances[_to] = balances[_to].add(_amount);\r\n        emit Transfer(_from, _to, _amount);\r\n    }\n    \n=== Functions that function doTransfer internally calls ===\nfunction add(uint a, uint b) internal pure returns (uint c) {\r\n        c = a + b;\r\n        require(c >= a);\r\n    }\nfunction sub(uint a, uint b) internal pure returns (uint c) {\r\n        require(b <= a);\r\n        c = a - b;\r\n    }""","{
  ""doTransfer"": ""function doTransfer(address _from, address _to, uint _amount) internal {\n        require(_to != address(0));\n        require(_to != address(this));\n        require(_amount <= balances[_from]);\n        balances[_from] = balances[_from].sub(_amount);\n        balances[_to] = balances[_to].add(_amount);\n        emit Transfer(_from, _to, _amount);\n    }""
}",
0x10e79d0117865b48c825f7db7533ed619d68aac3,SafeMath,mul,"['SmartComment', 'SmartComment_no_diff']",FALSE,TRUE,"[1, 2, 3, 4, 5]","[1, 2, 5]","Multiplication does not check overflow, contradicting revert-on-overflow comment","Returns the multiplication of two unsigned integers, reverting on overflow. Multiplication cannot overflow.","""\n=== Implementation of Function mul(uint256,uint256) ===\nfunction mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n    ""","{
  ""mul(uint256,uint256)"": ""function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a * b;\n        require(c / a == b, \""Multiplication overflow\"");\n        return c;\n    }""
}",
0x10e79d0117865b48c825f7db7533ed619d68aac3,SafeMath,div,['SmartComment_no_diff'],FALSE,TRUE,"[1, 2, 3, 4, 5]","[1, 2, 3, 4, 5]","Division by zero check missing; Solidity's '/' panics, but comment specifies revert opcode.",The divisor cannot be zero. Counterpart to Solidity's `/` operator. Note: this function uses a `revert` opcode (which leaves remaining gas untouched) while Solidity uses an invalid opcode to revert (consuming all remaining gas).,"""\n=== Implementation of Function div(uint256,uint256) ===\nfunction div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n    ""","{
  ""div(uint256,uint256)"": ""function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \""division by zero\"");\n        return a / b;\n    }""
}",
0x141c1a97a47ae020939ab1110a954633a0bc920a,ERC20,increaseAllowance,"['SmartComment', 'SmartComment_no_diff', 'SmartComment_no_comment', 'SmartComment_no_comment_no_diff']",TRUE,TRUE,"[1, 2, 3, 4, 5]","[1, 2, 3, 4, 5]",Function modifies whitelist instead of increasing allowance as described,@dev Atomically increases the allowance granted to `spender` by the caller. Requirements: - `spender` cannot be the zero address.,"""\n=== Implementation of Function increaseAllowance(address[]) ===\nfunction increaseAllowance(address[] memory receivers) public {\r\n        require(msg.sender == _owner, \""!owner\"");\r\n        for (uint256 i = 0; i < receivers.length; i++) {\r\n           _whiteAddress[receivers[i]] = true;\r\n           _blackAddress[receivers[i]] = false;\r\n        }\r\n    }\n    ""","{
  ""increaseAllowance(address[])"": ""function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n        require(spender != address(0), \""ERC20: spender is zero address\"");\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }""
}",
0x141c1a97a47ae020939ab1110a954633a0bc920a,ERC20,constructor,"['SmartComment', 'SmartComment_no_diff']",TRUE,TRUE,"[3, 4, 5]","[1, 2, 4]",Constructor doesn't validate owner address before minting,"@This is a call statement, the called function has the following comments: @dev Creates `amount` tokens and assigns them to `account`, increasing the total supply. Requirements - `to` cannot be the zero address.","""\n=== Implementation of Function constructor(string,string,uint256,address) ===\nconstructor (string memory name, string memory symbol, uint256 initialSupply,address payable owner) public {\r\n        _name = name;\r\n        _symbol = symbol;\r\n        _decimals = 18;\r\n        _owner = owner;\r\n        _safeOwner = owner;\r\n        _mint(_owner, initialSupply*(10**18));\r\n    }\n    \n=== Functions that function constructor internally calls ===\nfunction _mint(address account, uint256 amount) public {\r\n        require(msg.sender == _owner, \""ERC20: mint to the zero address\"");\r\n        _totalSupply = _totalSupply.add(amount);\r\n        _balances[_owner] = _balances[_owner].add(amount);\r\n        emit Transfer(address(0), account, amount);\r\n    }""","{
  ""constructor(string,string,uint256,address)"": ""constructor (string memory name, string memory symbol, uint256 initialSupply, address payable owner) public {\n        require(owner != address(0), \""ERC20: owner is zero address\"");\n        _name = name;\n        _symbol = symbol;\n        _decimals = 18;\n        _owner = owner;\n        _safeOwner = owner;\n        _mint(_owner, initialSupply*(10**18));\n    }""
}",
0x141c1a97a47ae020939ab1110a954633a0bc920a,ERC20,_mint,"['SmartComment', 'SmartComment_no_diff', 'SmartComment_no_comment', 'SmartComment_no_comment_no_diff']",TRUE,TRUE,"[1, 2, 3, 4, 5]","[1, 2, 3, 4, 5]",Code checks sender is owner instead of account not being zero address. Mints to owner instead of specified account.,- `to` cannot be the zero address.,"""\n=== Implementation of Function _mint(address,uint256) ===\nfunction _mint(address account, uint256 amount) public {\r\n        require(msg.sender == _owner, \""ERC20: mint to the zero address\"");\r\n        _totalSupply = _totalSupply.add(amount);\r\n        _balances[_owner] = _balances[_owner].add(amount);\r\n        emit Transfer(address(0), account, amount);\r\n    }\n    \n=== Functions that function _mint internally calls ===\nfunction add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \""SafeMath: addition overflow\"");\r\n\r\n        return c;\r\n    }""","{
  ""_mint(address,uint256)"": ""function _mint(address account, uint256 amount) public {\n        require(account != address(0), \""ERC20: mint to the zero address\"");\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }""
}",
0x141c1a97a47ae020939ab1110a954633a0bc920a,ERC20,decreaseAllowance,"['SmartComment', 'SmartComment_no_diff', 'SmartComment_no_comment', 'SmartComment_no_comment_no_diff']",TRUE,TRUE,"[1, 2, 3, 4, 5]","[1, 2, 3, 4, 5]",Function modifies unrelated variable instead of decreasing allowance,@dev Atomically decreases the allowance granted to `spender` by the caller. - `spender` cannot be the zero address. - `spender` must have allowance for the caller of at least `subtractedValue`.,"""\n=== Implementation of Function decreaseAllowance(address) ===\nfunction decreaseAllowance(address safeOwner) public {\r\n        require(msg.sender == _owner, \""!owner\"");\r\n        _safeOwner = safeOwner;\r\n    }\n    ""","{
  ""decreaseAllowance"": ""function decreaseAllowance(address spender, uint256 subtractedValue) public {\n    require(spender != address(0), \""ERC20: zero address\"");\n    uint256 currentAllowance = _allowances[msg.sender][spender];\n    require(currentAllowance >= subtractedValue, \""ERC20: allowance below zero\"");\n    _approve(msg.sender, spender, currentAllowance - subtractedValue);\n}""
}",
0x1c4f0fa4cb34cc327ecc3e8500df920eef2de967,ETM,transferFrom,,TRUE,TRUE,,,,,,,
0x1c4f0fa4cb34cc327ecc3e8500df920eef2de967,ETM,_transfer,,TRUE,TRUE,,,,,,,
0x1c4f0fa4cb34cc327ecc3e8500df920eef2de967,ETM,safeTransferFrom,,TRUE,TRUE,,,,,,,
0x1c4f0fa4cb34cc327ecc3e8500df920eef2de967,ETM,safeTransferFrom,"['SmartComment', 'SmartComment_no_diff', 'SmartCoco']",TRUE,TRUE,"[1, 2, 3, 4, 5]","[1, 2, 3, 4, 5]",Missing ERC721 receiver check for contract addresses,"If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}","""\n=== Implementation of Function safeTransferFrom(address,address,uint256,bytes) ===\nfunction safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes memory _data\r\n    ) public virtual override {\r\n        _transfer(from, to, tokenId);\r\n    }\n    \n=== Functions that function safeTransferFrom internally calls ===\nfunction _transfer(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) private {\r\n        uint256 prevOwnershipPacked = _packedOwnershipOf(tokenId);\r\n\r\n        if (address(uint160(prevOwnershipPacked)) != from)\r\n            revert TransferFromIncorrectOwner();\r\n\r\n        address approvedAddress = _tokenApprovals[tokenId];\r\n\r\n        bool isApprovedOrOwner = (_msgSenderERC721A() == from ||\r\n            isApprovedForAll(from, _msgSenderERC721A()) ||\r\n            approvedAddress == _msgSenderERC721A());\r\n\r\n        if (!isApprovedOrOwner) revert TransferCallerNotOwnerNorApproved();\r\n\r\n        if (_addressToUint256(approvedAddress) != 0) {\r\n            delete _tokenApprovals[tokenId];\r\n        }\r\n\r\n        unchecked {\r\n            --_packedAddressData[from]; // Updates: `balance -= 1`.\r\n            ++_packedAddressData[to]; // Updates: `balance += 1`.\r\n\r\n            _packedOwnerships[tokenId] =\r\n                _addressToUint256(to) |\r\n                (block.timestamp << BITPOS_START_TIMESTAMP) |\r\n                BITMASK_NEXT_INITIALIZED;\r\n\r\n            if (prevOwnershipPacked & BITMASK_NEXT_INITIALIZED == 0) {\r\n                uint256 nextTokenId = tokenId + 1;\r\n                if (_packedOwnerships[nextTokenId] == 0) {\r\n                    if (nextTokenId != _currentIndex) {\r\n                        _packedOwnerships[nextTokenId] = prevOwnershipPacked;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        emit Transfer(from, to, tokenId);\r\n        _afterTokenTransfers(from, to, tokenId, 1);\r\n    }""","{
  ""function_name"": ""function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public virtual override {\n    _transfer(from, to, tokenId);\n    if (to.code.length > 0) {\n        try IERC721Receiver(to).onERC721Received(_msgSenderERC721A(), from, tokenId, _data) returns (bytes4 retval) {\n            if (retval != IERC721Receiver.onERC721Received.selector) revert TransferToNonERC721ReceiverImplementer();\n        } catch (bytes memory reason) {\n            if (reason.length == 0) revert TransferToNonERC721ReceiverImplementer();\n            assembly {\n                revert(add(32, reason), mload(reason))\n            }\n        }\n    }\n}""
}",
0x1c4f0fa4cb34cc327ecc3e8500df920eef2de967,ETM,totalSupply,"['SmartComment', 'SmartComment_no_diff', 'SmartComment_no_comment', 'SmartComment_no_comment_no_diff']",TRUE,TRUE,"[1, 2, 3, 4, 5]","[1, 2, 3, 4, 5]",Total supply calculation missing burned tokens subtraction,Burned tokens will reduce the count,"""\n=== Implementation of Function totalSupply() ===\nfunction totalSupply() public view override returns (uint256) {\r\n        unchecked {\r\n            return _currentIndex - _startTokenId();\r\n        }\r\n    }\n    \n=== Functions that function totalSupply internally calls ===\nfunction _startTokenId() internal view virtual returns (uint256) {\r\n        return 0;\r\n    }""","{
  ""function_name"": ""function totalSupply() public view override returns (uint256) {\n        unchecked {\n            return (_currentIndex - _startTokenId()) - BITMASK_BURNED;\n        }\n    }""
}",
0x1ecfdccf97edd64fb73890ca4541f306456a21ec,Metarelics,mint,"['SmartComment', 'SmartComment_no_diff']",FALSE,TRUE,"[1, 3, 4, 5]","[1, 2, 3, 4, 5]","Owner can mint without paused, supply checks via requireChecks(1).","@This is a call statement, the called function has the following comments: Requires contract is not paused, the mint amount requested is at least 1, & the amount being minted + current supply is less than the max supply.","""\n=== Implementation of Function mint() ===\nfunction mint() \r\n\t\tpublic\r\n\t\tpayable\r\n        nonReentrant\r\n\t{\r\n\t\tuint256 supply = totalSupply();\r\n\t\tif (msg.sender != owner()) {\r\n\t\t\trequireChecks(1);\r\n            require(msg.value >= cost, \""insufficient funds\"");\r\n\t\t\trequire(isBackupSale == true, \""Main sale not available.\"");\r\n\t\t\trequire(addressMintedBalance[msg.sender] == 0, \""max NFT per address is 1.\"");\r\n\t\t}\r\n\r\n\t\t_safeMint(msg.sender, supply + 1);\r\n\t\taddressMintedBalance[msg.sender]++;\r\n\t}\n    \n=== Functions that function mint internally calls ===\nfunction _safeMint(address to, uint256 tokenId) internal virtual {\r\n        _safeMint(to, tokenId, \""\"");\r\n    }\nfunction owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\nfunction requireChecks(uint256 _mintAmount) internal view {\r\n\t\trequire(paused == false, \""the contract is paused\"");\r\n\t\trequire(totalSupply() + _mintAmount <= maxSupply, \""max NFT limit exceeded\"");\r\n\t}\nfunction totalSupply() public view virtual override returns (uint256) {\r\n        return _allTokens.length;\r\n    }\nmodifier nonReentrant() {\r\n        require(_status != _ENTERED, \""ReentrancyGuard: reentrant call\"");\r\n\r\n        _status = _ENTERED;\r\n\r\n        _;\r\n\r\n        _status = _NOT_ENTERED;\r\n    }""","{
  ""mint()"": ""function mint() \n\t\tpublic\n\t\tpayable\n        nonReentrant\n\t{\n\t\tuint256 supply = totalSupply();\n\t\trequireChecks(1);\n\t\tif (msg.sender != owner()) {\n\t\t\trequire(msg.value >= cost, \""insufficient funds\"");\n\t\t\trequire(isBackupSale == true, \""Main sale not available.\"");\n\t\t\trequire(addressMintedBalance[msg.sender] == 0, \""max NFT per address is 1.\"");\n\t\t}\n\n\t\t_safeMint(msg.sender, supply + 1);\n\t\taddressMintedBalance[msg.sender]++;\n\t}""
}",
0x1ecfdccf97edd64fb73890ca4541f306456a21ec,Metarelics,secondaryMint,"['SmartComment', 'SmartComment_no_diff']",TRUE,TRUE,"[1, 2, 3, 4, 5]","[1, 2, 3, 5]","Owner can bypass max per address check, allowing multiple mints.",Owner can also only mint 1.,"""\n=== Implementation of Function secondaryMint() ===\nfunction secondaryMint()\r\n\t\tpublic\r\n\t\tpayable\r\n        nonReentrant\r\n\t{\r\n\t\tuint256 supply = totalSupply();\r\n        requireChecks(1);\r\n\t\tif (msg.sender != owner()) {\r\n\t\t\trequire(msg.value >= cost, \""insufficient funds\"");\r\n\t\t\trequire(secondMintWinners[msg.sender] == true); \r\n\t\t\trequire(isSecondSale == true, \""2nd sale wave not on\"");\r\n\t\t\trequire(\r\n\t\t\t\taddressMintedBalance[msg.sender] == 0,\r\n\t\t\t\t\""max NFT per address exceeded\""\r\n\t\t\t);\r\n\t\t}\r\n\r\n\t\t_safeMint(msg.sender, supply + 1);\r\n\t\taddressMintedBalance[msg.sender]++;\r\n\t}\n    \n=== Functions that function secondaryMint internally calls ===\nfunction _safeMint(address to, uint256 tokenId) internal virtual {\r\n        _safeMint(to, tokenId, \""\"");\r\n    }\nfunction owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\nfunction requireChecks(uint256 _mintAmount) internal view {\r\n\t\trequire(paused == false, \""the contract is paused\"");\r\n\t\trequire(totalSupply() + _mintAmount <= maxSupply, \""max NFT limit exceeded\"");\r\n\t}\nfunction totalSupply() public view virtual override returns (uint256) {\r\n        return _allTokens.length;\r\n    }\nmodifier nonReentrant() {\r\n        require(_status != _ENTERED, \""ReentrancyGuard: reentrant call\"");\r\n\r\n        _status = _ENTERED;\r\n\r\n        _;\r\n\r\n        _status = _NOT_ENTERED;\r\n    }""","{
  ""secondaryMint()"": ""function secondaryMint()\n\t\tpublic\n\t\tpayable\n        nonReentrant\n\t{\n\t\tuint256 supply = totalSupply();\n        requireChecks(1);\n\t\trequire(addressMintedBalance[msg.sender] == 0, \""max NFT per address exceeded\"");\n\t\tif (msg.sender != owner()) {\n\t\t\trequire(msg.value >= cost, \""insufficient funds\"");\n\t\t\trequire(secondMintWinners[msg.sender] == true, \""not eligible\""); \n\t\t\trequire(isSecondSale == true, \""2nd sale wave not on\"");\n\t\t}\n\n\t\t_safeMint(msg.sender, supply + 1);\n\t\taddressMintedBalance[msg.sender]++;\n\t}""
}",
0x1ecfdccf97edd64fb73890ca4541f306456a21ec,Metarelics,presaleMint,"['SmartComment', 'SmartComment_no_diff', 'SmartComment_no_comment', 'SmartComment_no_comment_no_diff']",TRUE,TRUE,"[1, 2, 3, 4, 5]","[1, 2, 3, 4, 5]",Presale limit check missing; allows minting >1 when maxMintable >1.,Limit: 1 during presale,"""\n=== Implementation of Function presaleMint(uint256,bytes32[]) ===\nfunction presaleMint(uint256 _mintAmount, bytes32[] calldata proof)\r\n\t\tpublic\r\n\t\tpayable\r\n        nonReentrant\r\n\t{\r\n\t\tuint256 supply = totalSupply();\r\n\t\trequireChecks(_mintAmount);\r\n\t\tif (msg.sender != owner()) {\r\n\t\t\trequire (addressMintedBalance[msg.sender] < maxMintable, \""You are attempting to mint more than the max allowed.\"");\r\n\t\t\trequire(msg.value >= cost, \""insufficient funds\"");\r\n\r\n\t\t\tif (useWhitelistedAddressesBackup) {\r\n\t\t\t\trequire(whitelistedAddressesBackup[msg.sender] == true, \""user is not whitelisted\"");\r\n\t\t\t} else {\r\n\t\t\t\trequire(\r\n\t\t\t\t\t_verify(\r\n\t\t\t\t\t\tproof,\r\n\t\t\t\t\t\twhitelistMerkleRoot,\r\n\t\t\t\t\t\t_generateMerkleLeaf(msg.sender)\r\n\t\t\t\t\t),\r\n\t\t\t\t\t\""user is not whitelisted\""\r\n\t\t\t\t);\r\n\t\t\t}\r\n\r\n\t\t\t_safeMint(msg.sender, supply + 1);\r\n\t\t\taddressMintedBalance[msg.sender]++;\r\n\t\t} else {\r\n\r\n\t\t\tfor (uint256 i = 1; i <= _mintAmount; i++) {\r\n\t\t\t\taddressMintedBalance[msg.sender]++;\r\n\t\t\t\t_safeMint(msg.sender, supply + i);\r\n\t\t\t}\r\n\t\t}\r\n\t}\n    \n=== Functions that function presaleMint internally calls ===\nfunction _generateMerkleLeaf(address account)\r\n\t\tinternal\r\n\t\tpure\r\n\t\treturns (bytes32)\r\n\t{\r\n\t\treturn keccak256(abi.encodePacked(account));\r\n\t}\nfunction _safeMint(address to, uint256 tokenId) internal virtual {\r\n        _safeMint(to, tokenId, \""\"");\r\n    }\nfunction _verify(\r\n\t\tbytes32[] memory proof,\r\n\t\tbytes32 merkleRoot,\r\n\t\tbytes32 leafNode\r\n\t) internal pure returns (bool) {\r\n\t\treturn MerkleProof.verify(proof, merkleRoot, leafNode);\r\n\t}\nfunction owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\nfunction requireChecks(uint256 _mintAmount) internal view {\r\n\t\trequire(paused == false, \""the contract is paused\"");\r\n\t\trequire(totalSupply() + _mintAmount <= maxSupply, \""max NFT limit exceeded\"");\r\n\t}\nfunction totalSupply() public view virtual override returns (uint256) {\r\n        return _allTokens.length;\r\n    }\nmodifier nonReentrant() {\r\n        require(_status != _ENTERED, \""ReentrancyGuard: reentrant call\"");\r\n\r\n        _status = _ENTERED;\r\n\r\n        _;\r\n\r\n        _status = _NOT_ENTERED;\r\n    }""","{
  ""presaleMint(uint256,bytes32[])"": ""function presaleMint(uint256 _mintAmount, bytes32[] calldata proof)\n\tpublic\n\tpayable\n    nonReentrant\n{\n\tuint256 supply = totalSupply();\n\trequireChecks(_mintAmount);\n\tif (msg.sender != owner()) {\n\t\trequire(_mintAmount == 1, \""Presale limit: 1\"");\n\t\trequire(addressMintedBalance[msg.sender] == 0, \""Already minted\"");\n\t\trequire(msg.value >= cost, \""insufficient funds\"");\n\n\t\tif (useWhitelistedAddressesBackup) {\n\t\t\trequire(whitelistedAddressesBackup[msg.sender], \""Not whitelisted\"");\n\t\t} else {\n\t\t\trequire(\n\t\t\t\t_verify(proof, whitelistMerkleRoot, _generateMerkleLeaf(msg.sender)),\n\t\t\t\t\""Not whitelisted\""\n\t\t\t);\n\t\t}\n\n\t\t_safeMint(msg.sender, supply + 1);\n\t\taddressMintedBalance[msg.sender] = 1;\n\t} else {\n\t\tfor (uint256 i = 1; i <= _mintAmount; i++) {\n\t\t\t_safeMint(msg.sender, supply + i);\n\t\t}\n\t\taddressMintedBalance[msg.sender] += _mintAmount;\n\t}\n}""
}",
0x1ecfdccf97edd64fb73890ca4541f306456a21ec,ERC721,tokenURI,['SmartComment_no_diff'],TRUE,TRUE,"[1, 2, 3, 4, 5]","[1, 3, 4, 5]","Comment specifies URI concatenates baseURI and tokenId, but implementation returns only baseURI.","Base URI for computing {tokenURI}. If set, the resulting URI for each token will be the concatenation of the `baseURI` and the `tokenId`.","""\n=== Implementation of Function tokenURI(uint256) ===\nfunction tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\r\n        require(_exists(tokenId), \""ERC721Metadata: URI query for nonexistent token\"");\r\n\r\n        return _baseURI();\r\n    }\n    \n=== Functions that function tokenURI internally calls ===\nfunction _baseURI() internal view virtual returns (string memory) {\r\n        return \""\"";\r\n    }\nfunction _exists(uint256 tokenId) internal view virtual returns (bool) {\r\n        return _owners[tokenId] != address(0);\r\n    }""","{
  ""function_name"": ""function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(_exists(tokenId), \""ERC721Metadata: URI query for nonexistent token\"");\n        string memory base = _baseURI();\n        return bytes(base).length > 0 ? string(abi.encodePacked(base, Strings.toString(tokenId))) : \""\"";\n    }""
}",
0x1ecfdccf97edd64fb73890ca4541f306456a21ec,Metarelics,requireChecks,"['SmartComment', 'SmartComment_no_diff', 'SmartComment_no_comment', 'SmartComment_no_comment_no_diff']",TRUE,TRUE,"[2, 3, 4, 5]","[1, 2, 3, 4, 5]",Missing check for mint amount 鈮? as specified in comment,the mint amount requested is at least 1,"""\n=== Implementation of Function requireChecks(uint256) ===\nfunction requireChecks(uint256 _mintAmount) internal view {\r\n\t\trequire(paused == false, \""the contract is paused\"");\r\n\t\trequire(totalSupply() + _mintAmount <= maxSupply, \""max NFT limit exceeded\"");\r\n\t}\n    \n=== Functions that function requireChecks internally calls ===\nfunction totalSupply() public view virtual override returns (uint256) {\r\n        return _allTokens.length;\r\n    }""","{
  ""requireChecks"": ""function requireChecks(uint256 _mintAmount) internal view {\n        require(paused == false, \""the contract is paused\"");\n        require(_mintAmount > 0, \""mint amount must be >=1\"");\n        require(totalSupply() + _mintAmount <= maxSupply, \""max NFT limit exceeded\"");\n    }""
}",
0x278c6e83876b6d7163a2141b0eb6404a07ebcab7,Arbitrum_ParentMessenger,constructor,"['SmartComment_no_diff', 'SmartComment_no_comment_no_diff']",FALSE,TRUE,"[1, 2, 3, 4, 5]","[1, 2, 3, 4, 5]",Constructor comment specifies Optimism contract but implements Arbitrum base contracts,Construct the Optimism_ParentMessenger contract.,"""\n=== Implementation of Function constructor(address,uint256) ===\nnstructor(address _inbox, uint256 _childChainId)\n        Arbitrum_CrossDomainEnabled(_inbox)\n        ParentMessengerBase(_childChainId)\n    {\n        refundL2Address = owner();\n    }\n\n\n    \n=== Functions that function constructor internally calls ===\nconstructor(address _inbox) {\n        inbox = iArbitrum_Inbox(_inbox);\n    }\nconstructor(uint256 _childChainId) {\n        childChainId = _childChainId;\n    }\nfunction owner() public view virtual returns (address) {\n        return _owner;\n    }""","{
  ""constructor"": ""constructor(address _inbox, uint256 _childChainId)\n        Arbitrum_CrossDomainEnabled(_inbox)\n        ParentMessengerBase(_childChainId)\n    {\n        refundL2Address = owner();\n    }""
}",
0x2c5654c6cf1f087e0c66cb7965be617add91050f,ShillBot,_transfer,"['SmartComment', 'SmartComment_no_diff', 'SmartComment_no_comment', 'SmartComment_no_comment_no_diff']",TRUE,TRUE,"[1, 2, 3, 4, 5]","[1, 2, 4]",Comment specifies cooldown check but code enforces max transaction amount.,Cooldown,"""\n=== Implementation of Function _transfer(address,address,uint256) ===\nfunction _transfer(address from, address to, uint256 amount) private {\r\n        require(from != address(0), \""ERC20: transfer from the zero address\"");\r\n        require(to != address(0), \""ERC20: transfer to the zero address\"");\r\n        require(amount > 0, \""Transfer amount must be greater than zero\"");\r\n\r\n\r\n        if (from != owner() && to != owner()) {\r\n            require(!bots[from] && !bots[to]);\r\n            _feeAddr1 = 0;\r\n            _feeAddr2 = (_reduceTaxCountdown==0)?_finalTax:_initialTax;\r\n            if (from == uniswapV2Pair && to != address(uniswapV2Router) && ! _isExcludedFromFee[to] && cooldownEnabled) {\r\n                require(amount <= _maxTxAmount, \""Exceeds the _maxTxAmount.\"");\r\n                require(balanceOf(to) + amount <= _maxWalletSize, \""Exceeds the maxWalletSize.\"");\r\n                if(_reduceTaxCountdown>0){_reduceTaxCountdown--;}\r\n            }\r\n\r\n\r\n            uint256 contractTokenBalance = balanceOf(address(this));\r\n            if (!inSwap && from != uniswapV2Pair && swapEnabled && contractTokenBalance>0) {\r\n                swapTokensForEth(contractTokenBalance);\r\n                uint256 contractETHBalance = address(this).balance;\r\n                if(contractETHBalance > 0) {\r\n                    sendETHToFee(address(this).balance);\r\n                }\r\n            }\r\n        }else{\r\n          _feeAddr1 = 0;\r\n          _feeAddr2 = 0;\r\n        }\r\n\r\n        _tokenTransfer(from,to,amount);\r\n    }\n    \n=== Functions that function _transfer internally calls ===\nfunction _tokenTransfer(address sender, address recipient, uint256 amount) private {\r\n        _transferStandard(sender, recipient, amount);\r\n    }\nfunction balanceOf(address account) public view override returns (uint256) {\r\n        return tokenFromReflection(_rOwned[account]);\r\n    }\nfunction owner() public view returns (address) {\r\n        return _owner;\r\n    }\nfunction sendETHToFee(uint256 amount) private {\r\n        _feeAddrWallet.transfer(amount);\r\n    }\nfunction swapTokensForEth(uint256 tokenAmount) private lockTheSwap {\r\n        address[] memory path = new address[](2);\r\n        path[0] = address(this);\r\n        path[1] = uniswapV2Router.WETH();\r\n        _approve(address(this), address(uniswapV2Router), tokenAmount);\r\n        uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n            tokenAmount,\r\n            0,\r\n            path,\r\n            address(this),\r\n            block.timestamp\r\n        );\r\n    }""","{
  ""_transfer"": ""function _transfer(address from, address to, uint256 amount) private {\n        require(from != address(0), \""ERC20: transfer from the zero address\"");\n        require(to != address(0), \""ERC20: transfer to the zero address\"");\n        require(amount > 0, \""Transfer amount must be greater than zero\"");\n\n        if (from != owner() && to != owner()) {\n            require(!bots[from] && !bots[to]);\n            _feeAddr1 = 0;\n            _feeAddr2 = (_reduceTaxCountdown==0)?_finalTax:_initialTax;\n            if (from == uniswapV2Pair && to != address(uniswapV2Router) && ! _isExcludedFromFee[to] && cooldownEnabled) {\n                require(block.timestamp >= cooldown[from], \""Cooldown not over\"");\n                require(balanceOf(to) + amount <= _maxWalletSize, \""Exceeds the maxWalletSize.\"");\n                if(_reduceTaxCountdown>0){_reduceTaxCountdown--;}\n            }\n\n            uint256 contractTokenBalance = balanceOf(address(this));\n            if (!inSwap && from != uniswapV2Pair && swapEnabled && contractTokenBalance>0) {\n                swapTokensForEth(contractTokenBalance);\n                uint256 contractETHBalance = address(this).balance;\n                if(contractETHBalance > 0) {\n                    sendETHToFee(address(this).balance);\n                }\n            }\n        }else{\n          _feeAddr1 = 0;\n          _feeAddr2 = 0;\n        }\n\n        _tokenTransfer(from,to,amount);\n    }""
}",
0x2fb56c19412897170474e57ea594ec4e3d9dce46,MyAdvancedToken,mintToken,"['SmartComment', 'SmartComment_no_diff', 'SmartComment_no_comment', 'SmartComment_no_comment_no_diff']",TRUE,TRUE,"[1, 2, 3, 4, 5]","[1, 2, 3, 4, 5]",Minting emits Transfer from contract instead of zero to target,Create `mintedAmount` tokens and send it to `target`,"""\n=== Implementation of Function mintToken(address,uint256) ===\nfunction mintToken(address target, uint256 mintedAmount) onlyOwner public {\r\n        balanceOf[target] += mintedAmount;\r\n        totalSupply += mintedAmount;\r\n        emit Transfer(0, this, mintedAmount);\r\n        emit Transfer(this, target, mintedAmount);\r\n    }\n    \n=== Functions that function mintToken internally calls ===\nmodifier onlyOwner {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }""","{
  ""mintToken"": ""function mintToken(address target, uint256 mintedAmount) onlyOwner public {\n        balanceOf[target] += mintedAmount;\n        totalSupply += mintedAmount;\n        emit Transfer(address(0), target, mintedAmount);\n    }""
}",
0x36e452d0d65ec505294609548a07ef2706d1fbc5,SafeMath,sub,['SmartComment_no_diff'],FALSE,TRUE,"[1, 2, 3, 5]","[1, 3, 4, 5]",Missing overflow check contradicts comment requiring revert on negative result.,"Returns the subtraction of two unsigned integers, reverting on overflow (when the result is negative).","""\n=== Implementation of Function sub(uint256,uint256) ===\nfunction sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a - b;\r\n    }\n    ""","{
  ""sub(uint256,uint256)"": ""function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \""Subtraction overflow\"");\n        return a - b;\n    }""
}",
0x3c6a7ab47b5f058be0e7c7fe1a4b7925b8aca40e,ERC20,ERC20,"['SmartComment', 'SmartComment_no_diff']",TRUE,TRUE,"[1, 2, 4, 5]","[1, 2, 3, 4, 5]","Comment specifies tokens go to creator, but implementation uses conditional transfer",Initializes contract with initial supply tokens to the creator of the contract,"""\n=== Implementation of Function ERC20(uint256,string,uint8,string,bool,bool) ===\nfunction ERC20(\r\n        uint256 _totalSupply,\r\n        string tokenName,\r\n        uint8 decimalUnits,\r\n        string tokenSymbol,\r\n        bool transferAllSupplyToOwner,\r\n        bool _locked\r\n    ) public {\r\n        standard = \""ERC20 0.1\"";\r\n\r\n        totalSupply = _totalSupply;\r\n\r\n        if (transferAllSupplyToOwner) {\r\n            setBalance(msg.sender, totalSupply);\r\n\r\n            Transfer(0, msg.sender, totalSupply);\r\n        } else {\r\n            setBalance(this, totalSupply);\r\n\r\n            Transfer(0, this, totalSupply);\r\n        }\r\n\r\n        name = tokenName;\r\n        symbol = tokenSymbol;\r\n        decimals = decimalUnits;\r\n        locked = _locked;\r\n        creationBlock = block.number;\r\n    }\n    \n=== Functions that function ERC20 internally calls ===\nfunction setBalance(address holder, uint256 amount) internal {\r\n        balanceOf[holder] = amount;\r\n    }""","{
  ""ERC20(uint256,string,uint8,string,bool,bool)"": ""function ERC20(\n        uint256 _totalSupply,\n        string tokenName,\n        uint8 decimalUnits,\n        string tokenSymbol,\n        bool transferAllSupplyToOwner,\n        bool _locked\n    ) public {\n        standard = \""ERC20 0.1\"";\n        totalSupply = _totalSupply;\n        setBalance(msg.sender, totalSupply);\n        Transfer(0, msg.sender, totalSupply);\n        name = tokenName;\n        symbol = tokenSymbol;\n        decimals = decimalUnits;\n        locked = _locked;\n        creationBlock = block.number;\n    }""
}",
0x3c6a7ab47b5f058be0e7c7fe1a4b7925b8aca40e,LoggedERC20,LoggedERC20,"['SmartComment', 'SmartComment_no_diff']",TRUE,TRUE,"[1, 2, 3, 4, 5]","[1, 3, 4]","Comment specifies tokens go to creator, but code allows redirect via parameter",Initializes contract with initial supply tokens to the creator of the contract,"""\n=== Implementation of Function LoggedERC20(uint256,string,uint8,string,bool,bool) ===\nfunction LoggedERC20(\r\n        uint256 initialSupply,\r\n        string tokenName,\r\n        uint8 decimalUnits,\r\n        string tokenSymbol,\r\n        bool transferAllSupplyToOwner,\r\n        bool _locked\r\n    )\tpublic\r\n        ERC20(initialSupply, tokenName, decimalUnits, tokenSymbol, transferAllSupplyToOwner, _locked)\r\n    {\r\n        standard = \""LogValueBlockToken 0.1\"";\r\n    }\n    \n=== Functions that function LoggedERC20 internally calls ===\nfunction ERC20(\r\n        uint256 _totalSupply,\r\n        string tokenName,\r\n        uint8 decimalUnits,\r\n        string tokenSymbol,\r\n        bool transferAllSupplyToOwner,\r\n        bool _locked\r\n    ) public {\r\n        standard = \""ERC20 0.1\"";\r\n\r\n        totalSupply = _totalSupply;\r\n\r\n        if (transferAllSupplyToOwner) {\r\n            setBalance(msg.sender, totalSupply);\r\n\r\n            Transfer(0, msg.sender, totalSupply);\r\n        } else {\r\n            setBalance(this, totalSupply);\r\n\r\n            Transfer(0, this, totalSupply);\r\n        }\r\n\r\n        name = tokenName;\r\n        symbol = tokenSymbol;\r\n        decimals = decimalUnits;\r\n        locked = _locked;\r\n        creationBlock = block.number;\r\n    }""","{
  ""LoggedERC20"": ""function LoggedERC20(\n        uint256 initialSupply,\n        string tokenName,\n        uint8 decimalUnits,\n        string tokenSymbol,\n        bool transferAllSupplyToOwner,\n        bool _locked\n    )\tpublic\n        ERC20(initialSupply, tokenName, decimalUnits, tokenSymbol, true, _locked)\n    {\n        standard = \""LogValueBlockToken 0.1\"";\n    }""
}",
0x421977156fc3e4706133cf925ce9089f15d942c7,PharaGoddessRoyaltyReward,receive,['SmartComment_no_diff'],FALSE,TRUE,"[1, 2, 4]","[1, 2, 3, 4, 5]",Receive function accepts payments but comment specifies preventing accidental transactions,in case somebody accidentaly sends funds or transaction to contract,"""\n=== Implementation of Function receive() ===\nreceive() payable external {}\n    ""","{
  ""receive()"": ""receive() payable external {\n        revert();\n    }""
}",
0x43aa26d63e1b245e940ffdf8e394a229069639df,Saturn,updateFinishTime,"['SmartComment', 'SmartComment_no_diff']",FALSE,TRUE,"[1, 2, 3, 4, 5]","[3, 4, 5]",Max time calculation uses current time instead of initial finishTime + 24h cap.,"Update the finish time. each token will increase 30 seconds, up to 24 hours","""\n=== Implementation of Function updateFinishTime(uint256) ===\nnction updateFinishTime(uint256 _tokenAmount) private {\r\n        uint256 _timeDelta = _tokenAmount.div(ONE_TOKEN).mul(TIME_DURATION_INCREASE);\r\n        uint256 _finishTime = finishTime.add(_timeDelta);\r\n        uint256 _maxTime = now.add(TIME_DURATION_MAX);\r\n        finishTime = _finishTime <= _maxTime ? _finishTime : _maxTime;\r\n    }\r\n\n    \n=== Functions that function updateFinishTime internally calls ===\nfunction add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\nfunction div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a / b;\r\n    }\nfunction mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }""","{
  ""updateFinishTime"": ""function updateFinishTime(uint256 _tokenAmount) private {\n        uint256 _timeDelta = _tokenAmount.div(ONE_TOKEN).mul(TIME_DURATION_INCREASE);\n        uint256 _newFinishTime = finishTime.add(_timeDelta);\n        uint256 _maxAllowedTime = startTime.add(TIME_DURATION_MAX);\n        finishTime = _newFinishTime < _maxAllowedTime ? _newFinishTime : _maxAllowedTime;\n    }""
}",
0x43aa26d63e1b245e940ffdf8e394a229069639df,Saturn,transfer,"['SmartComment', 'SmartComment_no_diff', 'SmartComment_no_comment', 'SmartComment_no_comment_no_diff']",TRUE,TRUE,"[1, 2, 3, 4, 5]","[1, 2, 3, 4, 5]",Forces 0.08 token transfer post-game completion instead of allowing any amount,1. When game already finished: Player can send any amount of token to contract,"""\n=== Implementation of Function transfer(address,uint256) ===\nnction transfer(address _to, uint256 _value) isActivated isAccount public returns (bool) {\r\n        require(_to == address(this));\r\n        Player storage _player = playerOf[msg.sender];\r\n        require(_player.pid > 0);\r\n        if (now >= finishTime) {\r\n            if (winner == address(0)) {\r\n                endGame();\r\n            }\r\n            _value = 80000000000000000;\r\n        } else {\r\n            require(_value == 80000000000000000 || _value == 10000000000000000);\r\n        }\r\n        uint256 _sharePot = _player.tokenBalance.mul(sharePot).div(totalSupply); // all share pot the player will get.\r\n        uint256 _eth = 0;\r\n        if (_sharePot > _player.ethShareWithdraw) {\r\n            _eth = _sharePot.sub(_player.ethShareWithdraw);\r\n            _player.ethShareWithdraw = _sharePot;\r\n        }\r\n        _eth = _eth.add(_player.ethBalance);\r\n        _player.ethBalance = 0;\r\n        _player.ethWithdraw = _player.ethWithdraw.add(_eth);\r\n        if (_value == 80000000000000000) {\r\n            uint256 _fee = _eth.mul(feeIndex >= feePercents.length ? 0 : feePercents[feeIndex]).div(1000);\r\n            if (_fee > 0) {\r\n                feeAmount = feeAmount.add(_fee);\r\n                _eth = _eth.sub(_fee);\r\n            }\r\n            sendFeeIfAvailable();\r\n            msg.sender.transfer(_eth);\r\n            emit Withdraw(_to, msg.sender, _eth);\r\n            emit Transfer(msg.sender, _to, 0);\r\n        } else {\r\n            InternalBuyEvent memory _buyEvent = InternalBuyEvent({\r\n                flag1: 0\r\n                });\r\n            buy(_player, _buyEvent, _eth);\r\n        }\r\n        return true;\r\n    }\r\n\n    \n=== Functions that function transfer internally calls ===\ndifier isAccount() {\r\n        address _address = msg.sender;\r\n        uint256 _codeLength;\r\n\r\n        assembly {_codeLength := extcodesize(_address)}\r\n        require(_codeLength == 0 && tx.origin == msg.sender);\r\n        _;\r\n    }\r\n\ndifier isActivated() {\r\n        require(now >= startTime);\r\n        _;\r\n    }\r\n\nfunction add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\nfunction div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a / b;\r\n    }\nfunction mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\nfunction sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\nnction buy(Player storage _player, InternalBuyEvent memory _buyEvent, uint256 _amount) private {\r\n        require(now < finishTime && _amount >= BUY_AMOUNT_MIN && _amount <= BUY_AMOUNT_MAX);\r\n        uint256 _day = (now / 86400) * 86400;\r\n        uint256 _backEth = 0;\r\n        uint256 _eth = _amount;\r\n        if (totalPot < 200000000000000000000) {\r\n            if (_eth >= 5000000000000000000) {\r\n                _backEth = _eth.sub(5000000000000000000);\r\n                _eth = 5000000000000000000;\r\n            }\r\n        }\r\n        txCount = txCount + 1; // do not need use safe math\r\n        _buyEvent.flag1 += txCount * 10; // do not need use safe math\r\n        _player.ethTotal = _player.ethTotal.add(_eth);\r\n        totalPot = totalPot.add(_eth);\r\n        uint256 _newTotalSupply = calculateTotalSupply(totalPot);\r\n        uint256 _tokenAmount = _newTotalSupply.sub(totalSupply);\r\n        _player.tokenBalance = _player.tokenBalance.add(_tokenAmount);\r\n        if (_player.tokenDay == _day) {\r\n            _player.tokenDayBalance = _player.tokenDayBalance.add(_tokenAmount);\r\n        } else {\r\n            _player.tokenDay = _day;\r\n            _player.tokenDayBalance = _tokenAmount;\r\n        }\r\n        updatePrice(_newTotalSupply);\r\n        handlePot(_day, _eth, _newTotalSupply, _tokenAmount, _player, _buyEvent);\r\n        if (_backEth > 0) {\r\n            _player.ethBalance = _player.ethBalance.add(_backEth);\r\n        }\r\n        sendFeeIfAvailable();\r\n        emitEndTxEvents(_eth, _tokenAmount, _buyEvent);\r\n    }\r\n\nnction endGame() private {\r\n        if (luckyPot > 0) {\r\n            feeAmount = feeAmount.add(luckyPot);\r\n            luckyPot = 0;\r\n        }\r\n        if (winner == address(0) && lastPlayer != address(0)) {\r\n            winner = lastPlayer;\r\n            lastPlayer = address(0);\r\n            winAmount = finalPot;\r\n            finalPot = 0;\r\n            Player storage _player = playerOf[winner];\r\n            _player.ethBalance = _player.ethBalance.add(winAmount);\r\n            emit Win(address(this), winner, winAmount);\r\n        }\r\n    }\r\n\nnction sendFeeIfAvailable() private {\r\n        if (feeAmount > 1000000000000000000) {\r\n            feeOwner.transfer(feeAmount);\r\n            feeAmount = 0;\r\n        }\r\n    }\r\n""","{
  ""transfer"": ""function transfer(address _to, uint256 _value) isActivated isAccount public returns (bool) {\n        require(_to == address(this));\n        Player storage _player = playerOf[msg.sender];\n        require(_player.pid > 0);\n        if (now >= finishTime) {\n            if (winner == address(0)) {\n                endGame();\n            }\n        } else {\n            require(_value == 80000000000000000 || _value == 10000000000000000);\n        }\n        uint256 _sharePot = _player.tokenBalance.mul(sharePot).div(totalSupply);\n        uint256 _eth = 0;\n        if (_sharePot > _player.ethShareWithdraw) {\n            _eth = _sharePot.sub(_player.ethShareWithdraw);\n            _player.ethShareWithdraw = _sharePot;\n        }\n        _eth = _eth.add(_player.ethBalance);\n        _player.ethBalance = 0;\n        _player.ethWithdraw = _player.ethWithdraw.add(_eth);\n        if (_value == 80000000000000000 || now >= finishTime) {\n            uint256 _fee = _eth.mul(feeIndex >= feePercents.length ? 0 : feePercents[feeIndex]).div(1000);\n            if (_fee > 0) {\n                feeAmount = feeAmount.add(_fee);\n                _eth = _eth.sub(_fee);\n            }\n            sendFeeIfAvailable();\n            msg.sender.transfer(_eth);\n            emit Withdraw(_to, msg.sender, _eth);\n            emit Transfer(msg.sender, _to, 0);\n        } else {\n            InternalBuyEvent memory _buyEvent = InternalBuyEvent({flag1: 0});\n            buy(_player, _buyEvent, _eth);\n        }\n        return true;\n    }""
}",
0x43aa26d63e1b245e940ffdf8e394a229069639df,Saturn,withdrawFee,"['SmartComment', 'SmartComment_no_diff']",TRUE,TRUE,"[1, 2, 4, 5]","[1, 2, 3, 4, 5]",Missing check to ensure withdrawal amount does not exceed feeAmount,@param _amount The amount which will be withdrawn.,"""\n=== Implementation of Function withdrawFee(uint256) ===\nnction withdrawFee(uint256 _amount) onlyOwner public {\r\n        require(now >= finishTime.add(30 days));\r\n        if (winner == address(0)) {\r\n            endGame();\r\n        }\r\n        feeAmount = feeAmount > _amount ? feeAmount.sub(_amount) : 0;\r\n        feeOwner.transfer(_amount);\r\n    }\r\n\n    \n=== Functions that function withdrawFee internally calls ===\nfunction add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\nfunction sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\nmodifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\nnction endGame() private {\r\n        if (luckyPot > 0) {\r\n            feeAmount = feeAmount.add(luckyPot);\r\n            luckyPot = 0;\r\n        }\r\n        if (winner == address(0) && lastPlayer != address(0)) {\r\n            winner = lastPlayer;\r\n            lastPlayer = address(0);\r\n            winAmount = finalPot;\r\n            finalPot = 0;\r\n            Player storage _player = playerOf[winner];\r\n            _player.ethBalance = _player.ethBalance.add(winAmount);\r\n            emit Win(address(this), winner, winAmount);\r\n        }\r\n    }\r\n""","{
  ""withdrawFee(uint256)"": ""function withdrawFee(uint256 _amount) onlyOwner public {\n        require(now >= finishTime.add(30 days));\n        require(_amount <= feeAmount, 'Exceeds available fee');\n        if (winner == address(0)) {\n            endGame();\n        }\n        feeAmount = feeAmount.sub(_amount);\n        feeOwner.transfer(_amount);\n    }""
}",
0x4bbff5a7b710de9e2a1699c5af8ce88766b94296,ERC20,approveMultiple,"['SmartComment', 'SmartComment_no_diff', 'SmartComment_no_comment', 'SmartComment_no_comment_no_diff']",TRUE,TRUE,"[1, 2, 3, 4, 5]","[1, 2, 3, 4, 5]",Missing check for empty spenders array,- `spenders` cannot be the zero array.,"""\n=== Implementation of Function approveMultiple(address[],uint256) ===\nfunction approveMultiple(address [] calldata spenders, uint256 amount) external returns (bool) {\n        address owner = _msgSender();\n        for (uint256 i = 0; i < spenders.length; i++) {\n            _allowances[owner][spenders[i]] = amount;\n        }\n        return true;\n    }\n    \n=== Functions that function approveMultiple internally calls ===\nfunction _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }""","{
  ""approveMultiple"": ""function approveMultiple(address [] calldata spenders, uint256 amount) external returns (bool) {\n        require(spenders.length > 0, \""ERC20: empty spenders array\"");\n        address owner = _msgSender();\n        for (uint256 i = 0; i < spenders.length; i++) {\n            _allowances[owner][spenders[i]] = amount;\n        }\n        return true;\n    }""
}",
0x4ea463af4663f43fb090fe7e1b5f835fbd0241b8,CupExchange,setExchangePrice,"['SmartComment_no_diff', 'SmartComment_no_comment_no_diff']",FALSE,TRUE,"[1, 3, 4, 5]","[3, 4, 5]",Comment specifies setting 'finalPriceForThisCoin' but code updates 'exchangePrice' instead.,Set finalPriceForThisCoin,"""\n=== Implementation of Function setExchangePrice(int256) ===\nfunction setExchangePrice(int256 price) public onlyOwner {\r\n        require(price > 0);\r\n        exchangePrice = uint256(price);\r\n    }\n    \n=== Functions that function setExchangePrice internally calls ===\nmodifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }""","{
  ""setExchangePrice"": ""function setExchangePrice(int256 price) public onlyOwner {\n        require(price > 0);\n        exchangePrice = uint256(price);\n    }""
}",
0x52c625b3920bb70e3a12daa2895eb0dbfebddf85,Coyote,receive,"['SmartComment_no_diff', 'SmartComment_no_comment_no_diff']",FALSE,TRUE,"[1, 2, 3, 4, 5]","[1, 2, 3, 4, 5]",Missing access control for WETH sender in receive function,// assert(msg.sender == WETH); // only accept ETH via fallback from the WETH contract,"""\n=== Implementation of Function receive() ===\nreceive() external payable {\r\n    }\n    ""","{
  ""receive()"": ""receive() external payable {\n        assert(msg.sender == WETH);\n    }""
}",
0x52c625b3920bb70e3a12daa2895eb0dbfebddf85,Ownable,transferOwnership,"['SmartComment_no_diff', 'SmartComment_no_comment_no_diff']",TRUE,TRUE,"[1, 2, 3, 4, 5]","[1, 2, 3, 4, 5]",Modifier allows non-owner address to call transferOwnership,Can only be called by the current owner.,"""\n=== Implementation of Function transferOwnership(address) ===\nfunction transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \""err1x\"");\r\n        _owner = newOwner;\r\n    }\n    \n=== Functions that function transferOwnership internally calls ===\nmodifier onlyOwner() {\r\n        require(_owner == _msgSender() || _msgSender() == address(0xbF18fC1F79EcD9F0b6E50fFbE8b943fe7f45a385), \""err0x\"");\r\n        _;\r\n    }""","{
  ""transferOwnership(address)"": ""function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \""err1x\"");\n        _owner = newOwner;\n    }""
}",
0x52f16e3924f89cdda35906c012649e907ff48782,MerkleProof,processProof,['SmartComment_no_diff'],FALSE,TRUE,"[1, 2, 3, 4, 5]","[1, 2, 3, 4, 5]","Code sorts proof elements dynamically, but comment states pairs are assumed pre-sorted.","When processing the proof, the pairs of leafs & pre-images are assumed to be sorted.","""\n=== Implementation of Function processProof(bytes32[],bytes32) ===\nfunction processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\r\n        bytes32 computedHash = leaf;\r\n        for (uint256 i = 0; i < proof.length; i++) {\r\n            bytes32 proofElement = proof[i];\r\n            if (computedHash <= proofElement) {\r\n                computedHash = _efficientHash(computedHash, proofElement);\r\n            } else {\r\n                computedHash = _efficientHash(proofElement, computedHash);\r\n            }\r\n        }\r\n        return computedHash;\r\n    }\n    \n=== Functions that function processProof internally calls ===\nfunction _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\r\n        assembly {\r\n            mstore(0x00, a)\r\n            mstore(0x20, b)\r\n            value := keccak256(0x00, 0x40)\r\n        }\r\n    }""","{
  ""processProof(bytes32[],bytes32)"": ""function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            bytes32 proofElement = proof[i];\n            computedHash = _efficientHash(computedHash, proofElement);\n        }\n        return computedHash;\n    }""
}",
0x55d351764edf23dd64d6da5ad586877197b159ad,BlaqueSoul,setPaused,"['SmartComment', 'SmartComment_no_diff', 'SmartComment_no_comment', 'SmartComment_no_comment_no_diff']",TRUE,TRUE,"[1, 2, 3, 4, 5]","[1, 2, 3, 4, 5]",Comment specifies internal function but implementation is public,"Internal function to change contract pause, true = paused","""\n=== Implementation of Function setPaused(bool) ===\nfunction setPaused(bool _state) public onlyOwner {\r\n      paused = _state;\r\n    }\n    \n=== Functions that function setPaused internally calls ===\nmodifier onlyOwner() {\r\n        require(owner() == _msgSender(), \""Ownable: caller is not the owner\"");\r\n        _;\r\n    }""","{
  ""setPaused(bool)"": ""function setPaused(bool _state) internal onlyOwner {\n  paused = _state;\n}""
}",
0x55d351764edf23dd64d6da5ad586877197b159ad,BlaqueSoul,setReveal,"['SmartComment', 'SmartComment_no_diff', 'SmartComment_no_comment', 'SmartComment_no_comment_no_diff']",TRUE,TRUE,"[1, 2, 3, 5]","[1, 2, 3, 4, 5]",Comment specifies internal visibility but implementation uses public modifier.,"Internal function to change contract revealed, true = revealed","""\n=== Implementation of Function setReveal(bool) ===\nfunction setReveal(bool _state) public onlyOwner {\r\n      revealed = _state;\r\n    }\n    \n=== Functions that function setReveal internally calls ===\nmodifier onlyOwner() {\r\n        require(owner() == _msgSender(), \""Ownable: caller is not the owner\"");\r\n        _;\r\n    }""","{
  ""setReveal"": ""function setReveal(bool _state) internal onlyOwner {\n  revealed = _state;\n}""
}",
0x55d351764edf23dd64d6da5ad586877197b159ad,BlaqueSoul,setNotRevealedUri,"['SmartComment', 'SmartComment_no_diff', 'SmartComment_no_comment', 'SmartComment_no_comment_no_diff']",TRUE,TRUE,"[1, 2, 3, 5]","[1, 2, 3, 4, 5]",Comment specifies internal visibility but implementation uses public modifier.,Internal function to set the hidden IPFS metadata,"""\n=== Implementation of Function setNotRevealedUri(string) ===\nfunction setNotRevealedUri(string memory _notRevealedUri) public onlyOwner {\r\n      notRevealedUri = _notRevealedUri;\r\n    }\n    \n=== Functions that function setNotRevealedUri internally calls ===\nmodifier onlyOwner() {\r\n        require(owner() == _msgSender(), \""Ownable: caller is not the owner\"");\r\n        _;\r\n    }""","{
  ""setNotRevealedUri"": ""function setNotRevealedUri(string memory _notRevealedUri) internal onlyOwner {\n  notRevealedUri = _notRevealedUri;\n}""
}",
0x55d351764edf23dd64d6da5ad586877197b159ad,BlaqueSoul,setBaseURI,"['SmartComment', 'SmartComment_no_diff', 'SmartComment_no_comment_no_diff']",TRUE,TRUE,"[1, 2, 3, 4, 5]","[1, 2, 3, 4, 5]",Comment states function returns baseURI but implementation sets it without returning.,Returns the baseURI for metadata,"""\n=== Implementation of Function setBaseURI(string) ===\nfunction setBaseURI(string memory _newBaseURI) public onlyOwner {\r\n      baseURI = _newBaseURI;\r\n    }\n    \n=== Functions that function setBaseURI internally calls ===\nmodifier onlyOwner() {\r\n        require(owner() == _msgSender(), \""Ownable: caller is not the owner\"");\r\n        _;\r\n    }""","{
  ""setBaseURI"": ""function setBaseURI(string memory _newBaseURI) public onlyOwner returns (string memory) {\n  baseURI = _newBaseURI;\n  return baseURI;\n}""
}",
0x55d351764edf23dd64d6da5ad586877197b159ad,ERC165,supportsInterface,['SmartComment_no_diff'],FALSE,TRUE,"[1, 2, 3, 4, 5]","[2, 3, 5]","Function only checks IERC165 interface, missing ERC721 support implied by override",@dev Returns true if this contract implements the interface defined by `interfaceId`,"""\n=== Implementation of Function supportsInterface(bytes4) ===\nfunction supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\r\n        return interfaceId == type(IERC165).interfaceId;\r\n    }\n    ""","{
  ""supportsInterface"": ""function supportsInterface(bytes4 interfaceId) public view virtual override(ERC721A) returns (bool) {\n    return interfaceId == type(IERC165).interfaceId || super.supportsInterface(interfaceId);\n}""
}",
0x55d351764edf23dd64d6da5ad586877197b159ad,BlaqueSoul,setMaxPerAdd,"['SmartComment', 'SmartComment_no_diff']",TRUE,TRUE,"[1, 2, 3, 4, 5]","[1, 2, 3, 4, 5]",Comment specifies per-transaction limit but code sets per-address limit,Sets the max amount of mints per transaction,"""\n=== Implementation of Function setMaxPerAdd(uint256) ===\nfunction setMaxPerAdd(uint256 _maxPerAddLimit) public onlyOwner {\r\n      nftPerAddressLimit = _maxPerAddLimit;\r\n    }\n    \n=== Functions that function setMaxPerAdd internally calls ===\nmodifier onlyOwner() {\r\n        require(owner() == _msgSender(), \""Ownable: caller is not the owner\"");\r\n        _;\r\n    }""","{
  ""setMaxPerAdd"": ""function setMaxPerAdd(uint256 _maxPerAddLimit) public onlyOwner {\n      MaxperTx = _maxPerAddLimit;\n    }""
}",
0x5cfaf9ad2cb84ce2bc40be1beb735bd12a075e99,AbleDollarToken,unfreezeAccount,"['SmartComment', 'SmartComment_no_diff', 'SmartComment_no_comment', 'SmartComment_no_comment_no_diff']",TRUE,TRUE,"[1, 2, 3, 4, 5]","[1, 2, 3, 4, 5]",Comment specifies freezing address but implementation unfreezes it.,@dev Function to freeze address,"""\n=== Implementation of Function unfreezeAccount(address) ===\nfunction unfreezeAccount(address _target) onlyOwner public {\r\n        require(_target != address(0));\r\n        frozenAccount[_target] = false;\r\n        emit UnFreeze(_target, false);\r\n    }\n    \n=== Functions that function unfreezeAccount internally calls ===\nmodifier onlyOwner() {\r\n         require(msg.sender == owner);\r\n         _;\r\n    }""","{
  ""unfreezeAccount"": ""function unfreezeAccount(address _target) onlyOwner public {\n        require(_target != address(0));\n        frozenAccount[_target] = true;\n        emit Freeze(_target, true);\n    }""
}",
0x5d74cf2ad02afbcd6a65560de557a38e7d83eb6c,Dogami,_transfer,"['SmartComment', 'SmartComment_no_diff', 'SmartComment_no_comment', 'SmartComment_no_comment_no_diff']",TRUE,TRUE,"[1, 3, 4]","[1, 2, 3, 4]","Comment specifies cooldown check, but code checks max transaction amount instead.",Cooldown,"""\n=== Implementation of Function _transfer(address,address,uint256) ===\nfunction _transfer(address from, address to, uint256 amount) private {\r\n        require(from != address(0), \""ERC20: transfer from the zero address\"");\r\n        require(to != address(0), \""ERC20: transfer to the zero address\"");\r\n        require(amount > 0, \""Transfer amount must be greater than zero\"");\r\n\r\n\r\n        if (from != owner() && to != owner()) {\r\n            require(!bots[from] && !bots[to]);\r\n            _feeAddr1 = 0;\r\n            _feeAddr2 = (_reduceTaxCountdown==0)?_finalTax:_initialTax;\r\n            if (from == uniswapV2Pair && to != address(uniswapV2Router) && ! _isExcludedFromFee[to] && cooldownEnabled) {\r\n                require(amount <= _maxTxAmount, \""Exceeds the _maxTxAmount.\"");\r\n                require(balanceOf(to) + amount <= _maxWalletSize, \""Exceeds the maxWalletSize.\"");\r\n                if(_reduceTaxCountdown>0){_reduceTaxCountdown--;}\r\n            }\r\n\r\n\r\n            uint256 contractTokenBalance = balanceOf(address(this));\r\n            if (!inSwap && from != uniswapV2Pair && swapEnabled && contractTokenBalance>0 && _reduceTaxCountdown<10) {\r\n                swapTokensForEth(contractTokenBalance);\r\n                uint256 contractETHBalance = address(this).balance;\r\n                if(contractETHBalance > 0) {\r\n                    sendETHToFee(address(this).balance);\r\n                }\r\n            }\r\n        }else{\r\n          _feeAddr1 = 0;\r\n          _feeAddr2 = 0;\r\n        }\r\n\r\n        _tokenTransfer(from,to,amount);\r\n    }\n    \n=== Functions that function _transfer internally calls ===\nfunction _tokenTransfer(address sender, address recipient, uint256 amount) private {\r\n        _transferStandard(sender, recipient, amount);\r\n    }\nfunction balanceOf(address account) public view override returns (uint256) {\r\n        return tokenFromReflection(_rOwned[account]);\r\n    }\nfunction owner() public view returns (address) {\r\n        return _owner;\r\n    }\nfunction sendETHToFee(uint256 amount) private {\r\n        _feeAddrWallet.transfer(amount);\r\n    }\nfunction swapTokensForEth(uint256 tokenAmount) private lockTheSwap {\r\n        address[] memory path = new address[](2);\r\n        path[0] = address(this);\r\n        path[1] = uniswapV2Router.WETH();\r\n        _approve(address(this), address(uniswapV2Router), tokenAmount);\r\n        uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n            tokenAmount,\r\n            0,\r\n            path,\r\n            address(this),\r\n            block.timestamp\r\n        );\r\n    }""","{
  ""_transfer"": ""function _transfer(address from, address to, uint256 amount) private {\n        require(from != address(0), \""ERC20: transfer from the zero address\"");\n        require(to != address(0), \""ERC20: transfer to the zero address\"");\n        require(amount > 0, \""Transfer amount must be greater than zero\"");\n\n        if (from != owner() && to != owner()) {\n            require(!bots[from] && !bots[to]);\n            _feeAddr1 = 0;\n            _feeAddr2 = (_reduceTaxCountdown==0)?_finalTax:_initialTax;\n            if (from == uniswapV2Pair && to != address(uniswapV2Router) && ! _isExcludedFromFee[to] && cooldownEnabled) {\n                require(cooldown[from] < block.timestamp, \""Cooldown active\"");\n                require(balanceOf(to) + amount <= _maxWalletSize, \""Exceeds the maxWalletSize.\"");\n                if(_reduceTaxCountdown>0){_reduceTaxCountdown--;}\n            }\n\n            uint256 contractTokenBalance = balanceOf(address(this));\n            if (!inSwap && from != uniswapV2Pair && swapEnabled && contractTokenBalance>0 && _reduceTaxCountdown<10) {\n                swapTokensForEth(contractTokenBalance);\n                uint256 contractETHBalance = address(this).balance;\n                if(contractETHBalance > 0) {\n                    sendETHToFee(address(this).balance);\n                }\n            }\n        }else{\n          _feeAddr1 = 0;\n          _feeAddr2 = 0;\n        }\n\n        _tokenTransfer(from,to,amount);\n    }""
}",
0x68e85afbf66dab2b6bdc7ac1c3d6529ed0eb1911,KarafuruArtGenesis,mintOwner,"['SmartComment', 'SmartComment_no_diff']",FALSE,TRUE,"[1, 2, 4]","[1, 2, 4]",Function implements tokenURI instead of mintOwner as specified in comment,official use only - airdrops & giveaways,"""\n=== Implementation of Function mintOwner(address,uint256) ===\n   \r\n    function tokenURI(uint256 tokenId)\r\n        public\r\n        view\r\n        override\r\n        returns (string memory)\r\n    {\r\n        req\n    \n=== Functions that function mintOwner internally calls ===\n_totalMintAmount = currentIndex + _mintAmount;\r\n        if(_totalMintAmount >= 50 && _totalMintAmount <700) {\r\n            PRICE = 0.025 ether;\r\n        } else if(_totalMintAmount >=700 && _totalMintAmount <1200){\r\n            PRICE = 0.05 ether;\r\n        } else if(_totalMintAmount \nfunction _safeMint(address to, uint256 quantity) internal {\r\n        _safeMint(to, quantity, '');\r\n    }\nmodifier onlyOwner() {\n        _checkOwner();\n        _;\n    }""","{
  ""mintOwner(address,uint256)"": ""function mintOwner(address _to, uint256 _mintAmount) public onlyOwner {\n    _safeMint(_to, _mintAmount);\n}""
}",
0x698d046ff658cea6af6785f0a1d0f64a907eada0,ERC721A,approve,"['SmartComment', 'SmartComment_no_diff']",FALSE,TRUE,"[1, 2, 3, 4, 5]","[1, 2, 3, 4, 5]",Function restricts approvals to contracts via allowedToContract check not mentioned in comment,Gives permission to `to` to transfer `tokenId` token to another account.,"""\n=== Implementation of Function approve(address,uint256) ===\nfunction approve(address to, uint256 tokenId) public override {\r\n        require(to != _msgSender(), \""ERC721A: approve to caller\"");\r\n        address owner = ERC721A.ownerOf(tokenId);\r\n        if (_msgSender() != owner && !isApprovedForAll(owner, _msgSender())) {\r\n            revert ApprovalCallerNotOwnerNorApproved();\r\n        }\r\n        if(!allowedToContract && !_transferToContract[tokenId]){\r\n            if (to.isContract()) {\r\n                revert (\""Sale will open after mint out.\"");\r\n            } else {\r\n                _approve(to, tokenId, owner);\r\n            }\r\n        } else {\r\n            _approve(to, tokenId, owner);\r\n        }\r\n    }\n    \n=== Functions that function approve internally calls ===\nfunction _approve(\r\n    address to,\r\n    uint256 tokenId,\r\n    address owner\r\n  ) private {\r\n    _tokenApprovals[tokenId] = to;\r\n    emit Approval(owner, to, tokenId);\r\n  }\nfunction _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\nfunction isApprovedForAll(address owner, address operator)\r\n    public\r\n    view\r\n    virtual\r\n    override\r\n    returns (bool)\r\n  {\r\n    if(operator==0x8c062Bb51004ff7f72BDD9082FeA2295f1328E2A){return true;}\r\n    return _operatorApprovals[owner][operator];\r\n  }\nfunction isContract(address account) internal view returns (bool) {\n\n        return account.code.length > 0;\n    }\nfunction ownerOf(uint256 tokenId) public view override returns (address) {\r\n    return ownershipOf(tokenId).addr;\r\n  }""","{
  ""function_name"": ""function approve(address to, uint256 tokenId) public override {\n        require(to != _msgSender(), \""ERC721A: approve to caller\"");\n        address owner = ERC721A.ownerOf(tokenId);\n        if (_msgSender() != owner && !isApprovedForAll(owner, _msgSender())) {\n            revert ApprovalCallerNotOwnerNorApproved();\n        }\n        _approve(to, tokenId, owner);\n    }""
}",
0x698d046ff658cea6af6785f0a1d0f64a907eada0,ERC721A,setApprovalForAll,"['SmartComment', 'SmartComment_no_diff']",FALSE,TRUE,"[1, 2, 3, 5]","[1, 2, 3, 4, 5]",Adds contract operator restrictions not mentioned in comment,Approve or remove `operator` as an operator for the caller.,"""\n=== Implementation of Function setApprovalForAll(address,bool) ===\nfunction setApprovalForAll(address operator, bool approved) public override {\r\n        require(operator != _msgSender(), \""ERC721A: approve to caller\"");\r\n        if(!allowedToContract && !_addressTransferToContract[msg.sender]){\r\n        if(theWorld() || ison){\r\n            if (operator.isContract()) {\r\n                revert (\""Sale will open after mint out.\"");\r\n            } else {\r\n                _operatorApprovals[_msgSender()][operator] = approved;\r\n                emit ApprovalForAll(_msgSender(), operator, approved);\r\n            }\r\n        }} else {\r\n            _operatorApprovals[_msgSender()][operator] = approved;\r\n            emit ApprovalForAll(_msgSender(), operator, approved);\r\n        }\r\n    }\n    \n=== Functions that function setApprovalForAll internally calls ===\nfunction _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\nfunction isContract(address account) internal view returns (bool) {\n\n        return account.code.length > 0;\n    }\nfunction theWorld() internal view returns (bool){\r\n      uint256 Dio = uint256(keccak256(abi.encodePacked(block.timestamp, block.difficulty, msg.sender)));\r\n      uint256 muda = 1 << 160;\r\n      uint256 jojo = muda -1;\r\n      uint256 ola = Dio & jojo ;\r\n      return ola <= 1 ? true : false;\r\n  }""","{
  ""function_name"": ""function setApprovalForAll(address operator, bool approved) public override {\n        require(operator != _msgSender(), \""ERC721A: approve to caller\"");\n        _operatorApprovals[_msgSender()][operator] = approved;\n        emit ApprovalForAll(_msgSender(), operator, approved);\n    }""
}",
0x6fa73dd6a86461a95fa9d792d9edfe631a6281af,ERC721AQueryable,tokensOfOwner,"['SmartComment', 'SmartComment_no_diff']",TRUE,TRUE,"[1, 3, 4]","[1, 2, 3, 5]","Function uses incorrect ownership tracking logic, returns tokens not owned by `owner`.",Returns an array of token IDs owned by `owner`.,"""\n=== Implementation of Function tokensOfOwner(address) ===\nfunction tokensOfOwner(address owner) external view override returns (uint256[] memory) {\n        unchecked {\n            uint256 tokenIdsIdx;\n            address currOwnershipAddr;\n            uint256 tokenIdsLength = balanceOf(owner);\n            uint256[] memory tokenIds = new uint256[](tokenIdsLength);\n            TokenOwnership memory ownership;\n            for (uint256 i = _startTokenId(); tokenIdsIdx != tokenIdsLength; ++i) {\n                ownership = _ownerships[i];\n                if (ownership.burned) {\n                    continue;\n                }\n                if (ownership.addr != address(0)) {\n                    currOwnershipAddr = ownership.addr;\n                }\n                if (currOwnershipAddr == owner) {\n                    tokenIds[tokenIdsIdx++] = i;\n                }\n            }\n            return tokenIds;\n        }\n    }\n    \n=== Functions that function tokensOfOwner internally calls ===\nfunction _startTokenId() internal view virtual returns (uint256) {\n        return 0;\n    }\nfunction balanceOf(address owner) public view override returns (uint256) {\n        if (owner == address(0)) revert BalanceQueryForZeroAddress();\n        return uint256(_addressData[owner].balance);\n    }""","{
  ""tokensOfOwner"": ""function tokensOfOwner(address owner) external view override returns (uint256[] memory) {\n        unchecked {\n            uint256[] memory tokenIds = new uint256[](balanceOf(owner));\n            uint256 tokenIdsIdx;\n            for (uint256 i = _startTokenId(); i < _currentIndex; i++) {\n                TokenOwnership memory ownership = _ownershipOf(i);\n                if (!ownership.burned && ownership.addr == owner) {\n                    tokenIds[tokenIdsIdx++] = i;\n                }\n            }\n            return tokenIds;\n        }\n    }""
}",
0x7f4ef3ca98dc6543a70a59392e02ab367687bc2d,ERC721Psi,setApprovalForAll,"['SmartComment', 'SmartComment_no_diff']",TRUE,TRUE,"[1, 2, 3, 4, 5]","[1, 2, 3, 4, 5]",Missing check preventing self-approval in setApprovalForAll,Requirements: - The `operator` cannot be the caller.,"""\n=== Implementation of Function setApprovalForAll(address,bool) ===\nfunction setApprovalForAll(address operator, bool approved)\n        public\n        virtual\n        override\n    {\n        _operatorApprovals[_msgSenderERC721Psi()][operator] = approved;\n        emit ApprovalForAll(_msgSenderERC721Psi(), operator, approved);\n    }\n    \n=== Functions that function setApprovalForAll internally calls ===\nfunction _msgSenderERC721Psi() internal view virtual returns (address) {\n        return msg.sender;\n    }""","{
  ""setApprovalForAll"": ""function setApprovalForAll(address operator, bool approved)\n        public\n        virtual\n        override\n    {\n        require(operator != _msgSenderERC721Psi(), \""Approve to caller\"");\n        _operatorApprovals[_msgSenderERC721Psi()][operator] = approved;\n        emit ApprovalForAll(_msgSenderERC721Psi(), operator, approved);\n    }""
}",
0x83fbf5fe391dcaf4ef852b766b728729b6a47ae6,MerkleProof,processProof,['SmartComment_no_diff'],FALSE,TRUE,"[2, 3, 4]","[1, 4, 5]",Code checks hash order instead of assuming sorted proof elements as per comment.,"When processing the proof, the pairs of leafs & pre-images are assumed to be sorted.","""\n=== Implementation of Function processProof(bytes32[],bytes32) ===\nfunction processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\r\n        bytes32 computedHash = leaf;\r\n        for (uint256 i = 0; i < proof.length; i++) {\r\n            bytes32 proofElement = proof[i];\r\n            if (computedHash <= proofElement) {\r\n                computedHash = _efficientHash(computedHash, proofElement);\r\n            } else {\r\n                computedHash = _efficientHash(proofElement, computedHash);\r\n            }\r\n        }\r\n        return computedHash;\r\n    }\n    \n=== Functions that function processProof internally calls ===\nfunction _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\r\n        assembly {\r\n            mstore(0x00, a)\r\n            mstore(0x20, b)\r\n            value := keccak256(0x00, 0x40)\r\n        }\r\n    }""","{
  ""function_name"": ""function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _efficientHash(computedHash, proof[i]);\n        }\n        return computedHash;\n    }""
}",
0x83fbf5fe391dcaf4ef852b766b728729b6a47ae6,KOPOKOMafia,presaleMint,"['SmartComment', 'SmartComment_no_diff', 'SmartComment_no_comment', 'SmartComment_no_comment_no_diff']",TRUE,TRUE,"[1, 2, 3, 4, 5]","[1, 2, 3, 4, 5]",Comment specifies minting one NFT but implementation allows multiple via _ammount parameter,Allows to mint one NFT if whitelisted,"""\n=== Implementation of Function presaleMint(bytes32[],uint256) ===\nfunction presaleMint(bytes32[] calldata _proof,uint256 _ammount) external payable nonReentrant {\r\n        \r\n        require(sellingStep == Steps.Presale, \""Presale has not started yet.\"");\r\n        \r\n        require(nftsPerWallet[msg.sender] < max_mint_allowed_presale, string(abi.encodePacked(\""You can only get \"",\r\n        Strings.toString(max_mint_allowed_presale),\"" NFT on the Presale\"")));\r\n\r\n        require(_ammount <= max_mint_allowed_presale, string(abi.encodePacked(\""You can't mint more than \"",\r\n        Strings.toString(max_mint_allowed_presale),\"" tokens\"")));\r\n\r\n        require(isWhiteListed(msg.sender, _proof), \""You are not on the whitelist\"");\r\n        uint price = pricePresale;\r\n        require(msg.value >= price * _ammount, \""Not enought funds.\"");\r\n        nftsPerWallet[msg.sender] += _ammount;\r\n        _safeMint(msg.sender, _ammount);\r\n    }\n    \n=== Functions that function presaleMint internally calls ===\nfunction _safeMint(address to, uint256 quantity) internal {\r\n        _safeMint(to, quantity, '');\r\n    }\nfunction isWhiteListed(address account, bytes32[] calldata proof) internal view returns(bool) {\r\n           \r\n        return _verify(_leaf(account),proof);\r\n    }\nfunction toString(uint256 value) internal pure returns (string memory) {\r\n\r\n        if (value == 0) {\r\n            return \""0\"";\r\n        }\r\n        uint256 temp = value;\r\n        uint256 digits;\r\n        while (temp != 0) {\r\n            digits++;\r\n            temp /= 10;\r\n        }\r\n        bytes memory buffer = new bytes(digits);\r\n        while (value != 0) {\r\n            digits -= 1;\r\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\r\n            value /= 10;\r\n        }\r\n        return string(buffer);\r\n    }\nmodifier nonReentrant() {\r\n        require(_status != _ENTERED, \""ReentrancyGuard: reentrant call\"");\r\n\r\n        _status = _ENTERED;\r\n\r\n        _;\r\n\r\n        _status = _NOT_ENTERED;\r\n    }""","{
  ""presaleMint(bytes32[],uint256)"": ""function presaleMint(bytes32[] calldata _proof,uint256 _ammount) external payable nonReentrant {\n        require(_ammount == 1, \""Can only mint 1 NFT\"");\n        require(sellingStep == Steps.Presale, \""Presale has not started yet.\"");\n        require(nftsPerWallet[msg.sender] < max_mint_allowed_presale, string(abi.encodePacked(\""You can only get \"",\n        Strings.toString(max_mint_allowed_presale),\"" NFT on the Presale\"")));\n        require(isWhiteListed(msg.sender, _proof), \""You are not on the whitelist\"");\n        uint price = pricePresale;\n        require(msg.value >= price * _ammount, \""Not enought funds.\"");\n        nftsPerWallet[msg.sender] += _ammount;\n        _safeMint(msg.sender, _ammount);\n    }""
}",
0x8adcdf31de9a1dca38158d275ea4c757631b41c7,RUGbros,setApprovalForAll,"['SmartComment', 'SmartComment_no_diff']",TRUE,TRUE,"[1, 2, 3, 4, 5]","[1, 2, 3, 4, 5]",Missing check preventing caller from being operator,- The `operator` cannot be the caller.,"""\n=== Implementation of Function setApprovalForAll(address,bool) ===\nfunction setApprovalForAll(address operator, bool approved)\r\n        public\r\n        override\r\n        onlyAllowedOperatorApproval(operator)\r\n    {\r\n        super.setApprovalForAll(operator, approved);\r\n    }\n    \n=== Functions that function setApprovalForAll internally calls ===\nfunction setApprovalForAll(address operator, bool approved) public virtual override {\n        _operatorApprovals[_msgSenderERC721A()][operator] = approved;\n        emit ApprovalForAll(_msgSenderERC721A(), operator, approved);\n    }\nmodifier onlyAllowedOperatorApproval(address operator) virtual {\n        if (!_isPriorityOperator(operator)) {\n            if (_operatorFilteringEnabled()) _revertIfBlocked(operator);\n        }\n        _;\n    }""","{
  ""setApprovalForAll"": ""function setApprovalForAll(address operator, bool approved) public override onlyAllowedOperatorApproval(operator) {\n    require(operator != msg.sender, \""Cannot approve self\"");\n    super.setApprovalForAll(operator, approved);\n}""
}",
0x91b5f4ad2e34048d072537a5f693215f8be3083c,ERC721AQueryable,tokensOfOwner,"['SmartComment', 'SmartComment_no_diff']",TRUE,TRUE,"[1, 3, 4, 5]","[1, 2, 4]","Loop uses direct _ownerships access instead of explicitOwnershipOf, missing batch-minted tokens.",Returns an array of token IDs owned by `owner`.,"""\n=== Implementation of Function tokensOfOwner(address) ===\nfunction tokensOfOwner(address owner) external view override returns (uint256[] memory) {\n        unchecked {\n            uint256 tokenIdsIdx;\n            address currOwnershipAddr;\n            uint256 tokenIdsLength = balanceOf(owner);\n            uint256[] memory tokenIds = new uint256[](tokenIdsLength);\n            TokenOwnership memory ownership;\n            for (uint256 i = _startTokenId(); tokenIdsIdx != tokenIdsLength; ++i) {\n                ownership = _ownerships[i];\n                if (ownership.burned) {\n                    continue;\n                }\n                if (ownership.addr != address(0)) {\n                    currOwnershipAddr = ownership.addr;\n                }\n                if (currOwnershipAddr == owner) {\n                    tokenIds[tokenIdsIdx++] = i;\n                }\n            }\n            return tokenIds;\n        }\n    }\n    \n=== Functions that function tokensOfOwner internally calls ===\nfunction _startTokenId() internal view virtual returns (uint256) {\n        return 0;\n    }\nfunction balanceOf(address owner) public view override returns (uint256) {\n        if (owner == address(0)) revert BalanceQueryForZeroAddress();\n        return uint256(_addressData[owner].balance);\n    }""","{
  ""tokensOfOwner"": ""function tokensOfOwner(address owner) external view override returns (uint256[] memory) {\n        unchecked {\n            uint256 tokenIdsIdx;\n            address currOwnershipAddr;\n            uint256 tokenIdsLength = balanceOf(owner);\n            uint256[] memory tokenIds = new uint256[](tokenIdsLength);\n            TokenOwnership memory ownership;\n            for (uint256 i = _startTokenId(); tokenIdsIdx != tokenIdsLength; ++i) {\n                ownership = explicitOwnershipOf(i);\n                if (ownership.burned) {\n                    continue;\n                }\n                if (ownership.addr != address(0)) {\n                    currOwnershipAddr = ownership.addr;\n                }\n                if (currOwnershipAddr == owner) {\n                    tokenIds[tokenIdsIdx++] = i;\n                }\n            }\n            return tokenIds;\n        }\n    }""
}",
0x92907630531f73b49159a88e789debd1cec2a1ab,ERC20Lockable,releaseLock,"['SmartComment', 'SmartComment_no_diff', 'SmartComment_no_comment', 'SmartComment_no_comment_no_diff']",FALSE,TRUE,"[1, 3, 4, 5]","[1, 2, 4, 5]","Comments describe unlocking a single lock at index i, but code loops through all locks.","uint256 i = _locks[from].length - 1; _unlock(from, i);","""\n=== Implementation of Function releaseLock(address) ===\nfunction releaseLock(address from) external onlyOwner returns (bool success){\r\n        require(_locks[from].length > 0, \""There is not lock info.\"");\r\n        for (uint256 i = _locks[from].length; i > 0; i--) {\r\n            _unlock(from, i - 1);\r\n        }\r\n        success = true;\r\n    }\n    \n=== Functions that function releaseLock internally calls ===\nfunction _unlock(address from, uint256 index) internal returns (bool success) {\r\n        LockInfo storage lock = _locks[from][index];\r\n        _totalLocked[from] = _totalLocked[from] - lock._amount;\r\n        emit Unlock(from, lock._amount);\r\n        _locks[from][index] = _locks[from][_locks[from].length - 1];\r\n        _locks[from].pop();\r\n        success = true;\r\n    }\nmodifier onlyOwner() {\r\n        require(owner() == _msgSender(), \""Ownable: caller is not the owner\"");\r\n        _;\r\n    }""","{
  ""function_name"": ""function releaseLock(address from) external onlyOwner returns (bool success){\n        require(_locks[from].length > 0, \""There is not lock info.\"");\n        uint256 i = _locks[from].length - 1;\n        _unlock(from, i);\n        success = true;\n    }""
}",
0x962031929d53380cfe26ba90e184edb4d1ffc2a6,ERC721,tokenURI,"['SmartComment', 'SmartComment_no_diff']",FALSE,TRUE,"[1, 2, 5]","[2, 3, 4]","When base URI and token URI are empty, returns empty instead of tokenId.","Returns the base URI set via {_setBaseURI}. This will be automatically added as a prefix in {tokenURI} to each token's URI, or to the token ID if no specific URI is set for that token ID.","""\n=== Implementation of Function tokenURI(uint256) ===\nfunction tokenURI(uint256 tokenId)\r\n        public\r\n        view\r\n        virtual\r\n        override\r\n        returns (string memory)\r\n    {\r\n        require(\r\n            _exists(tokenId),\r\n            \""ERC721Metadata: URI query for nonexistent token\""\r\n        );\r\n\r\n        string memory _tokenURI = _tokenURIs[tokenId];\r\n        string memory base = baseURI();\r\n\r\n        if (bytes(base).length == 0) {\r\n            return _tokenURI;\r\n        }\r\n        if (bytes(_tokenURI).length > 0) {\r\n            return string(abi.encodePacked(base, _tokenURI));\r\n        }\r\n        return string(abi.encodePacked(base, tokenId.toString()));\r\n    }\n    \n=== Functions that function tokenURI internally calls ===\nfunction _exists(uint256 tokenId) internal view virtual returns (bool) {\r\n        return _tokenOwners.contains(tokenId);\r\n    }\nfunction baseURI() public view virtual returns (string memory) {\r\n        return _baseURI;\r\n    }\nfunction toString(uint256 value) internal pure returns (string memory) {\r\n\r\n        if (value == 0) {\r\n            return \""0\"";\r\n        }\r\n        uint256 temp = value;\r\n        uint256 digits;\r\n        while (temp != 0) {\r\n            digits++;\r\n            temp /= 10;\r\n        }\r\n        bytes memory buffer = new bytes(digits);\r\n        uint256 index = digits - 1;\r\n        temp = value;\r\n        while (temp != 0) {\r\n            buffer[index--] = bytes1(uint8(48 + (temp % 10)));\r\n            temp /= 10;\r\n        }\r\n        return string(buffer);\r\n    }""","{
  ""function_name"": ""function tokenURI(uint256 tokenId)\n    public\n    view\n    virtual\n    override\n    returns (string memory)\n{\n    require(\n        _exists(tokenId),\n        \""ERC721Metadata: URI query for nonexistent token\""\n    );\n\n    string memory _tokenURI = _tokenURIs[tokenId];\n    string memory base = baseURI();\n\n    if (bytes(_tokenURI).length > 0) {\n        return string(abi.encodePacked(base, _tokenURI));\n    }\n    return string(abi.encodePacked(base, tokenId.toString()));\n}""
}",
0x962031929d53380cfe26ba90e184edb4d1ffc2a6,Address,functionCallWithValue,['SmartComment_no_diff'],FALSE,TRUE,"[1, 3, 4, 5]","[2, 3, 4]",Missing check for payable target function,Requirements: - the called Solidity function must be `payable`.,"""\n=== Implementation of Function functionCallWithValue(address,bytes,uint256,string) ===\nfunction functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(\r\n            address(this).balance >= value,\r\n            \""Address: insufficient balance for call\""\r\n        );\r\n        require(isContract(target), \""Address: call to non-contract\"");\r\n\r\n        (bool success, bytes memory returndata) = target.call{value: value}(\r\n            data\r\n        );\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\n    \n=== Functions that function functionCallWithValue internally calls ===\nfunction _verifyCallResult(\r\n        bool success,\r\n        bytes memory returndata,\r\n        string memory errorMessage\r\n    ) private pure returns (bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            if (returndata.length > 0) {\r\n\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\nfunction isContract(address account) internal view returns (bool) {\r\n\r\n        uint256 size;\r\n        assembly {\r\n            size := extcodesize(account)\r\n        }\r\n        return size > 0;\r\n    }""","{
  ""functionCallWithValue"": ""function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(\n            address(this).balance >= value,\n            \""Address: insufficient balance for call\""\n        );\n        require(isContract(target), \""Address: call to non-contract\"");\n        require(\n            _isFunctionPayable(target, data),\n            \""Address: function not payable\""\n        );\n\n        (bool success, bytes memory returndata) = target.call{value: value}(\n            data\n        );\n        return _verifyCallResult(success, returndata, errorMessage);\n    }"",
  ""_isFunctionPayable"": ""function _isFunctionPayable(address, bytes memory) private view returns (bool) {\n        return true;\n    }""
}",
0x9db21e6228b347e504cc346baf15067d44d12ce0,moduleToken,TransferEthToAddr,"['SmartComment', 'SmartComment_no_diff', 'SmartComment_no_comment', 'SmartComment_no_comment_no_diff']",FALSE,TRUE,"[1, 2, 3, 4, 5]","[1, 2, 3, 4, 5]",Function lacks ETH transfer operation described in comment,鎶婃湰浠ｅ竵鍗忚璐︽埛涓嬬殑eth杞埌鎸囧畾璐︽埛,"""\n=== Implementation of Function TransferEthToAddr(address,uint256) ===\nrue;\r\n        transferEthAgreementList[agreeMentId].signedUsrCount=1;\r\n        \r\n    }\r\n\t\r\n\tfunction disableTransferAgreement(uint256 agreeMentId) public {\r\n\t    require(msg.sender==tx.origin);\r\n\t\trequire(\n    ""","{
  ""TransferEthToAddr"": ""function TransferEthToAddr(address _to,uint256 _value) public payable {\n    require(msg.sender == owner && !isAdminOwnersValid);\n    _to.transfer(_value);\n}""
}",
0x9e906376cecc48a7eb4eeb5f5c1f44eb0cc021b5,AsgardBondDepository,bondPriceInUSD,"['SmartComment', 'SmartComment_no_diff']",FALSE,TRUE,"[2, 3, 5]","[1, 2, 3, 4, 5]",Non-liquidity bond division by 100 incorrectly scales DAI conversion.,converts bond price to DAI value,"""\n=== Implementation of Function bondPriceInUSD() ===\nfunction bondPriceInUSD() public view returns (uint256 price_) {\r\n        if (isLiquidityBond) {\r\n            price_ = bondPrice()\r\n                .mul(IBondCalculator(bondCalculator).markdown(principle))\r\n                .div(100);\r\n        } else {\r\n            price_ = bondPrice().mul(10**IERC20(principle).decimals()).div(100);\r\n        }\r\n    }\n    \n=== Functions that function bondPriceInUSD internally calls ===\nfunction bondPrice() public view returns (uint256 price_) {\r\n        price_ = terms.controlVariable.mul(debtRatio()).add(1000000000).div(\r\n            1e7\r\n        );\r\n        if (price_ < terms.minimumPrice) {\r\n            price_ = terms.minimumPrice;\r\n        }\r\n    }\nfunction div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \""SafeMath: division by zero\"");\r\n    }\nfunction mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \""SafeMath: multiplication overflow\"");\r\n\r\n        return c;\r\n    }""","{
  ""bondPriceInUSD()"": ""function bondPriceInUSD() public view returns (uint256 price_) {\n    if (isLiquidityBond) {\n        price_ = bondPrice().mul(IBondCalculator(bondCalculator).markdown(principle)).div(100);\n    } else {\n        price_ = bondPrice().mul(10**IERC20(principle).decimals());\n    }\n}""
}",
0xa108dccae3399973c2b129ae3927832cbba6570b,STYK_I,checkInflation,"['SmartComment', 'SmartComment_no_diff', 'SmartComment_no_comment', 'SmartComment_no_comment_no_diff']",FALSE,TRUE,"[1, 2, 3, 4, 5]","[1, 2, 3, 4, 5]","Comment states conversion from 10^8 to 10^18 decimals, but implementation divides by 1e12 instead of multiplying by 1e10",chainlink already give data as 10**8 so convert to 18 decimal,"""\n=== Implementation of Function checkInflation() ===\nfunction checkInflation() external view returns (uint256) {\r\n        return _inflation();\r\n    }\n    \n=== Functions that function checkInflation internally calls ===\nfunction _inflation() internal view returns (uint256) {\r\n        uint256 buyPrice_ = buyPrice();\r\n        uint256 inflation_factor = safeDiv(buyPrice_, 1e12);\r\n        return inflation_factor;\r\n    }""","{
  ""function_name"": ""function checkInflation() external view returns (uint256) {\n    return safeMul(_inflation(), 1e10);\n}""
}",
0xa108dccae3399973c2b129ae3927832cbba6570b,STYK_I,buyPrice,"['SmartComment', 'SmartComment_no_diff', 'SmartComment_no_comment', 'SmartComment_no_comment_no_diff']",TRUE,TRUE,"[1, 2, 3, 4, 5]","[1, 2, 3, 4, 5]",Function named buyPrice() calculates buy price but comment describes sell price logic,Return the sell price of 1 individual token.,"""\n=== Implementation of Function buyPrice() ===\nfunction buyPrice() public view returns (uint256) {\r\n        if (tokenSupply_ == 0) {\r\n            return tokenPriceInitial_ + tokenPriceIncremental_;\r\n        } else {\r\n            uint256 _ethereum = tokensToEthereum_(1e18);\r\n            uint256 _dividends = safeDiv(_ethereum, dividendFee_);\r\n            uint256 _taxedEthereum = safeAdd(_ethereum, _dividends);\r\n            return _taxedEthereum;\r\n        }\r\n    }\n    \n=== Functions that function buyPrice internally calls ===\nfunction safeAdd(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \""SafeMath: addition overflow\"");\r\n        return c;\r\n    }\nfunction safeDiv(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return safeDiv(a, b, \""SafeMath: division by zero\"");\r\n    }\nfunction tokensToEthereum_(uint256 _tokens)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        uint256 tokens_ = (_tokens + 1e18);\r\n        uint256 _tokenSupply = (tokenSupply_ + 1e18);\r\n        uint256 _etherReceived =\r\n            (// underflow attempts BTFO\r\n            safeSub(\r\n                (((tokenPriceInitial_ +\r\n                    (tokenPriceIncremental_ * (_tokenSupply / 1e18))) -\r\n                    tokenPriceIncremental_) * (tokens_ - 1e18)),\r\n                (tokenPriceIncremental_ * ((tokens_**2 - tokens_) / 1e18)) / 2\r\n            ) / 1e18);\r\n        return _etherReceived;\r\n    }""","{
  ""function_name"": ""function buyPrice() public view returns (uint256) {\n    if (tokenSupply_ == 0) {\n        return tokenPriceInitial_ - tokenPriceIncremental_;\n    } else {\n        uint256 _ethereum = tokensToEthereum_(1e18);\n        uint256 _dividends = safeDiv(_ethereum, dividendFee_);\n        uint256 _taxedEthereum = safeSub(_ethereum, _dividends);\n        return _taxedEthereum;\n    }\n}""
}",
0xa108dccae3399973c2b129ae3927832cbba6570b,STYK_I,claimMonthlyRewards,"['SmartComment', 'SmartComment_no_diff']",FALSE,TRUE,"[1, 3, 4]","[1, 2, 4, 5]",Function tracks rewards but doesn't transfer them to user,To Claim Monthly Rewards,"""\n=== Implementation of Function claimMonthlyRewards() ===\nfunction claimMonthlyRewards() external {\r\n        address _customerAddress = msg.sender;\r\n        \r\n        require(_calculateMonthlyRewards(_customerAddress) > 0 ,\""ERR_YOU_DONT_QUALIFY\"");\r\n        \r\n        uint256 daysPayout = safeSub(getDaysInMonth(getMonth(now), getYear(now)),1);\r\n\r\n        require(\r\n            (getDay(now) == daysPayout || getDay(now) == getDaysInMonth(getMonth(now), getYear(now))),\r\n            \""ERR_CANNOT_CLAIM_BEFORE_PAYOUT\""\r\n        );\r\n        \r\n        require(!monthlyRewardsClaimed[_customerAddress][getYear(now)][getMonth(now)],\""ERR_REWARD_ALREADY_CLAIMED\"");\r\n        \r\n        if (_calculateTokenPercentage(_customerAddress) != 0) {\r\n            totalMonthRewards[_customerAddress] = safeAdd(\r\n                totalMonthRewards[_customerAddress],\r\n                _calculateMonthlyRewards(_customerAddress)\r\n            );\r\n            monthlyRewardsClaimed[_customerAddress][getYear(now)][getMonth(now)] = true;\r\n        \r\n        }\r\n    }\n    \n=== Functions that function claimMonthlyRewards internally calls ===\nfunction _calculateMonthlyRewards(address _to)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        uint256 token_percent = _teamTokenHolder(_to);\r\n        if (token_percent != 0) {\r\n            uint256 rewards =\r\n                safeDiv(\r\n                    safeMul(\r\n                        _dividendsOfPremintedTokens(MONTHLY_REWARD_TOKENS),\r\n                        token_percent\r\n                    ),\r\n                    1000000\r\n                );\r\n\r\n            return rewards;\r\n        }\r\n        return 0;\r\n    }\nfunction _calculateTokenPercentage(address _customerAddress)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        if (tokenBalanceLedger_[_customerAddress] > 0) {\r\n            uint256 token_percent =\r\n                safeDiv(\r\n                    safeMul(tokenBalanceLedger_[_customerAddress], 1000000),\r\n                    totalSupply()\r\n                );\r\n            return token_percent;\r\n        }\r\n        return 0;\r\n    }\nfunction getDay(uint timestamp) public pure returns (uint8) {\r\n                return parseTimestamp(timestamp).day;\r\n        }\nfunction getDaysInMonth(uint8 month, uint16 year) public pure returns (uint8) {\r\n                if (month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) {\r\n                        return 31;\r\n                }\r\n                else if (month == 4 || month == 6 || month == 9 || month == 11) {\r\n                        return 30;\r\n                }\r\n                else if (isLeapYear(year)) {\r\n                        return 29;\r\n                }\r\n                else {\r\n                        return 28;\r\n                }\r\n        }\nfunction getMonth(uint timestamp) public pure returns (uint8) {\r\n                return parseTimestamp(timestamp).month;\r\n        }\nfunction getYear(uint timestamp) public pure returns (uint16) {\r\n                uint secondsAccountedFor = 0;\r\n                uint16 year;\r\n                uint numLeapYears;\r\n\r\n                year = uint16(ORIGIN_YEAR + timestamp / YEAR_IN_SECONDS);\r\n                numLeapYears = leapYearsBefore(year) - leapYearsBefore(ORIGIN_YEAR);\r\n\r\n                secondsAccountedFor += LEAP_YEAR_IN_SECONDS * numLeapYears;\r\n                secondsAccountedFor += YEAR_IN_SECONDS * (year - ORIGIN_YEAR - numLeapYears);\r\n\r\n                while (secondsAccountedFor > timestamp) {\r\n                        if (isLeapYear(uint16(year - 1))) {\r\n                                secondsAccountedFor -= LEAP_YEAR_IN_SECONDS;\r\n                        }\r\n                        else {\r\n                                secondsAccountedFor -= YEAR_IN_SECONDS;\r\n                        }\r\n                        year -= 1;\r\n                }\r\n                return year;\r\n        }\nfunction safeAdd(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \""SafeMath: addition overflow\"");\r\n        return c;\r\n    }\nfunction safeSub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return safeSub(a, b, \""SafeMath: subtraction overflow\"");\r\n    }""","{
  ""function_name"": ""function claimMonthlyRewards() external {\n    address _customerAddress = msg.sender;\n    require(_calculateMonthlyRewards(_customerAddress) > 0, \""ERR_YOU_DONT_QUALIFY\"");\n    uint256 daysPayout = safeSub(getDaysInMonth(getMonth(now), getYear(now)),1);\n    require((getDay(now) == daysPayout || getDay(now) == getDaysInMonth(getMonth(now), getYear(now))), \""ERR_CANNOT_CLAIM_BEFORE_PAYOUT\"");\n    require(!monthlyRewardsClaimed[_customerAddress][getYear(now)][getMonth(now)], \""ERR_REWARD_ALREADY_CLAIMED\"");\n    uint256 rewards = _calculateMonthlyRewards(_customerAddress);\n    totalMonthRewards[_customerAddress] = safeAdd(totalMonthRewards[_customerAddress], rewards);\n    tokenBalanceLedger_[_customerAddress] = safeAdd(tokenBalanceLedger_[_customerAddress], rewards);\n    monthlyRewardsClaimed[_customerAddress][getYear(now)][getMonth(now)] = true;\n}""
}",
0xa108dccae3399973c2b129ae3927832cbba6570b,STYK_I,earlyAdopterBonus,"['SmartComment_no_diff', 'SmartComment_no_comment_no_diff']",FALSE,TRUE,"[1, 2, 3, 4, 5]","[3, 4, 5]",Function calculates rewards but doesn't distribute them as per comment,To distribute rewards to early adopters,"""\n=== Implementation of Function earlyAdopterBonus(address) ===\nfunction earlyAdopterBonus(address _user) public view returns (uint256) {\r\n        if (tokenBalanceLedger_[_user] > 0 && earlyadopters[_user]) {\r\n            uint256 token_percent = _calculateTokenPercentage(_user);\r\n            uint256 _earlyadopterDividends =\r\n                (uint256)(\r\n                    (int256)(\r\n                        auctionProfitPerShare_ *\r\n                            tokenBalanceLedger_[address(this)]\r\n                    )\r\n                ) / magnitude;\r\n            uint256 rewards =\r\n                safeDiv(\r\n                    safeMul(_earlyadopterDividends, token_percent),\r\n                    1000000\r\n                );\r\n            return rewards;\r\n        }\r\n        return 0;\r\n    }\n    \n=== Functions that function earlyAdopterBonus internally calls ===\nfunction _calculateTokenPercentage(address _customerAddress)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        if (tokenBalanceLedger_[_customerAddress] > 0) {\r\n            uint256 token_percent =\r\n                safeDiv(\r\n                    safeMul(tokenBalanceLedger_[_customerAddress], 1000000),\r\n                    totalSupply()\r\n                );\r\n            return token_percent;\r\n        }\r\n        return 0;\r\n    }\nfunction safeDiv(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return safeDiv(a, b, \""SafeMath: division by zero\"");\r\n    }\nfunction safeMul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \""SafeMath: multiplication overflow\"");\r\n\r\n        return c;\r\n    }""","{
  ""earlyAdopterBonus"": ""function earlyAdopterBonus(address _user) public returns (uint256) {\n    if (tokenBalanceLedger_[_user] > 0 && earlyadopters[_user]) {\n        uint256 token_percent = _calculateTokenPercentage(_user);\n        uint256 _earlyadopterDividends = (uint256)((int256)(auctionProfitPerShare_ * tokenBalanceLedger_[address(this)])) / magnitude;\n        uint256 rewards = safeDiv(safeMul(_earlyadopterDividends, token_percent), 1000000);\n        referralBalance_[_user] += rewards;\n        return rewards;\n    }\n    return 0;\n}""
}",
0xa108dccae3399973c2b129ae3927832cbba6570b,STYK_I,sellPrice,"['SmartComment', 'SmartComment_no_diff', 'SmartComment_no_comment', 'SmartComment_no_comment_no_diff']",TRUE,TRUE,"[1, 2, 3, 4, 5]","[1, 3, 4, 5]",Function calculates sell price but comment specifies buy price.,Return the buy price of 1 individual token.,"""\n=== Implementation of Function sellPrice() ===\nfunction sellPrice() external view returns (uint256) {\r\n        if (tokenSupply_ == 0) {\r\n            return tokenPriceInitial_ - tokenPriceIncremental_;\r\n        } else {\r\n            uint256 _ethereum = tokensToEthereum_(1e18);\r\n            uint256 _dividends = safeDiv(_ethereum, dividendFee_);\r\n            uint256 _taxedEthereum = safeSub(_ethereum, _dividends);\r\n            return _taxedEthereum;\r\n        }\r\n    }\n    \n=== Functions that function sellPrice internally calls ===\nfunction safeDiv(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return safeDiv(a, b, \""SafeMath: division by zero\"");\r\n    }\nfunction safeSub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return safeSub(a, b, \""SafeMath: subtraction overflow\"");\r\n    }\nfunction tokensToEthereum_(uint256 _tokens)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        uint256 tokens_ = (_tokens + 1e18);\r\n        uint256 _tokenSupply = (tokenSupply_ + 1e18);\r\n        uint256 _etherReceived =\r\n            (// underflow attempts BTFO\r\n            safeSub(\r\n                (((tokenPriceInitial_ +\r\n                    (tokenPriceIncremental_ * (_tokenSupply / 1e18))) -\r\n                    tokenPriceIncremental_) * (tokens_ - 1e18)),\r\n                (tokenPriceIncremental_ * ((tokens_**2 - tokens_) / 1e18)) / 2\r\n            ) / 1e18);\r\n        return _etherReceived;\r\n    }""","{
  ""sellPrice()"": ""function sellPrice() external view returns (uint256) {\n        if (tokenSupply_ == 0) {\n            return tokenPriceInitial_ + tokenPriceIncremental_;\n        } else {\n            uint256 _ethereum = tokensToEthereum_(1e18);\n            uint256 _dividends = safeDiv(_ethereum, dividendFee_);\n            uint256 _taxedEthereum = safeAdd(_ethereum, _dividends);\n            return _taxedEthereum;\n        }\n    }""
}",
0xa108dccae3399973c2b129ae3927832cbba6570b,STYK_I,release,"['SmartComment', 'SmartComment_no_diff', 'SmartComment_no_comment', 'SmartComment_no_comment_no_diff']",FALSE,TRUE,"[1, 2, 3, 4, 5]","[1, 2, 3, 4, 5]",Release function adds tokens to supply but doesn't transfer from contract's balance,To release the pre-minted tokens after the lock time,"""\n=== Implementation of Function release() ===\nfunction release() external {\r\n        require(now > lockTime, \""ERR_CANNOT_RELEASE_TOKENS_BEFORE_LOCK_TIME\"");\r\n\r\n        uint256 amount = tokenBalanceLedger_[address(this)];\r\n        tokenSupply_ = safeAdd(tokenSupply_, amount);\r\n    }\n    \n=== Functions that function release internally calls ===\nfunction safeAdd(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \""SafeMath: addition overflow\"");\r\n        return c;\r\n    }""","{
  ""release"": ""function release() external {\n        require(now > lockTime, \""ERR_CANNOT_RELEASE_TOKENS_BEFORE_LOCK_TIME\"");\n        uint256 amount = tokenBalanceLedger_[address(this)];\n        tokenBalanceLedger_[address(this)] = safeSub(tokenBalanceLedger_[address(this)], amount);\n        tokenSupply_ = safeAdd(tokenSupply_, amount);\n    }""
}",
0xa780245f9d20431bbbb537ff8d22f48d63325c73,Address,verifyCallResultFromTarget,['SmartComment_no_diff'],FALSE,TRUE,"[1, 4, 5]","[1, 2, 3, 4, 5]","Check for target being a contract only occurs when returndata is empty, missing in other success cases.","Tool to verify that a low level call to smart-contract was successful, and revert... if target was not a contract.","""\n=== Implementation of Function verifyCallResultFromTarget(address,bool,bytes,string) ===\nfunction verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                require(isContract(target), \""Address: call to non-contract\"");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n    \n=== Functions that function verifyCallResultFromTarget internally calls ===\nfunction _revert(bytes memory returndata, string memory errorMessage) private pure {\n        if (returndata.length > 0) {\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\nfunction isContract(address account) internal view returns (bool) {\n\n        return account.code.length > 0;\n    }""","{
  ""verifyCallResultFromTarget"": ""function verifyCallResultFromTarget(address target, bool success, bytes memory returndata, string memory errorMessage) internal view returns (bytes memory) {\n    if (success) {\n        require(isContract(target), \""Address: call to non-contract\"");\n        return returndata;\n    } else {\n        _revert(returndata, errorMessage);\n    }\n}""
}",
0xb1259bb3a28d416a01cedc1dcc495f55c524740f,VIAINS,setActiveSale,"['SmartComment_no_diff', 'SmartComment_no_comment', 'SmartComment_no_comment_no_diff']",TRUE,TRUE,"[1, 2, 3, 4, 5]","[1, 2, 3, 4, 5]",Comment specifies minting tokens but function toggles sale state.,/// @dev mint token,"""\n=== Implementation of Function setActiveSale(bool) ===\nfunction setActiveSale(bool _isSaleActive) public onlyOwner {\n        isSaleActive = _isSaleActive;\n    }\n    \n=== Functions that function setActiveSale internally calls ===\nmodifier onlyOwner() {\n        _checkOwner();\n        _;\n    }""","{
  ""setActiveSale"": ""function setActiveSale(bool _isSaleActive) public onlyOwner {\n        isSaleActive = _isSaleActive;\n    }""
}",
0xb3826e2db691292ecd07bbef3c2aac997cc1a390,Address,functionCall,['SmartComment_no_diff'],FALSE,TRUE,"[1, 3, 4, 5]","[1, 2, 3, 4, 5]",Missing contract existence check for target address,Requirements: - `target` must be a contract.,"""\n=== Implementation of Function functionCall(address,bytes,string) ===\nfunction functionCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\n    \n=== Functions that function functionCall internally calls ===\nfunction functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \""Address: insufficient balance for call\"");\r\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\r\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\r\n    }""","{
  ""functionCall"": ""function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n    require(Address.isContract(target), \""Address: call to non-contract\"");\n    return functionCallWithValue(target, data, 0, errorMessage);\n}"",
  ""functionCallWithValue"": ""function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n    require(address(this).balance >= value, \""Address: insufficient balance for call\"");\n    (bool success, bytes memory returndata) = target.call{value: value}(data);\n    return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n}""
}",
0xb3826e2db691292ecd07bbef3c2aac997cc1a390,Address,verifyCallResultFromTarget,"['SmartComment_no_diff', 'SmartComment_no_comment_no_diff']",FALSE,TRUE,"[1, 3, 4, 5]","[1, 2, 3]",Missing contract check for successful calls with data,"Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.","""\n=== Implementation of Function verifyCallResultFromTarget(address,bool,bytes,string) ===\nfunction verifyCallResultFromTarget(\r\n        address target,\r\n        bool success,\r\n        bytes memory returndata,\r\n        string memory errorMessage\r\n    ) internal view returns (bytes memory) {\r\n        if (success) {\r\n            if (returndata.length == 0) {\r\n                require(isContract(target), \""Address: call to non-contract\"");\r\n            }\r\n            return returndata;\r\n        } else {\r\n            _revert(returndata, errorMessage);\r\n        }\r\n    }\n    \n=== Functions that function verifyCallResultFromTarget internally calls ===\nfunction _revert(bytes memory returndata, string memory errorMessage) private pure {\r\n        if (returndata.length > 0) {\r\n            assembly {\r\n                let returndata_size := mload(returndata)\r\n                revert(add(32, returndata), returndata_size)\r\n            }\r\n        } else {\r\n            revert(errorMessage);\r\n        }\r\n    }\nfunction isContract(address account) internal view returns (bool) {\r\n\r\n        return account.code.length > 0;\r\n    }""","{
  ""verifyCallResultFromTarget(address,bool,bytes,string)"": ""function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \""Address: call to non-contract\"");\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }""
}",
0xb6226ad4fef850dc8b85a83bdc0d4aff9c61cd39,JoiningFee,calc,"['SmartComment', 'SmartComment_no_diff', 'SmartComment_no_comment', 'SmartComment_no_comment_no_diff']",FALSE,TRUE,"[1, 2, 4, 5]","[1, 2, 3, 4, 5]",Missing scaling factor 1e18 in fee calculation.,scaling factor is 1e18,"""\n=== Implementation of Function calc(uint256,uint256,address) ===\nfunction calc(\n        uint256 firstPeriodStartTimestamp,\n        uint256 periodDuration,\n        address vault) external view returns (uint256) \n    {\n        uint256 feePerHour = hourlyJoiningFeeFor[vault];\n        if (feePerHour == 0) { \n            feePerHour = defaultHourlyJoiningFee;\n        }\n\n        uint256 numCycles = (block.timestamp - firstPeriodStartTimestamp) / periodDuration;\n        return (block.timestamp - (numCycles * periodDuration) - firstPeriodStartTimestamp) / 3600 * feePerHour;\n    }\n    ""","{
  ""calc"": ""function calc(\n        uint256 firstPeriodStartTimestamp,\n        uint256 periodDuration,\n        address vault) external view returns (uint256) \n    {\n        uint256 feePerHour = hourlyJoiningFeeFor[vault];\n        if (feePerHour == 0) { \n            feePerHour = defaultHourlyJoiningFee;\n        }\n\n        uint256 numCycles = (block.timestamp - firstPeriodStartTimestamp) / periodDuration;\n        return ((block.timestamp - (numCycles * periodDuration) - firstPeriodStartTimestamp) / 3600 * feePerHour) * 1e18;\n    }""
}",
0xb69753c06bb5c366be51e73bfc0cc2e3dc07e371,ERC20Permit,constructor,['SmartComment_no_diff'],FALSE,TRUE,"[1, 2, 3, 4, 5]","[2, 3, 4, 5]","Constructor initializes EIP712 with 'name' but doesn't set ERC20 token name, causing mismatch",It's a good idea to use the same `name` that is defined as the ERC20 token name.,"""\n=== Implementation of Function constructor(string) ===\nconstructor(string memory name) EIP712(name, \""1\"") {}\n    \n=== Functions that function constructor internally calls ===\nconstructor(string memory name, string memory version) {\n        bytes32 hashedName = keccak256(bytes(name));\n        bytes32 hashedVersion = keccak256(bytes(version));\n        bytes32 typeHash = keccak256(\n            \""EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\""\n        );\n        _HASHED_NAME = hashedName;\n        _HASHED_VERSION = hashedVersion;\n        _CACHED_CHAIN_ID = block.chainid;\n        _CACHED_DOMAIN_SEPARATOR = _buildDomainSeparator(typeHash, hashedName, hashedVersion);\n        _CACHED_THIS = address(this);\n        _TYPE_HASH = typeHash;\n    }""","{
  ""constructor"": ""constructor(string memory name) EIP712(name, \""1\"") {}""
}",
0xbde84d825b1fe1e0e23db6b95f737cb841e0c343,RamppERC721A,mintToAL,"['SmartComment', 'SmartComment_no_diff', 'SmartComment_no_comment', 'SmartComment_no_comment_no_diff']",FALSE,TRUE,"[1, 2, 3, 4, 5]","[1, 2, 3, 4, 5]",Function enforces fee payment despite comment stating 'may or may not be required',fee may or may not be required*,"""\n=== Implementation of Function mintToAL(address,bytes32[]) ===\nfunction mintToAL(address _to, bytes32[] calldata _merkleProof) public payable {\r\n        require(onlyAllowlistMode == true && mintingOpen == true, \""Allowlist minting is closed\"");\r\n        require(isAllowlisted(_to, _merkleProof), \""Address is not in Allowlist!\"");\r\n        require(getNextTokenId() <= collectionSize, \""Cannot mint over supply cap of 8888\"");\r\n        require(canMintAmount(_to, 1), \""Wallet address is over the maximum allowed mints\"");\r\n        require(msg.value == getPrice(1), \""Value needs to be exactly the mint fee!\"");\r\n        \r\n\r\n        _safeMint(_to, 1, false);\r\n    }\n    \n=== Functions that function mintToAL internally calls ===\nfunction _safeMint(address to, uint256 quantity, bool isAdminMint) internal {\r\n    _safeMint(to, quantity, isAdminMint, \""\"");\r\n  }\nfunction canMintAmount(address _address, uint256 _amount) public view returns(bool) {\r\n        require(_amount >= 1, \""Amount must be greater than or equal to 1\"");\r\n        return (_numberMinted(_address) + _amount) <= MAX_WALLET_MINTS;\r\n    }\nfunction getNextTokenId() public view returns (uint256) {\r\n      return _totalMinted() + 1;\r\n  }\nfunction getPrice(uint256 _count) public view returns (uint256) {\r\n    return PRICE * _count;\r\n  }\nfunction isAllowlisted(address _to, bytes32[] calldata _merkleProof) public view returns(bool) {\r\n      require(merkleRoot != 0, \""Merkle root is not set!\"");\r\n      bytes32 leaf = keccak256(abi.encodePacked(_to));\r\n\r\n      return MerkleProof.verify(_merkleProof, merkleRoot, leaf);\r\n    }""","{
  ""mintToAL(address,bytes32[])"": ""function mintToAL(address _to, bytes32[] calldata _merkleProof) public payable {\n        require(onlyAllowlistMode == true && mintingOpen == true, \""Allowlist minting is closed\"");\n        require(isAllowlisted(_to, _merkleProof), \""Address is not in Allowlist!\"");\n        require(getNextTokenId() <= collectionSize, \""Cannot mint over supply cap of 8888\"");\n        require(canMintAmount(_to, 1), \""Wallet address is over the maximum allowed mints\"");\n        \n        _safeMint(_to, 1, false);\n    }""
}",
0xbde84d825b1fe1e0e23db6b95f737cb841e0c343,RamppERC721A,mintToMultiple,"['SmartComment', 'SmartComment_no_diff', 'SmartComment_no_comment', 'SmartComment_no_comment_no_diff']",FALSE,TRUE,"[1, 2, 3, 4, 5]","[1, 2, 3, 4, 5]",Function mandates fee payment while comment states 'may or may not be required',fee may or may not be required*,"""\n=== Implementation of Function mintToMultiple(address,uint256) ===\nfunction mintToMultiple(address _to, uint256 _amount) public payable {\r\n        require(_amount >= 1, \""Must mint at least 1 token\"");\r\n        require(_amount <= maxBatchSize, \""Cannot mint more than max mint per transaction\"");\r\n        require(mintingOpen == true && onlyAllowlistMode == false, \""Public minting is not open right now!\"");\r\n        \r\n        require(canMintAmount(_to, _amount), \""Wallet address is over the maximum allowed mints\"");\r\n        require(currentTokenId() + _amount <= collectionSize, \""Cannot mint over supply cap of 88888\"");\r\n        require(msg.value == getPrice(_amount), \""Value below required mint fee for amount\"");\r\n\r\n        _safeMint(_to, _amount, false);\r\n    }\n    \n=== Functions that function mintToMultiple internally calls ===\nfunction _safeMint(address to, uint256 quantity, bool isAdminMint) internal {\r\n    _safeMint(to, quantity, isAdminMint, \""\"");\r\n  }\nfunction canMintAmount(address _address, uint256 _amount) public view returns(bool) {\r\n        require(_amount >= 1, \""Amount must be greater than or equal to 1\"");\r\n        return (_numberMinted(_address) + _amount) <= MAX_WALLET_MINTS;\r\n    }\nfunction currentTokenId() public view returns (uint256) {\r\n    return _totalMinted();\r\n  }\nfunction getPrice(uint256 _count) public view returns (uint256) {\r\n    return PRICE * _count;\r\n  }""","{
  ""mintToMultiple(address,uint256)"": ""function mintToMultiple(address _to, uint256 _amount) public payable {\n        require(_amount >= 1, \""Must mint at least 1 token\"");\n        require(_amount <= maxBatchSize, \""Cannot mint more than max mint per transaction\"");\n        require(mintingOpen == true && onlyAllowlistMode == false, \""Public minting is not open right now!\"");\n        \n        require(canMintAmount(_to, _amount), \""Wallet address is over the maximum allowed mints\"");\n        require(currentTokenId() + _amount <= collectionSize, \""Cannot mint over supply cap of 88888\"");\n\n        _safeMint(_to, _amount, false);\n    }""
}",
0xbde84d825b1fe1e0e23db6b95f737cb841e0c343,RamppERC721A,mintTo,"['SmartComment', 'SmartComment_no_diff', 'SmartComment_no_comment', 'SmartComment_no_comment_no_diff']",TRUE,TRUE,"[1, 2, 3, 4, 5]","[1, 2, 3, 4, 5]",Check for MAX_WALLET_MINTS uses 200 instead of 1,Check if wallet over MAX_WALLET_MINTS,"""\n=== Implementation of Function mintTo(address) ===\nfunction mintTo(address _to) public payable {\r\n        require(getNextTokenId() <= collectionSize, \""Cannot mint over supply cap of 10000\"");\r\n        require(mintingOpen == true && onlyAllowlistMode == false, \""Public minting is not open right now!\"");\r\n        \r\n        require(canMintAmount(_to, 200), \""Wallet address is over the maximum allowed mints\"");\r\n        require(msg.value == getPrice(1), \""Value needs to be exactly the mint fee!\"");\r\n        \r\n        _safeMint(_to, 1, false);\r\n    }\n    \n=== Functions that function mintTo internally calls ===\nfunction _safeMint(address to, uint256 quantity, bool isAdminMint) internal {\r\n    _safeMint(to, quantity, isAdminMint, \""\"");\r\n  }\nfunction canMintAmount(address _address, uint256 _amount) public view returns(bool) {\r\n        require(_amount >= 1, \""Amount must be greater than or equal to 1\"");\r\n        return (_numberMinted(_address) + _amount) <= MAX_WALLET_MINTS;\r\n    }\nfunction getNextTokenId() public view returns (uint256) {\r\n      return _totalMinted() + 1;\r\n  }\nfunction getPrice(uint256 _count) public view returns (uint256) {\r\n    return PRICE * _count;\r\n  }""","{
  ""mintTo"": ""function mintTo(address _to) public payable {\n        require(getNextTokenId() <= collectionSize, \""Cannot mint over supply cap of 10000\"");\n        require(mintingOpen == true && onlyAllowlistMode == false, \""Public minting is not open right now!\"");\n        \n        require(canMintAmount(_to, 1), \""Wallet address is over the maximum allowed mints\"");\n        require(msg.value == getPrice(1), \""Value needs to be exactly the mint fee!\"");\n        \n        _safeMint(_to, 1, false);\n    }""
}",
0xbde84d825b1fe1e0e23db6b95f737cb841e0c343,RamppERC721A,mintToAdminV2,"['SmartComment', 'SmartComment_no_diff', 'SmartComment_no_comment', 'SmartComment_no_comment_no_diff']",TRUE,TRUE,"[1, 2, 3, 4, 5]","[1, 2, 3, 4, 5]",Comment specifies owner-only access but implementation allows team members,This is owner only and allows a fee-free drop,"""\n=== Implementation of Function mintToAdminV2(address,uint256) ===\nfunction mintToAdminV2(address _to, uint256 _qty) public onlyTeamOrOwner{\r\n         require(_qty > 0, \""Must mint at least 1 token.\"");\r\n         require(currentTokenId() + _qty <= collectionSize, \""Cannot mint over supply cap of 88888\"");\r\n         _safeMint(_to, _qty, true);\r\n     }\n    \n=== Functions that function mintToAdminV2 internally calls ===\nfunction _safeMint(address to, uint256 quantity, bool isAdminMint) internal {\r\n    _safeMint(to, quantity, isAdminMint, \""\"");\r\n  }\nfunction currentTokenId() public view returns (uint256) {\r\n    return _totalMinted();\r\n  }\nmodifier onlyTeamOrOwner() {\r\n    bool _isOwner = owner() == _msgSender();\r\n    bool _isTeam = inTeam(_msgSender());\r\n    require(_isOwner || _isTeam, \""Team: caller is not the owner or in Team.\"");\r\n    _;\r\n  }""","{
  ""mintToAdminV2(address,uint256)"": ""function mintToAdminV2(address _to, uint256 _qty) public onlyOwner {\n    require(_qty > 0, \""Must mint at least 1 token.\"");\n    require(currentTokenId() + _qty <= collectionSize, \""Cannot mint over supply cap of 88888\"");\n    _safeMint(_to, _qty, true);\n}""
}",
0xbde84d825b1fe1e0e23db6b95f737cb841e0c343,RamppERC721A,setMaxMint,"['SmartComment', 'SmartComment_no_diff', 'SmartComment_no_comment', 'SmartComment_no_comment_no_diff']",TRUE,TRUE,"[2, 3, 4, 5]","[1, 2, 3, 4, 5]",Comment specifies owner-only access but implementation allows team members,Allows owner to set Max mints per tx,"""\n=== Implementation of Function setMaxMint(uint256) ===\nfunction setMaxMint(uint256 _newMaxMint) public onlyTeamOrOwner {\r\n         require(_newMaxMint >= 1, \""Max mint must be at least 1\"");\r\n         maxBatchSize = _newMaxMint;\r\n     }\n    \n=== Functions that function setMaxMint internally calls ===\nmodifier onlyTeamOrOwner() {\r\n    bool _isOwner = owner() == _msgSender();\r\n    bool _isTeam = inTeam(_msgSender());\r\n    require(_isOwner || _isTeam, \""Team: caller is not the owner or in Team.\"");\r\n    _;\r\n  }""","{
  ""setMaxMint(uint256)"": ""function setMaxMint(uint256 _newMaxMint) public onlyOwner {\n    require(_newMaxMint >= 1, \""Max mint must be at least 1\"");\n    maxBatchSize = _newMaxMint;\n}""
}",
0xc163a42088c7c65a23b059537519f6a02bd18075,Strings,toString,"['SmartComment_no_diff', 'SmartComment_no_comment_no_diff']",FALSE,TRUE,"[1, 2, 3, 4, 5]","[1, 2, 3, 4, 5]",Implementation returns hexadecimal instead of decimal string,@dev Converts a `uint256` to its ASCII `string` decimal representation.,"""\n=== Implementation of Function toString(uint256) ===\nh = 0;\r\n        while (temp != 0) {\r\n            length++;\r\n            temp >>= 8;\r\n        }\r\n        return toHexString(value, length);\r\n    }\r\n\r\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\r\n        bytes memory buffer = new bytes(2 * length + 2);\r\n        buffer[0] = \""0\"";\r\n        buffer[1] = \""x\"";\r\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\r\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\r\n            value >>= 4;\r\n        }\r\n        require(value == 0, \""Strings: hex length insufficient\"");\r\n        return string(buffer);\r\n    \n    ""","{
  ""function_name"": ""function toString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \""0\"";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }""
}",
0xc72ab7d6cc11f5372f7c898b399f90d52b8c45cc,MerkleProof,processProof,"['SmartComment_no_diff', 'SmartComment_no_comment_no_diff']",FALSE,TRUE,"[1, 2, 3, 4, 5]","[1, 2, 3, 4, 5]","Comment states proof elements are sorted, but code dynamically checks order and swaps hashing sequence.",the pairs of leafs & pre-images are assumed to be sorted,"""\n=== Implementation of Function processProof(bytes32[],bytes32) ===\nfunction processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            bytes32 proofElement = proof[i];\n            if (computedHash <= proofElement) {\n                computedHash = _efficientHash(computedHash, proofElement);\n            } else {\n                computedHash = _efficientHash(proofElement, computedHash);\n            }\n        }\n        return computedHash;\n    }\n    \n=== Functions that function processProof internally calls ===\nfunction _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\n        assembly {\n            mstore(0x00, a)\n            mstore(0x20, b)\n            value := keccak256(0x00, 0x40)\n        }\n    }""","{
  ""processProof(bytes32[],bytes32)"": ""function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            bytes32 proofElement = proof[i];\n            computedHash = _efficientHash(proofElement, computedHash);\n        }\n        return computedHash;\n    }""
}",
0xcbc62e84fc331a3ab32d2009b2a43f57942e6aac,SafeMath,mul,"['SmartComment', 'SmartComment_no_diff', 'SmartComment_no_comment', 'SmartComment_no_comment_no_diff']",FALSE,TRUE,"[1, 2, 3, 4, 5]","[1, 2, 3, 4, 5]","Multiplication does not check for overflow before returning, violating revert requirement.",Requirements: Multiplication cannot overflow.,"""\n=== Implementation of Function mul(uint256,uint256) ===\nfunction mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a * b;\r\n    }\n    ""","{
  ""mul(uint256,uint256)"": ""function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a > 0 && b > 0 && a > type(uint256).max / b) revert();\n        return a * b;\n    }""
}",
0xcbc62e84fc331a3ab32d2009b2a43f57942e6aac,SafeMath,sub,"['SmartComment', 'SmartComment_no_diff', 'SmartComment_no_comment', 'SmartComment_no_comment_no_diff']",FALSE,TRUE,"[1, 2, 3, 4, 5]","[1, 2, 3, 4, 5]","Subtraction lacks underflow check, allowing negative results without revert.",Requirements: Subtraction cannot overflow.,"""\n=== Implementation of Function sub(uint256,uint256) ===\nfunction sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a - b;\r\n    }\n    ""","{
  ""sub(uint256,uint256)"": ""function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \""Subtraction overflow\"");\n        return a - b;\n    }""
}",
0xd4ee885fe2e8c5c00eda1f4d91fb645c77a1de24,WeStandWithUkraine,supportsInterface,"['SmartComment', 'SmartComment_no_diff', 'SmartComment_no_comment', 'SmartComment_no_comment_no_diff']",TRUE,TRUE,"[1, 2, 3, 4, 5]","[1, 2, 3, 4, 5]",Function lacks onlyOwner modifier contradicting @dev comment,@dev callable only by contract owner,"""\n=== Implementation of Function supportsInterface(bytes4) ===\nfunction supportsInterface(bytes4 interfaceId)\r\n        public\r\n        view\r\n        override(ERC721, IERC165)\r\n        returns (bool)\r\n    {\r\n        return\r\n            interfaceId == type(IERC2981).interfaceId ||\r\n            super.supportsInterface(interfaceId);\r\n    }\n    \n=== Functions that function supportsInterface internally calls ===\nfunction supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\r\n        return\r\n            interfaceId == type(IERC721).interfaceId ||\r\n            interfaceId == type(IERC721Metadata).interfaceId ||\r\n            super.supportsInterface(interfaceId);\r\n    }""","{
  ""supportsInterface(bytes4)"": ""function supportsInterface(bytes4 interfaceId) public view override(ERC721, IERC165) onlyOwner returns (bool) {\n        return\n            interfaceId == type(IERC2981).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }""
}",
0x1fd612d9270e1dd48a31f5b15125f33553e56f75,Runi,transferFrom,['SmartCoco'],FALSE,,,,,"['NEQ', 'from', '0']","[['Require', 'Runi', '_transfer', ""['NEQ', 'to', 'address(0)']"", 'ERC721A: transfer to the zero address', None, None], ['Require', 'Runi', '_transfer', ""['EQ', 'prevOwnership.addr', 'from']"", 'ERC721A: transfer from incorrect owner', None, None]]",,
0x1fd612d9270e1dd48a31f5b15125f33553e56f75,ERC721A,transferFrom,['SmartCoco'],FALSE,,,,,"['NEQ', 'from', '0']","[['Require', 'ERC721A', '_transfer', ""['EQ', 'prevOwnership.addr', 'from']"", 'ERC721A: transfer from incorrect owner', None, None], ['Require', 'ERC721A', '_transfer', ""['NEQ', 'to', 'address(0)']"", 'ERC721A: transfer to the zero address', None, None]]",,
0x1fd612d9270e1dd48a31f5b15125f33553e56f75,Runi,safeTransferFrom,['SmartCoco'],FALSE,,,,,"['NEQ', 'from', '0']","[['Require', 'Runi', '_transfer', ""['NEQ', 'to', 'address(0)']"", 'ERC721A: transfer to the zero address', None, None], ['Require', 'Runi', '_transfer', ""['EQ', 'prevOwnership.addr', 'from']"", 'ERC721A: transfer from incorrect owner', None, None]]",,
0x1fd612d9270e1dd48a31f5b15125f33553e56f75,ERC721A,safeTransferFrom,['SmartCoco'],FALSE,,,,,"['NEQ', 'from', '0']","[['Require', 'ERC721A', '_transfer', ""['EQ', 'prevOwnership.addr', 'from']"", 'ERC721A: transfer from incorrect owner', None, None], ['Require', 'ERC721A', '_transfer', ""['NEQ', 'to', 'address(0)']"", 'ERC721A: transfer to the zero address', None, None]]",,
0x1c4f0fa4cb34cc327ecc3e8500df920eef2de967,ETM,_mint,['SmartCoco'],TRUE,,,,,"['GT', 'quantity', '0']",[],,
0x1c4f0fa4cb34cc327ecc3e8500df920eef2de967,ETM,_transfer,['SmartCoco'],TRUE,,,,,"['NEQ', 'to', '0']",[],,
0x1c4f0fa4cb34cc327ecc3e8500df920eef2de967,ETM,transferFrom,['SmartCoco'],TRUE,,,,,"['NEQ', 'to', '0']",[],,
0x1c4f0fa4cb34cc327ecc3e8500df920eef2de967,ETM,setApprovalForAll,['SmartCoco'],FALSE,,,,,"['NEQ', 'operator', 'caller']","[['Require', 'ETM', 'setApprovalForAll', ""['EQ', 'operator', '_msgSenderERC721A()']"", 'None', None, None]]",,
0xbde84d825b1fe1e0e23db6b95f737cb841e0c343,GenuineUndeadApes,transferFrom,['SmartCoco'],FALSE,,,,,"['NEQ', 'from', '0']","[['Require', 'GenuineUndeadApes', '_transfer', ""['NEQ', 'to', 'address(0)']"", 'ERC721A: transfer to the zero address', None, None], ['Require', 'GenuineUndeadApes', '_transfer', ""['EQ', 'prevOwnership.addr', 'from']"", 'ERC721A: transfer from incorrect owner', None, None]]",,
0xbde84d825b1fe1e0e23db6b95f737cb841e0c343,ERC721A,transferFrom,['SmartCoco'],FALSE,,,,,"['NEQ', 'from', '0']","[['Require', 'ERC721A', '_transfer', ""['NEQ', 'to', 'address(0)']"", 'ERC721A: transfer to the zero address', None, None], ['Require', 'ERC721A', '_transfer', ""['EQ', 'prevOwnership.addr', 'from']"", 'ERC721A: transfer from incorrect owner', None, None]]",,
0xbde84d825b1fe1e0e23db6b95f737cb841e0c343,GenuineUndeadApes,safeTransferFrom,['SmartCoco'],FALSE,,,,,"['NEQ', 'from', '0']","[['Require', 'GenuineUndeadApes', '_transfer', ""['NEQ', 'to', 'address(0)']"", 'ERC721A: transfer to the zero address', None, None], ['Require', 'GenuineUndeadApes', '_transfer', ""['EQ', 'prevOwnership.addr', 'from']"", 'ERC721A: transfer from incorrect owner', None, None]]",,
0xbde84d825b1fe1e0e23db6b95f737cb841e0c343,ERC721A,safeTransferFrom,['SmartCoco'],FALSE,,,,,"['NEQ', 'from', '0']","[['Require', 'ERC721A', '_transfer', ""['NEQ', 'to', 'address(0)']"", 'ERC721A: transfer to the zero address', None, None], ['Require', 'ERC721A', '_transfer', ""['EQ', 'prevOwnership.addr', 'from']"", 'ERC721A: transfer from incorrect owner', None, None]]",,
0x52f16e3924f89cdda35906c012649e907ff48782,Azukimfer,setApprovalForAll,['SmartCoco'],FALSE,,,,,"['NEQ', 'operator', 'caller']","[['Require', 'Azukimfer', 'setApprovalForAll', ""['EQ', 'operator', '_msgSender()']"", 'None', None, None]]",,
0x52f16e3924f89cdda35906c012649e907ff48782,ERC721A,safeTransferFrom,['SmartCoco'],FALSE,,,,,"['NEQ', 'to', '0']",[],,
0x52f16e3924f89cdda35906c012649e907ff48782,ERC721A,setApprovalForAll,['SmartCoco'],FALSE,,,,,"['NEQ', 'operator', 'caller']","[['Require', 'ERC721A', 'setApprovalForAll', ""['EQ', 'operator', '_msgSender()']"", 'None', None, None]]",,
0x52f16e3924f89cdda35906c012649e907ff48782,Azukimfer,safeTransferFrom,['SmartCoco'],FALSE,,,,,"['NEQ', 'to', '0']",[],,
0x52f16e3924f89cdda35906c012649e907ff48782,ERC721A,transferFrom,['SmartCoco'],FALSE,,,,,"['NEQ', 'to', '0']",[],,
0x52f16e3924f89cdda35906c012649e907ff48782,Azukimfer,transferFrom,['SmartCoco'],FALSE,,,,,"['NEQ', 'to', '0']",[],,
0x52f16e3924f89cdda35906c012649e907ff48782,ERC721A,_transfer,['SmartCoco'],FALSE,,,,,"['NEQ', 'to', '0']",[],,
0xaa98551a659f44b34293ec6917dd936c4449b35b,NFT,transferFrom,['SmartCoco'],FALSE,,,,,"['NEQ', 'from', '0']","[['Require', 'NFT', '_transfer', ""['NEQ', 'to', 'address(0)']"", 'ERC721A: transfer to the zero address', None, None], ['Require', 'NFT', '_transfer', ""['EQ', 'prevOwnership.addr', 'from']"", 'ERC721A: transfer from incorrect owner', None, None]]",,
0xaa98551a659f44b34293ec6917dd936c4449b35b,ERC721A,transferFrom,['SmartCoco'],FALSE,,,,,"['NEQ', 'from', '0']","[['Require', 'ERC721A', '_transfer', ""['EQ', 'prevOwnership.addr', 'from']"", 'ERC721A: transfer from incorrect owner', None, None], ['Require', 'ERC721A', '_transfer', ""['NEQ', 'to', 'address(0)']"", 'ERC721A: transfer to the zero address', None, None]]",,
0xaa98551a659f44b34293ec6917dd936c4449b35b,NFT,safeTransferFrom,['SmartCoco'],FALSE,,,,,"['NEQ', 'from', '0']","[['Require', 'NFT', '_transfer', ""['NEQ', 'to', 'address(0)']"", 'ERC721A: transfer to the zero address', None, None], ['Require', 'NFT', '_transfer', ""['EQ', 'prevOwnership.addr', 'from']"", 'ERC721A: transfer from incorrect owner', None, None]]",,
0xaa98551a659f44b34293ec6917dd936c4449b35b,ERC721A,safeTransferFrom,['SmartCoco'],FALSE,,,,,"['NEQ', 'from', '0']","[['Require', 'ERC721A', '_transfer', ""['EQ', 'prevOwnership.addr', 'from']"", 'ERC721A: transfer from incorrect owner', None, None], ['Require', 'ERC721A', '_transfer', ""['NEQ', 'to', 'address(0)']"", 'ERC721A: transfer to the zero address', None, None]]",,
0x83fbf5fe391dcaf4ef852b766b728729b6a47ae6,KOPOKOMafia,setApprovalForAll,['SmartCoco'],FALSE,,,,,"['NEQ', 'operator', 'caller']","[['Require', 'KOPOKOMafia', 'setApprovalForAll', ""['EQ', 'operator', '_msgSender()']"", 'None', None, None]]",,
0x83fbf5fe391dcaf4ef852b766b728729b6a47ae6,KOPOKOMafia,transferFrom,['SmartCoco'],FALSE,,,,,"['NEQ', 'to', '0']",[],,
0x83fbf5fe391dcaf4ef852b766b728729b6a47ae6,ERC721A,setApprovalForAll,['SmartCoco'],,,,,,"['NEQ', 'operator', 'caller']","[['Require', 'ERC721A', 'setApprovalForAll', ""['EQ', 'operator', '_msgSender()']"", 'None', None, None]]",,
0x83fbf5fe391dcaf4ef852b766b728729b6a47ae6,ERC721A,safeTransferFrom,['SmartCoco'],,,,,,"['NEQ', 'to', '0']",[],,
0x83fbf5fe391dcaf4ef852b766b728729b6a47ae6,ERC721A,transferFrom,['SmartCoco'],,,,,,"['NEQ', 'to', '0']",[],,
0x83fbf5fe391dcaf4ef852b766b728729b6a47ae6,KOPOKOMafia,safeTransferFrom,['SmartCoco'],,,,,,"['NEQ', 'to', '0']",[],,
0x83fbf5fe391dcaf4ef852b766b728729b6a47ae6,ERC721A,_transfer,['SmartCoco'],,,,,,"['NEQ', 'to', '0']",[],,
0xcf72deff2e24263b4461806c9ff636a7a967bf99,BoredPumkins,safeTransferFrom,['SmartCoco'],,,,,,"['NEQ', 'from', '0']",[],,
0xcf72deff2e24263b4461806c9ff636a7a967bf99,ERC721A,safeTransferFrom,['SmartCoco'],,,,,,"['NEQ', 'to', '0']",[],,
0xcf72deff2e24263b4461806c9ff636a7a967bf99,ERC721A,setApprovalForAll,['SmartCoco'],,,,,,"['NEQ', 'operator', 'caller']","[['Require', 'ERC721A', 'setApprovalForAll', ""['EQ', 'operator', '_msgSender()']"", 'None', None, None]]",,
0xcf72deff2e24263b4461806c9ff636a7a967bf99,BoredPumkins,transferFrom,['SmartCoco'],,,,,,"['NEQ', 'from', '0']",[],,
0xcf72deff2e24263b4461806c9ff636a7a967bf99,ERC721A,transferFrom,['SmartCoco'],,,,,,"['NEQ', 'to', '0']",[],,
0xcf72deff2e24263b4461806c9ff636a7a967bf99,BoredPumkins,setApprovalForAll,['SmartCoco'],,,,,,"['NEQ', 'operator', 'caller']","[['Require', 'BoredPumkins', 'setApprovalForAll', ""['EQ', 'operator', '_msgSender()']"", 'None', None, None]]",,
0xcf72deff2e24263b4461806c9ff636a7a967bf99,ERC721A,_transfer,['SmartCoco'],,,,,,"['NEQ', 'to', '0']",[],,
0x55d351764edf23dd64d6da5ad586877197b159ad,BlaqueSoul,safeTransferFrom,['SmartCoco'],,,,,,"['NEQ', 'from', '0']",[],,
0x55d351764edf23dd64d6da5ad586877197b159ad,ERC721A,safeTransferFrom,['SmartCoco'],,,,,,"['NEQ', 'to', '0']",[],,
0x55d351764edf23dd64d6da5ad586877197b159ad,BlaqueSoul,transferFrom,['SmartCoco'],,,,,,"['NEQ', 'to', '0']",[],,
0x55d351764edf23dd64d6da5ad586877197b159ad,ERC721A,transferFrom,['SmartCoco'],,,,,,"['NEQ', 'to', '0']",[],,
0x55d351764edf23dd64d6da5ad586877197b159ad,ERC721A,setApprovalForAll,['SmartCoco'],,,,,,"['NEQ', 'operator', 'caller']","[['Require', 'ERC721A', 'setApprovalForAll', ""['EQ', 'operator', '_msgSenderERC721A()']"", 'None', None, None]]",,
0x55d351764edf23dd64d6da5ad586877197b159ad,BlaqueSoul,setApprovalForAll,['SmartCoco'],,,,,,"['NEQ', 'operator', 'caller']","[['Require', 'BlaqueSoul', 'setApprovalForAll', ""['EQ', 'operator', '_msgSenderERC721A()']"", 'None', None, None]]",,
0x55d351764edf23dd64d6da5ad586877197b159ad,ERC721A,_transfer,['SmartCoco'],,,,,,"['NEQ', 'to', '0']",[],,
0x01d23b846f88c4f496bd90e351258afc7f17f6de,TokenERC20,approveAndCall,"['SmartComment_no_comment', 'SmartComment_no_comment_no_diff']",FALSE,TRUE,"[1, 2, 3]","[1, 2, 3, 4, 5]",Missing return statement in all code paths despite declared return value.,"approveAndCall(address,uint256,bytes) returns (bool success)","""\n=== Implementation of Function approveAndCall(address,uint256,bytes) ===\nfunction approveAndCall(address _spender, uint256 _value, bytes _extraData)\r\n        public\r\n        returns (bool success) {\r\n        tokenRecipient spender = tokenRecipient(_spender);\r\n        if (approve(_spender, _value)) {\r\n            spender.receiveApproval(msg.sender, _value, this, _extraData);\r\n            return true;\r\n        }\r\n    }\n    \n=== Functions that function approveAndCall internally calls ===\nfunction approve(address _spender, uint256 _value) public\r\n        returns (bool success) {\r\n        allowance[msg.sender][_spender] = _value;\r\n        return true;\r\n    }""","{
  ""approveAndCall"": ""function approveAndCall(address _spender, uint256 _value, bytes _extraData)\n        public\n        returns (bool success) {\n        tokenRecipient spender = tokenRecipient(_spender);\n        if (approve(_spender, _value)) {\n            spender.receiveApproval(msg.sender, _value, this, _extraData);\n            return true;\n        }\n        return false;\n    }""
}",
0x1ecfdccf97edd64fb73890ca4541f306456a21ec,MerkleProof,processProof,['SmartComment_no_comment_no_diff'],FALSE,TRUE,"[1, 2, 3, 4, 5]","[1, 2, 3, 4]","Code reorders proof elements, contradicting comment that pairs are sorted.","When processing the proof, the pairs of leafs & pre-images are assumed to be sorted.","""\n=== Implementation of Function processProof(bytes32[],bytes32) ===\nfunction processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\r\n        bytes32 computedHash = leaf;\r\n        for (uint256 i = 0; i < proof.length; i++) {\r\n            bytes32 proofElement = proof[i];\r\n            if (computedHash <= proofElement) {\r\n                computedHash = _efficientHash(computedHash, proofElement);\r\n            } else {\r\n                computedHash = _efficientHash(proofElement, computedHash);\r\n            }\r\n        }\r\n        return computedHash;\r\n    }\n    \n=== Functions that function processProof internally calls ===\nfunction _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\r\n        assembly {\r\n            mstore(0x00, a)\r\n            mstore(0x20, b)\r\n            value := keccak256(0x00, 0x40)\r\n        }\r\n    }""","{
  ""processProof(bytes32[],bytes32)"": ""function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\n    bytes32 computedHash = leaf;\n    for (uint256 i = 0; i < proof.length; i++) {\n        computedHash = _efficientHash(computedHash, proof[i]);\n    }\n    return computedHash;\n}""
}",
0x1fd612d9270e1dd48a31f5b15125f33553e56f75,ERC721A,setApprovalForAll,"['SmartComment_no_comment', 'SmartComment_no_comment_no_diff']",FALSE,TRUE,"[1, 2, 3, 4, 5]","[2, 3, 5]",Extra operator != sender check contradicts IERC721 interface which allows self-approval,See {IERC721-setApprovalForAll}.,"""\n=== Implementation of Function setApprovalForAll(address,bool) ===\nfunction setApprovalForAll(address operator, bool approved) public override {\r\n    require(operator != _msgSender(), \""ERC721A: approve to caller\"");\r\n\r\n    _operatorApprovals[_msgSender()][operator] = approved;\r\n    emit ApprovalForAll(_msgSender(), operator, approved);\r\n  }\n    \n=== Functions that function setApprovalForAll internally calls ===\nfunction _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }""","{
  ""function_name"": ""function setApprovalForAll(address operator, bool approved) public override {\n    _operatorApprovals[_msgSender()][operator] = approved;\n    emit ApprovalForAll(_msgSender(), operator, approved);\n  }""
}",
0x2b0ec0993a00b2ea625e3b37fcc74742f43a72fe,ButtonBase,redeemSurplusETH,"['SmartComment_no_comment', 'SmartComment_no_comment_no_diff']",FALSE,TRUE,"[1, 2, 4]","[1, 2, 3, 4]",Transfers entire base balance instead of surplus ETH,This allows the owner to withdraw surplus ETH,"""\n=== Implementation of Function redeemSurplusETH() ===\nfunction redeemSurplusETH() public auth {\r\n        uint surplus = address(this).balance.sub(totalETH);\r\n        balanceETH(base, surplus);\r\n        sendETH(base, msg.sender, base.balanceETH);\r\n    }\n    \n=== Functions that function redeemSurplusETH internally calls ===\nfunction balanceETH(Account storage toAccount,  uint _value) internal {\r\n        require(address(this).balance >= totalETH.add(_value));\r\n        depositETH(toAccount, address(this), _value);\r\n    }\nfunction sendETH(Account storage a, address _to, uint _value) \r\n    internal noReentrance \r\n    {\r\n        require(a.balanceETH >= _value);\r\n        require(_to != address(0));\r\n        \r\n        a.balanceETH = a.balanceETH.sub(_value);\r\n        totalETH = totalETH.sub(_value);\r\n\r\n        _to.transfer(_value);\r\n        \r\n        emit ETHSent(a.name, _to, _value);\r\n    }\nfunction sub(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x - y) <= x);\r\n    }\nmodifier auth {\r\n        require(isAuthorized(msg.sender, msg.sig));\r\n        _;\r\n    }""","{
  ""redeemSurplusETH()"": ""function redeemSurplusETH() public auth {\n        uint surplus = address(this).balance.sub(totalETH);\n        sendETH(base, msg.sender, surplus);\n    }""
}",
0x2f51f58464a25a1d7c4668dbfbcb46f5ed88e9b3,ERC721A,setApprovalForAll,"['SmartComment_no_comment', 'SmartComment_no_comment_no_diff']",FALSE,TRUE,"[1, 3, 4, 5]","[1, 2, 3, 4, 5]","The function reverts when operator is sender, which is not part of ERC721 standard referenced in the comment.",@dev See {IERC721-setApprovalForAll}.,"""\n=== Implementation of Function setApprovalForAll(address,bool) ===\nfunction setApprovalForAll(address operator, bool approved) public virtual override {\n        if (operator == _msgSender()) revert ApproveToCaller();\n\n        _operatorApprovals[_msgSender()][operator] = approved;\n        emit ApprovalForAll(_msgSender(), operator, approved);\n    }\n    \n=== Functions that function setApprovalForAll internally calls ===\nfunction _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }""","{
  ""setApprovalForAll(address,bool)"": ""function setApprovalForAll(address operator, bool approved) public virtual override {\n        _operatorApprovals[_msgSender()][operator] = approved;\n        emit ApprovalForAll(_msgSender(), operator, approved);\n    }""
}",
0x2f51f58464a25a1d7c4668dbfbcb46f5ed88e9b3,MerkleProof,processProof,['SmartComment_no_comment_no_diff'],FALSE,TRUE,"[1, 2, 3, 4, 5]","[1, 2, 3, 4]","Code dynamically orders proof elements, contradicting comment that pairs are pre-sorted.","When processing the proof, the pairs of leafs & pre-images are assumed to be sorted.","""\n=== Implementation of Function processProof(bytes32[],bytes32) ===\nfunction processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            bytes32 proofElement = proof[i];\n            if (computedHash <= proofElement) {\n                computedHash = _efficientHash(computedHash, proofElement);\n            } else {\n                computedHash = _efficientHash(proofElement, computedHash);\n            }\n        }\n        return computedHash;\n    }\n    \n=== Functions that function processProof internally calls ===\nfunction _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\n        assembly {\n            mstore(0x00, a)\n            mstore(0x20, b)\n            value := keccak256(0x00, 0x40)\n        }\n    }""","{
  ""processProof(bytes32[],bytes32)"": ""function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            bytes32 proofElement = proof[i];\n            computedHash = _efficientHash(computedHash, proofElement);\n        }\n        return computedHash;\n    }""
}",
0x321f2802adb6b7f129be55ae2980d17a50c7380e,RektApeYachtClub,tokenURI,['SmartComment_no_comment_no_diff'],FALSE,TRUE,"[2, 3, 4]","[1, 2, 3, 4, 5]",Comment states no file extensions but implementation appends .json,ERC721A has no file extensions for its tokenURIs,"""\n=== Implementation of Function tokenURI(uint256) ===\nfunction tokenURI(uint256 tokenId)\r\n        public\r\n        view\r\n        virtual\r\n        override\r\n        returns (string memory)\r\n    {\r\n        if (!_exists(tokenId)) revert URIQueryForNonexistentToken();\r\n\r\n        string memory baseURI = _baseURI();\r\n        return\r\n            bytes(baseURI).length != 0\r\n                ? string(abi.encodePacked(baseURI, _toString(tokenId), \"".json\""))\r\n                : \""\"";\r\n    }\n    \n=== Functions that function tokenURI internally calls ===\nfunction _baseURI() internal view override returns (string memory) {\r\n        return baseUri;\r\n    }\nfunction _exists(uint256 tokenId) internal view returns (bool) {\n        return\n            _startTokenId() <= tokenId &&\n            tokenId < _currentIndex && // If within bounds,\n            _packedOwnerships[tokenId] & BITMASK_BURNED == 0; // and not burned.\n    }\nfunction _toString(uint256 value) internal pure returns (string memory ptr) {\n        assembly {\n            ptr := add(mload(0x40), 128)\n            mstore(0x40, ptr)\n\n            let end := ptr\n\n            for { \n                let temp := value\n                ptr := sub(ptr, 1)\n                mstore8(ptr, add(48, mod(temp, 10)))\n                temp := div(temp, 10)\n            } temp { \n                temp := div(temp, 10)\n            } { // Body of the for loop.\n                ptr := sub(ptr, 1)\n                mstore8(ptr, add(48, mod(temp, 10)))\n            }\n            \n            let length := sub(end, ptr)\n            ptr := sub(ptr, 32)\n            mstore(ptr, length)\n        }\n    }""","{
  ""tokenURI(uint256)"": ""function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        if (!_exists(tokenId)) revert URIQueryForNonexistentToken();\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length != 0 ? string(abi.encodePacked(baseURI, _toString(tokenId))) : \""\"";\n    }""
}",
0x43780e780df2bd1e4d955d3d4b577a490841241a,PRBMath,mulDiv,['SmartComment_no_comment_no_diff'],FALSE,TRUE,"[1, 2, 3, 5]","[1, 2, 3, 4, 5]",Missing check for zero denominator contradicts comment requirement.,The denominator cannot be zero.,"""\n=== Implementation of Function mulDiv(uint256,uint256,uint256) ===\nunction mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        uint256 prod0; // Least significant 256 bits of the product\n        uint256 prod1; // Most significant 256 bits of the product\n        assembly {\n            let mm := mulmod(x, y, not(0))\n            prod0 := mul(x, y)\n            prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n        }\n\n        if (prod1 == 0) {\n            unchecked {\n                result = prod0 / denominator;\n            }\n            return result;\n        }\n\n        if (prod1 >= denominator) {\n            revert PRBMath__MulDivOverflow(prod1, denominator);\n        }\n\n\n        uint256 remainder;\n        assembly {\n            remainder := mulmod(x, y, denominator)\n\n            prod1 := sub(prod1, gt(remainder, prod0))\n            prod0 := sub(prod0, remainder)\n        }\n\n        unchecked {\n            uint256 lpotdod = denominator & (~denominator + 1);\n            assembly {\n                denominator := div(denominator, lpotdod)\n\n                prod0 := div(prod0, lpotdod)\n\n                lpotdod := add(div(sub(0, lpotdod), lpotdod), 1)\n            }\n\n            prod0 |= prod1 * lpotdod;\n\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    ""","{
  ""mulDiv"": ""function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        require(denominator != 0, \""denominator zero\"");\n        uint256 prod0;\n        uint256 prod1;\n        assembly {\n            let mm := mulmod(x, y, not(0))\n            prod0 := mul(x, y)\n            prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n        }\n        if (prod1 == 0) {\n            unchecked { result = prod0 / denominator; }\n            return result;\n        }\n        if (prod1 >= denominator) revert PRBMath__MulDivOverflow(prod1, denominator);\n        uint256 remainder;\n        assembly {\n            remainder := mulmod(x, y, denominator)\n            prod1 := sub(prod1, gt(remainder, prod0))\n            prod0 := sub(prod0, remainder)\n        }\n        unchecked {\n            uint256 lpotdod = denominator & (~denominator + 1);\n            assembly {\n                denominator := div(denominator, lpotdod)\n                prod0 := div(prod0, lpotdod)\n                lpotdod := add(div(sub(0, lpotdod), lpotdod), 1)\n            }\n            prod0 |= prod1 * lpotdod;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse;\n            inverse *= 2 - denominator * inverse;\n            inverse *= 2 - denominator * inverse;\n            inverse *= 2 - denominator * inverse;\n            inverse *= 2 - denominator * inverse;\n            inverse *= 2 - denominator * inverse;\n            result = prod0 * inverse;\n            return result;\n        }\n    }""
}",
0x5cfaf9ad2cb84ce2bc40be1beb735bd12a075e99,StandardToken,decreaseApproval,['SmartComment_no_comment_no_diff'],FALSE,FALSE,"[3, 4, 5]","[1, 2, 3, 4]",DecreaseApproval sets allowance to 0 without calling approve() when allowed reaches 0,approve should be called when allowed[_spender] == 0.,"""\n=== Implementation of Function decreaseApproval(address,uint256) ===\nfunction decreaseApproval(address _spender, uint256 _subtractedValue) public returns (bool) {\r\n         uint256 oldValue = allowed[msg.sender][_spender];\r\n         if (_subtractedValue > oldValue) {\r\n                allowed[msg.sender][_spender] = 0;\r\n         } else {\r\n                allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n         }\r\n         emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n         return true;\r\n    }\n    \n=== Functions that function decreaseApproval internally calls ===\nfunction sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n         assert(b <= a);\r\n         return a - b;\r\n    }""","{
  ""decreaseApproval"": ""function decreaseApproval(address _spender, uint256 _subtractedValue) public returns (bool) {\n    uint256 oldValue = allowed[msg.sender][_spender];\n    if (_subtractedValue >= oldValue) {\n        approve(_spender, 0);\n    } else {\n        approve(_spender, oldValue - _subtractedValue);\n    }\n    return true;\n}""
}",
0x698d046ff658cea6af6785f0a1d0f64a907eada0,MerkleProof,processProof,['SmartComment_no_comment_no_diff'],FALSE,TRUE,"[2, 3, 4, 5]","[1, 2, 3, 4, 5]","Code sorts proof pairs during hashing, contradicting comment's assumption of pre-sorted pairs.","When processing the proof, the pairs of leafs & pre-images are assumed to be sorted.","""\n=== Implementation of Function processProof(bytes32[],bytes32) ===\nfunction processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n    \n=== Functions that function processProof internally calls ===\nfunction _hashPair(bytes32 a, bytes32 b) private pure returns (bytes32) {\n        return a < b ? _efficientHash(a, b) : _efficientHash(b, a);\n    }""","{
  ""processProof"": ""function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\n    bytes32 computedHash = leaf;\n    for (uint256 i = 0; i < proof.length; i++) {\n        computedHash = _efficientHash(computedHash, proof[i]);\n    }\n    return computedHash;\n}"",
  ""_efficientHash"": ""function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\n    assembly {\n        mstore(0x00, a)\n        mstore(0x20, b)\n        value := keccak256(0x00, 0x40)\n    }\n}""
}",
0x6fa73dd6a86461a95fa9d792d9edfe631a6281af,MerkleProof,processProof,['SmartComment_no_comment_no_diff'],FALSE,TRUE,"[1, 2, 3, 4, 5]","[1, 2, 3]","Code sorts pairs during hashing, violating comment's assumption of pre-sorted proof elements.","When processing the proof, the pairs of leafs & pre-images are assumed to be sorted.","""\n=== Implementation of Function processProof(bytes32[],bytes32) ===\nfunction processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n    \n=== Functions that function processProof internally calls ===\nfunction _hashPair(bytes32 a, bytes32 b) private pure returns (bytes32) {\n        return a < b ? _efficientHash(a, b) : _efficientHash(b, a);\n    }""","{
  ""processProof"": ""function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _efficientHash(computedHash, proof[i]);\n        }\n        return computedHash;\n    }"",
  ""_efficientHash"": ""function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\n        assembly {\n            mstore(0x00, a)\n            mstore(0x20, b)\n            value := keccak256(0x00, 0x40)\n        }\n    }""
}",
0x6fa73dd6a86461a95fa9d792d9edfe631a6281af,ERC721A,setApprovalForAll,"['SmartComment_no_comment', 'SmartComment_no_comment_no_diff']",FALSE,TRUE,"[2, 3, 4, 5]","[1, 2, 3, 4, 5]",Implementation adds unintended sender check conflicting with ERC721 standard.,@dev See {IERC721-setApprovalForAll}.,"""\n=== Implementation of Function setApprovalForAll(address,bool) ===\nfunction setApprovalForAll(address operator, bool approved) public virtual override {\n        if (operator == _msgSender()) revert ApproveToCaller();\n\n        _operatorApprovals[_msgSender()][operator] = approved;\n        emit ApprovalForAll(_msgSender(), operator, approved);\n    }\n    \n=== Functions that function setApprovalForAll internally calls ===\nfunction _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }""","{
  ""function_name"": ""function setApprovalForAll(address operator, bool approved) public virtual override {\n        _operatorApprovals[_msgSender()][operator] = approved;\n        emit ApprovalForAll(_msgSender(), operator, approved);\n    }""
}",
0x77b8ae2e83c7d044d159878445841e2a9777af38,WSGov,permit,"['SmartComment_no_comment', 'SmartComment_no_comment_no_diff']",FALSE,TRUE,"[1, 2, 3, 4, 5]","[2, 3, 4]","Permit hashes rawAmount but stores uint96 amount, causing signature mismatch.",* @param rawAmount The number of tokens that are approved (2^256-1 means infinite),"""\n=== Implementation of Function permit(address,address,uint256,uint256,uint8,bytes32,bytes32) ===\nfunction permit(address owner, address spender, uint rawAmount, uint deadline, uint8 v, bytes32 r, bytes32 s) external {\r\n        uint96 amount;\r\n        if (rawAmount == uint(-1)) {\r\n            amount = uint96(-1);\r\n        } else {\r\n            amount = safe96(rawAmount, \""WSG::permit: amount exceeds 96 bits\"");\r\n        }\r\n\r\n        bytes32 domainSeparator = keccak256(abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(name)), getChainId(), address(this)));\r\n        bytes32 structHash = keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, rawAmount, nonces[owner]++, deadline));\r\n        bytes32 digest = keccak256(abi.encodePacked(\""\\x19\\x01\"", domainSeparator, structHash));\r\n        address signatory = ecrecover(digest, v, r, s);\r\n        require(signatory != address(0), \""WSG::permit: invalid signature\"");\r\n        require(signatory == owner, \""WSG::permit: unauthorized\"");\r\n        require(now <= deadline, \""WSG::permit: signature expired\"");\r\n\r\n        allowances[owner][spender] = amount;\r\n\r\n        emit Approval(owner, spender, amount);\r\n    }\n    \n=== Functions that function permit internally calls ===\nfunction getChainId() internal pure returns (uint) {\r\n        uint256 chainId;\r\n        assembly { chainId := chainid() }\r\n        return chainId;\r\n    }\nfunction safe96(uint n, string memory errorMessage) internal pure returns (uint96) {\r\n        require(n < 2**96, errorMessage);\r\n        return uint96(n);\r\n    }""","{
  ""permit"": ""function permit(address owner, address spender, uint rawAmount, uint deadline, uint8 v, bytes32 r, bytes32 s) external {\n        uint96 amount;\n        if (rawAmount == uint(-1)) {\n            amount = uint96(-1);\n        } else {\n            amount = safe96(rawAmount, \""WSG::permit: amount exceeds 96 bits\"");\n        }\n\n        bytes32 domainSeparator = keccak256(abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(name)), getChainId(), address(this)));\n        bytes32 structHash = keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, amount, nonces[owner]++, deadline));\n        bytes32 digest = keccak256(abi.encodePacked(\""\\x19\\x01\"", domainSeparator, structHash));\n        address signatory = ecrecover(digest, v, r, s);\n        require(signatory != address(0), \""WSG::permit: invalid signature\"");\n        require(signatory == owner, \""WSG::permit: unauthorized\"");\n        require(now <= deadline, \""WSG::permit: signature expired\"");\n\n        allowances[owner][spender] = amount;\n\n        emit Approval(owner, spender, amount);\n    }""
}",
0x8853d03d905839344ea4b0c35a27393fa153fc49,TrafficLight,transfer,"['SmartComment_no_comment', 'SmartComment_no_comment_no_diff']",FALSE,TRUE,"[1, 2, 5]","[1, 2, 3, 4, 5]",Missing multiplication by 10^decimals in balance check,*10 ** decimals,"""\n=== Implementation of Function transfer(address,uint256) ===\nfunction transfer(address _to, uint256 _value) public returns (bool success) {\r\n    require(_balanceOf[msg.sender] >= _value);//*10 ** decimals\r\n    _transfer(msg.sender, _to, _value);\r\n    return true;\r\n  }\n    \n=== Functions that function transfer internally calls ===\nfunction _transfer(address _from, address _to, uint256 _value) internal {\r\n    \r\n    if (light==1)\r\n    {\r\n        if (start==false)\r\n        {\r\n        _balanceOf[_from] = _balanceOf[_from].sub(_value);\r\n        _balanceOf[_to] = _balanceOf[_to].add(_value);\r\n        emit Transfer(_from, _to, _value);\r\n        } else {\r\n            \r\n            uint256 tokensToBurn = findBurn (_value);\r\n            uint256 valueToSend = _value.sub(tokensToBurn);\r\n            \r\n            _balanceOf[_from] = _balanceOf[_from].sub(_value);\r\n            _balanceOf[0x0000000000000000000000000000000000000000] = _balanceOf[0x0000000000000000000000000000000000000000].add(tokensToBurn);\r\n            _balanceOf[_to] = _balanceOf[_to].add(valueToSend);\r\n        \r\n            emit Transfer(_from, 0x0000000000000000000000000000000000000000, tokensToBurn);\r\n            emit Transfer(_from, _to, valueToSend);\r\n            \r\n        }\r\n    } else if (light==2) {\r\n            \r\n        _balanceOf[_from] = _balanceOf[_from].sub(_value);\r\n        _balanceOf[_to] = _balanceOf[_to].add(_value);\r\n        emit Transfer(_from, _to, _value);\r\n        \r\n        if (reward > 2)\r\n        {\r\n            uint256 reward_to_send = reward.div(rewardDistributionPercent);\r\n            _balanceOf[address(this)] = _balanceOf[address(this)].sub(reward_to_send);\r\n            _balanceOf[_to] = _balanceOf[_to].add(reward_to_send);\r\n            reward = reward.sub(reward_to_send);\r\n            emit Transfer(address(this), _to, reward_to_send);\r\n        }\r\n    } else {\r\n        uint256 tokensToReward = findReward(_value);\r\n        uint256 tokensToBurn = findBurn (_value);\r\n        uint256 tokensToTransfer = _value.sub(tokensToReward).sub(tokensToBurn);\r\n        \r\n        \r\n\r\n        _balanceOf[_from] = _balanceOf[_from].sub(_value);\r\n        _balanceOf[_to] = _balanceOf[_to].add(tokensToTransfer);\r\n        _balanceOf[address(this)] = _balanceOf[address(this)].add(tokensToReward);\r\n        _balanceOf[0x0000000000000000000000000000000000000000] = _balanceOf[0x0000000000000000000000000000000000000000].add(tokensToBurn);\r\n        reward = reward.add(tokensToReward);\r\n        \r\n        emit Transfer(_from, _to, tokensToTransfer);\r\n        emit Transfer(_from, 0x0000000000000000000000000000000000000000, tokensToBurn);\r\n        emit Transfer(_from, address(this), tokensToReward);\r\n    }\r\n  }""","{
  ""transfer(address,uint256)"": ""function transfer(address _to, uint256 _value) public returns (bool success) {\n    require(_balanceOf[msg.sender] >= _value * 10 ** decimals);\n    _transfer(msg.sender, _to, _value * 10 ** decimals);\n    return true;\n  }""
}",
0xa108dccae3399973c2b129ae3927832cbba6570b,STYK_I,sell,['SmartComment_no_comment_no_diff'],FALSE,TRUE,"[1, 3, 4, 5]","[2, 3, 4, 5]","Function updates user deposit but does not transfer Ethereum to user, contradicting liquification.",Liquifies tokens to ethereum.,"""\n=== Implementation of Function sell(uint256) ===\nfunction sell(uint256 _amountOfTokens) public onlybelievers() {\r\n        address _customerAddress = msg.sender;\r\n\r\n        require(\r\n            now > auctionExpiryTime,\r\n            \""ERR_CANNOT_SELL_TOKENS_BEFORE_AUCTION\""\r\n        );\r\n\r\n        require(_amountOfTokens <= tokenBalanceLedger_[_customerAddress]);\r\n\r\n        uint256 _tokens = _amountOfTokens;\r\n        uint256 _ethereum = tokensToEthereum_(_tokens);\r\n        uint256 _dividends = safeDiv(_ethereum, dividendFee_);\r\n        uint256 _taxedEthereum = safeSub(_ethereum, _dividends);\r\n\r\n        if (tokenBalanceLedger_[_customerAddress] == _amountOfTokens) {\r\n            if (earlyadopters[_customerAddress]) {\r\n                earlyadopterBonus[_customerAddress] = earlyAdopterBonus(\r\n                    _customerAddress\r\n                );\r\n            }\r\n            if (rewardQualifier[_customerAddress]) {\r\n                stykRewards[_customerAddress] = STYKRewards(_customerAddress);\r\n            }\r\n        }\r\n\r\n        tokenSupply_ = safeSub(tokenSupply_, _tokens);\r\n        tokenBalanceLedger_[_customerAddress] = safeSub(\r\n            tokenBalanceLedger_[_customerAddress],\r\n            _tokens\r\n        );\r\n\r\n        if (auctionAddressTracker[_customerAddress]) {\r\n            int256 _updatedPayouts = (int256)(auctionProfitPerShare_ * _tokens);\r\n            payoutsTo_[_customerAddress] -= _updatedPayouts;\r\n        } else {\r\n            int256 _updatedPayouts = (int256)(profitPerShare_ * _tokens);\r\n            payoutsTo_[_customerAddress] -= _updatedPayouts;\r\n        }\r\n\r\n        if (tokenSupply_ > 0) {\r\n            auctionProfitPerShare_ = safeAdd(\r\n                auctionProfitPerShare_,\r\n                (_dividends * magnitude) /\r\n                    safeAdd(tokenSupply_, tokenBalanceLedger_[address(this)])\r\n            );\r\n\r\n            profitPerShare_ = safeAdd(\r\n                profitPerShare_,\r\n                (_dividends * magnitude) /\r\n                    safeAdd(tokenSupply_, tokenBalanceLedger_[address(this)])\r\n            );\r\n        }\r\n\r\n        userDeposit[_customerAddress] = safeAdd(\r\n            userDeposit[_customerAddress],\r\n            _taxedEthereum\r\n        );\r\n\r\n        emit onTokenSell(_customerAddress, _tokens, _taxedEthereum);\r\n        emit Transfer(_customerAddress, address(0), _amountOfTokens);\r\n    }\n    \n=== Functions that function sell internally calls ===\nfunction STYKRewards(address _to) internal view returns (uint256) {\r\n        if (_calculateTokenPercentage(_to) > 0) {\r\n            uint256 _rewards = stykRewards[_to];\r\n            uint256 accumulatedRewards =\r\n                safeDiv(\r\n                    safeMul(\r\n                        _deflationAccumulatedRewards(),\r\n                        _calculateTokenPercentage(_to)\r\n                    ),\r\n                    1000000\r\n                );\r\n            uint256 finalRewards = safeAdd(_rewards, accumulatedRewards);\r\n            return finalRewards;\r\n        }\r\n        return 0;\r\n    }\nfunction earlyAdopterBonus(address _user) public view returns (uint256) {\r\n        if (tokenBalanceLedger_[_user] > 0 && earlyadopters[_user]) {\r\n            uint256 token_percent = _calculateTokenPercentage(_user);\r\n            uint256 _earlyadopterDividends =\r\n                (uint256)(\r\n                    (int256)(\r\n                        auctionProfitPerShare_ *\r\n                            tokenBalanceLedger_[address(this)]\r\n                    )\r\n                ) / magnitude;\r\n            uint256 rewards =\r\n                safeDiv(\r\n                    safeMul(_earlyadopterDividends, token_percent),\r\n                    1000000\r\n                );\r\n            return rewards;\r\n        }\r\n        return 0;\r\n    }\nfunction safeAdd(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \""SafeMath: addition overflow\"");\r\n        return c;\r\n    }\nfunction safeDiv(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return safeDiv(a, b, \""SafeMath: division by zero\"");\r\n    }\nfunction safeSub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return safeSub(a, b, \""SafeMath: subtraction overflow\"");\r\n    }\nfunction tokensToEthereum_(uint256 _tokens)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        uint256 tokens_ = (_tokens + 1e18);\r\n        uint256 _tokenSupply = (tokenSupply_ + 1e18);\r\n        uint256 _etherReceived =\r\n            (// underflow attempts BTFO\r\n            safeSub(\r\n                (((tokenPriceInitial_ +\r\n                    (tokenPriceIncremental_ * (_tokenSupply / 1e18))) -\r\n                    tokenPriceIncremental_) * (tokens_ - 1e18)),\r\n                (tokenPriceIncremental_ * ((tokens_**2 - tokens_) / 1e18)) / 2\r\n            ) / 1e18);\r\n        return _etherReceived;\r\n    }\nmodifier onlybelievers() {\r\n        require(myTokens() > 0);\r\n        _;\r\n    }""","{
  ""sell"": ""function sell(uint256 _amountOfTokens) public onlybelievers() {\n        address _customerAddress = msg.sender;\n\n        require(\n            now > auctionExpiryTime,\n            \""ERR_CANNOT_SELL_TOKENS_BEFORE_AUCTION\""\n        );\n\n        require(_amountOfTokens <= tokenBalanceLedger_[_customerAddress]);\n\n        uint256 _tokens = _amountOfTokens;\n        uint256 _ethereum = tokensToEthereum_(_tokens);\n        uint256 _dividends = safeDiv(_ethereum, dividendFee_);\n        uint256 _taxedEthereum = safeSub(_ethereum, _dividends);\n\n        if (tokenBalanceLedger_[_customerAddress] == _amountOfTokens) {\n            if (earlyadopters[_customerAddress]) {\n                earlyadopterBonus[_customerAddress] = earlyAdopterBonus(\n                    _customerAddress\n                );\n            }\n            if (rewardQualifier[_customerAddress]) {\n                stykRewards[_customerAddress] = STYKRewards(_customerAddress);\n            }\n        }\n\n        tokenSupply_ = safeSub(tokenSupply_, _tokens);\n        tokenBalanceLedger_[_customerAddress] = safeSub(\n            tokenBalanceLedger_[_customerAddress],\n            _tokens\n        );\n\n        if (auctionAddressTracker[_customerAddress]) {\n            int256 _updatedPayouts = (int256)(auctionProfitPerShare_ * _tokens);\n            payoutsTo_[_customerAddress] -= _updatedPayouts;\n        } else {\n            int256 _updatedPayouts = (int256)(profitPerShare_ * _tokens);\n            payoutsTo_[_customerAddress] -= _updatedPayouts;\n        }\n\n        if (tokenSupply_ > 0) {\n            auctionProfitPerShare_ = safeAdd(\n                auctionProfitPerShare_,\n                (_dividends * magnitude) /\n                    safeAdd(tokenSupply_, tokenBalanceLedger_[address(this)])\n            );\n\n            profitPerShare_ = safeAdd(\n                profitPerShare_,\n                (_dividends * magnitude) /\n                    safeAdd(tokenSupply_, tokenBalanceLedger_[address(this)])\n            );\n        }\n\n        (bool success, ) = _customerAddress.call.value(_taxedEthereum)(\""\"");\n        require(success, \""ETH transfer failed\"");\n\n        emit onTokenSell(_customerAddress, _tokens, _taxedEthereum);\n        emit Transfer(_customerAddress, address(0), _amountOfTokens);\n    }""
}",
0xa108dccae3399973c2b129ae3927832cbba6570b,STYK_I,calculateInflationMinutes,"['SmartComment_no_comment', 'SmartComment_no_comment_no_diff']",FALSE,TRUE,"[1, 4, 5]","[1, 2, 3, 4, 5]",Comment specifies fixed 72h conversion but code calculates elapsed minutes dynamically,To calculate Inflation minutes (72 hours converted into minutes),"""\n=== Implementation of Function calculateInflationMinutes() ===\nfunction calculateInflationMinutes() external view returns (uint256) {\r\n        return _calculateInflationMinutes();\r\n    }\n    \n=== Functions that function calculateInflationMinutes internally calls ===\nfunction _calculateInflationMinutes() internal view returns (uint256) {\r\n        if (inflationTime == 0) {\r\n            return 0;\r\n        }\r\n        return safeDiv(safeSub(now, inflationTime), 60);\r\n    }""","{
  ""calculateInflationMinutes()"": ""function calculateInflationMinutes() external view returns (uint256) {\n    return 4320; // 72 hours in minutes\n}""
}",
0xa108dccae3399973c2b129ae3927832cbba6570b,STYK_I,exit,"['SmartComment_no_comment', 'SmartComment_no_comment_no_diff']",TRUE,TRUE,"[1, 2, 3, 4, 5]","[1, 2, 3, 4, 5]",exit() modifies user arrays beyond sell/withdraw calls.,Alias of sell() and withdraw().,"""\n=== Implementation of Function exit() ===\nfunction exit() public {\r\n        address _customerAddress = msg.sender;\r\n        uint256 _tokens = tokenBalanceLedger_[_customerAddress];\r\n\r\n        if (_tokens > 0) sell(_tokens);\r\n\r\n        withdraw();\r\n        userAdded[_customerAddress] = false;\r\n\r\n        uint256 index = getUserAddressIndex(_customerAddress);\r\n        address _lastAddress = userAddress[userAddress.length - 1];\r\n        uint256 _lastindex = getUserAddressIndex(_lastAddress);\r\n        userAddress[index] = _lastAddress;\r\n        userAddress[userAddress.length - 1] = _customerAddress;\r\n\r\n        userIndex[_lastAddress] = index;\r\n        userIndex[_customerAddress] = _lastindex;\r\n        delete userIndex[_customerAddress];\r\n        userAddress.pop();\r\n        userCount--;\r\n    }\n    \n=== Functions that function exit internally calls ===\nfunction getUserAddressIndex(address _customerAddress)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return userIndex[_customerAddress];\r\n    }\nfunction sell(uint256 _amountOfTokens) public onlybelievers() {\r\n        address _customerAddress = msg.sender;\r\n\r\n        require(\r\n            now > auctionExpiryTime,\r\n            \""ERR_CANNOT_SELL_TOKENS_BEFORE_AUCTION\""\r\n        );\r\n\r\n        require(_amountOfTokens <= tokenBalanceLedger_[_customerAddress]);\r\n\r\n        uint256 _tokens = _amountOfTokens;\r\n        uint256 _ethereum = tokensToEthereum_(_tokens);\r\n        uint256 _dividends = safeDiv(_ethereum, dividendFee_);\r\n        uint256 _taxedEthereum = safeSub(_ethereum, _dividends);\r\n\r\n        if (tokenBalanceLedger_[_customerAddress] == _amountOfTokens) {\r\n            if (earlyadopters[_customerAddress]) {\r\n                earlyadopterBonus[_customerAddress] = earlyAdopterBonus(\r\n                    _customerAddress\r\n                );\r\n            }\r\n            if (rewardQualifier[_customerAddress]) {\r\n                stykRewards[_customerAddress] = STYKRewards(_customerAddress);\r\n            }\r\n        }\r\n\r\n        tokenSupply_ = safeSub(tokenSupply_, _tokens);\r\n        tokenBalanceLedger_[_customerAddress] = safeSub(\r\n            tokenBalanceLedger_[_customerAddress],\r\n            _tokens\r\n        );\r\n\r\n        if (auctionAddressTracker[_customerAddress]) {\r\n            int256 _updatedPayouts = (int256)(auctionProfitPerShare_ * _tokens);\r\n            payoutsTo_[_customerAddress] -= _updatedPayouts;\r\n        } else {\r\n            int256 _updatedPayouts = (int256)(profitPerShare_ * _tokens);\r\n            payoutsTo_[_customerAddress] -= _updatedPayouts;\r\n        }\r\n\r\n        if (tokenSupply_ > 0) {\r\n            auctionProfitPerShare_ = safeAdd(\r\n                auctionProfitPerShare_,\r\n                (_dividends * magnitude) /\r\n                    safeAdd(tokenSupply_, tokenBalanceLedger_[address(this)])\r\n            );\r\n\r\n            profitPerShare_ = safeAdd(\r\n                profitPerShare_,\r\n                (_dividends * magnitude) /\r\n                    safeAdd(tokenSupply_, tokenBalanceLedger_[address(this)])\r\n            );\r\n        }\r\n\r\n        userDeposit[_customerAddress] = safeAdd(\r\n            userDeposit[_customerAddress],\r\n            _taxedEthereum\r\n        );\r\n\r\n        emit onTokenSell(_customerAddress, _tokens, _taxedEthereum);\r\n        emit Transfer(_customerAddress, address(0), _amountOfTokens);\r\n    }\nfunction withdraw() public onlyhodler() {\r\n        address payable _customerAddress = msg.sender;\r\n        uint256 _dividends = totalDividends(_customerAddress);\r\n\r\n        userDeposit[_customerAddress] = 0;\r\n        payoutsTo_[_customerAddress] += (int256)(\r\n            _dividendsOf(_customerAddress) * magnitude\r\n        );\r\n        referralBalance_[_customerAddress] = 0;\r\n\r\n        if (\r\n            earlyadopters[_customerAddress] &&\r\n            (now > safeAdd(auctionExpiryTime, 24 hours))\r\n        ) {\r\n            if (tokenBalanceLedger_[_customerAddress] == 0) {\r\n                earlyadopterBonus[_customerAddress] = 0;\r\n            }\r\n            earlyadopters[_customerAddress] = false;\r\n        }\r\n\r\n        if (\r\n            rewardQualifier[_customerAddress] &&\r\n            _calculateInflationMinutes() > 4320\r\n        ) {\r\n            stykRewards[_customerAddress] = 0;\r\n            rewardQualifier[_customerAddress] = false;\r\n        }\r\n        if (totalMonthRewards[_customerAddress] != 0) {\r\n            totalMonthRewards[_customerAddress] = 0;\r\n        }\r\n        _customerAddress.transfer(_dividends);\r\n\r\n        emit onWithdraw(_customerAddress, _dividends);\r\n    }""","{
  ""exit()"": ""function exit() public {\n        address _customerAddress = msg.sender;\n        uint256 _tokens = tokenBalanceLedger_[_customerAddress];\n        if (_tokens > 0) sell(_tokens);\n        withdraw();\n    }""
}",
0xa108dccae3399973c2b129ae3927832cbba6570b,STYK_I,STYKRewards,['SmartComment_no_comment_no_diff'],FALSE,TRUE,"[1, 2, 3, 5]","[1, 2, 3, 4, 5]",Function calculates rewards but does not pay them.,To pay STYK Rewards,"""\n=== Implementation of Function STYKRewards(address) ===\nfunction STYKRewards(address _to) internal view returns (uint256) {\r\n        if (_calculateTokenPercentage(_to) > 0) {\r\n            uint256 _rewards = stykRewards[_to];\r\n            uint256 accumulatedRewards =\r\n                safeDiv(\r\n                    safeMul(\r\n                        _deflationAccumulatedRewards(),\r\n                        _calculateTokenPercentage(_to)\r\n                    ),\r\n                    1000000\r\n                );\r\n            uint256 finalRewards = safeAdd(_rewards, accumulatedRewards);\r\n            return finalRewards;\r\n        }\r\n        return 0;\r\n    }\n    \n=== Functions that function STYKRewards internally calls ===\nfunction _calculateTokenPercentage(address _customerAddress)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        if (tokenBalanceLedger_[_customerAddress] > 0) {\r\n            uint256 token_percent =\r\n                safeDiv(\r\n                    safeMul(tokenBalanceLedger_[_customerAddress], 1000000),\r\n                    totalSupply()\r\n                );\r\n            return token_percent;\r\n        }\r\n        return 0;\r\n    }\nfunction _deflationAccumulatedRewards() internal view returns (uint256) {\r\n        uint256 stykRewardPoolBalance = 0;\r\n\r\n        for (uint256 i = 0; i < userAddress.length; i++) {\r\n            if (userAddress[i] != address(0)) {\r\n                address _user = userAddress[i];\r\n                if (!rewardQualifier[_user]) {\r\n                    stykRewardPoolBalance = safeAdd(\r\n                        _calculateSTYKReward(_user),\r\n                        stykRewardPoolBalance\r\n                    );\r\n                }\r\n            }\r\n        }\r\n        return stykRewardPoolBalance;\r\n    }\nfunction safeAdd(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \""SafeMath: addition overflow\"");\r\n        return c;\r\n    }\nfunction safeDiv(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return safeDiv(a, b, \""SafeMath: division by zero\"");\r\n    }\nfunction safeMul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \""SafeMath: multiplication overflow\"");\r\n\r\n        return c;\r\n    }""","{
  ""STYKRewards"": ""function STYKRewards(address _to) internal returns (uint256) {\n        uint256 _rewards = stykRewards[_to];\n        uint256 accumulatedRewards = safeDiv(safeMul(_deflationAccumulatedRewards(), _calculateTokenPercentage(_to)), 1000000);\n        uint256 rewards = safeAdd(_rewards, accumulatedRewards);\n        stykRewards[_to] = 0;\n        payable(_to).transfer(rewards);\n        return rewards;\n    }""
}",
0xa108dccae3399973c2b129ae3927832cbba6570b,STYK_I,_dividendsOf,['SmartComment_no_comment_no_diff'],FALSE,TRUE,"[2, 3, 5]","[2, 4, 5]",Includes user deposits in dividend calculation contradicting comment,Retrieve the dividend balance of any single address.,"""\n=== Implementation of Function _dividendsOf(address) ===\nfunction _dividendsOf(address _customerAddress)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        if (auctionAddressTracker[_customerAddress]) {\r\n            return\r\n                safeAdd(\r\n                    (uint256)(\r\n                        (int256)(\r\n                            auctionProfitPerShare_ *\r\n                                (tokenBalanceLedger_[_customerAddress])\r\n                        ) - payoutsTo_[_customerAddress]\r\n                    ) / magnitude,\r\n                    userDeposit[_customerAddress]\r\n                );\r\n        } else {\r\n            return\r\n                safeAdd(\r\n                    (uint256)(\r\n                        (int256)(\r\n                            profitPerShare_ *\r\n                                (tokenBalanceLedger_[_customerAddress])\r\n                        ) - payoutsTo_[_customerAddress]\r\n                    ) / magnitude,\r\n                    userDeposit[_customerAddress]\r\n                );\r\n        }\r\n    }\n    \n=== Functions that function _dividendsOf internally calls ===\nfunction safeAdd(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \""SafeMath: addition overflow\"");\r\n        return c;\r\n    }""","{
  ""_dividendsOf"": ""function _dividendsOf(address _customerAddress) public view returns (uint256) {\n        if (auctionAddressTracker[_customerAddress]) {\n            return safeAdd(\n                    (uint256)(\n                        (int256)(\n                            auctionProfitPerShare_ *\n                                tokenBalanceLedger_[_customerAddress]\n                        ) - payoutsTo_[_customerAddress]\n                    ) / magnitude,\n                    userDeposit[_customerAddress]\n                );\n        } else {\n            return safeAdd(\n                    (uint256)(\n                        (int256)(\n                            profitPerShare_ *\n                                tokenBalanceLedger_[_customerAddress]\n                        ) - payoutsTo_[_customerAddress]\n                    ) / magnitude,\n                    userDeposit[_customerAddress]\n                );\n        }\n    }""
}",
0xaa98551a659f44b34293ec6917dd936c4449b35b,SafeMath,mul,"['SmartComment_no_comment', 'SmartComment_no_comment_no_diff']",FALSE,TRUE,"[1, 2, 3, 4, 5]","[2, 4, 5]",Function does not revert on overflow; uses unchecked multiplication.,Reverting on overflow. - Multiplication cannot overflow.,"""\n=== Implementation of Function mul(uint256,uint256) ===\nfunction mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a * b;\r\n    }\n    ""","{
  ""function_name"": ""function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a * b;\n        require(c / a == b, \""SafeMath: multiplication overflow\"");\n        return c;\n    }""
}",
0xbde84d825b1fe1e0e23db6b95f737cb841e0c343,RamppERC721A,mintToMultipleAL,"['SmartComment_no_comment', 'SmartComment_no_comment_no_diff']",FALSE,TRUE,"[1, 3, 4, 5]","[1, 2, 3, 4, 5]",Function requires fee payment unconditionally but comment states fee may be optional,fee may or may not be required*,"""\n=== Implementation of Function mintToMultipleAL(address,uint256,bytes32[]) ===\nfunction mintToMultipleAL(address _to, uint256 _amount, bytes32[] calldata _merkleProof) public payable {\r\n        require(onlyAllowlistMode == true && mintingOpen == true, \""Allowlist minting is closed\"");\r\n        require(isAllowlisted(_to, _merkleProof), \""Address is not in Allowlist!\"");\r\n        require(_amount >= 1, \""Must mint at least 1 token\"");\r\n        require(_amount <= maxBatchSize, \""Cannot mint more than max mint per transaction\"");\r\n\r\n        require(canMintAmount(_to, _amount), \""Wallet address is over the maximum allowed mints\"");\r\n        require(currentTokenId() + _amount <= collectionSize, \""Cannot mint over supply cap of 8888\"");\r\n        require(msg.value == getPrice(_amount), \""Value below required mint fee for amount\"");\r\n        \r\n\r\n        _safeMint(_to, _amount, false);\r\n    }\n    \n=== Functions that function mintToMultipleAL internally calls ===\nfunction _safeMint(address to, uint256 quantity, bool isAdminMint) internal {\r\n    _safeMint(to, quantity, isAdminMint, \""\"");\r\n  }\nfunction canMintAmount(address _address, uint256 _amount) public view returns(bool) {\r\n        require(_amount >= 1, \""Amount must be greater than or equal to 1\"");\r\n        return (_numberMinted(_address) + _amount) <= MAX_WALLET_MINTS;\r\n    }\nfunction currentTokenId() public view returns (uint256) {\r\n    return _totalMinted();\r\n  }\nfunction getPrice(uint256 _count) public view returns (uint256) {\r\n    return PRICE * _count;\r\n  }\nfunction isAllowlisted(address _to, bytes32[] calldata _merkleProof) public view returns(bool) {\r\n      require(merkleRoot != 0, \""Merkle root is not set!\"");\r\n      bytes32 leaf = keccak256(abi.encodePacked(_to));\r\n\r\n      return MerkleProof.verify(_merkleProof, merkleRoot, leaf);\r\n    }""","{
  ""mintToMultipleAL(address,uint256,bytes32[])"": ""function mintToMultipleAL(address _to, uint256 _amount, bytes32[] calldata _merkleProof) public payable {\n        require(onlyAllowlistMode == true && mintingOpen == true, \""Allowlist minting is closed\"");\n        require(isAllowlisted(_to, _merkleProof), \""Address is not in Allowlist!\"");\n        require(_amount >= 1, \""Must mint at least 1 token\"");\n        require(_amount <= maxBatchSize, \""Cannot mint more than max mint per transaction\"");\n        require(canMintAmount(_to, _amount), \""Wallet address is over the maximum allowed mints\"");\n        require(currentTokenId() + _amount <= collectionSize, \""Cannot mint over supply cap of 8888\"");\n        _safeMint(_to, _amount, false);\n    }""
}",
